<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>GPGPU-Sim: v3.x/src/gpgpu-sim/shader.cc Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_c934b74ccb33d6b9bfd1e576787940d8.html">v3.x</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_da58ad9beee6988f697f1a76e412a52a.html">src</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_d956d62670f5e9a38a62eba10b09b5c2.html">gpgpu-sim</a>
  </div>
</div>
<div class="contents">
<h1>shader.cc</h1><a href="shader_8cc.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// Copyright (c) 2009-2011, Tor M. Aamodt, Wilson W.L. Fung, Ali Bakhoda,</span>
<a name="l00002"></a>00002 <span class="comment">// George L. Yuan, Andrew Turner, Inderpreet Singh </span>
<a name="l00003"></a>00003 <span class="comment">// The University of British Columbia</span>
<a name="l00004"></a>00004 <span class="comment">// All rights reserved.</span>
<a name="l00005"></a>00005 <span class="comment">//</span>
<a name="l00006"></a>00006 <span class="comment">// Redistribution and use in source and binary forms, with or without</span>
<a name="l00007"></a>00007 <span class="comment">// modification, are permitted provided that the following conditions are met:</span>
<a name="l00008"></a>00008 <span class="comment">//</span>
<a name="l00009"></a>00009 <span class="comment">// Redistributions of source code must retain the above copyright notice, this</span>
<a name="l00010"></a>00010 <span class="comment">// list of conditions and the following disclaimer.</span>
<a name="l00011"></a>00011 <span class="comment">// Redistributions in binary form must reproduce the above copyright notice, this</span>
<a name="l00012"></a>00012 <span class="comment">// list of conditions and the following disclaimer in the documentation and/or</span>
<a name="l00013"></a>00013 <span class="comment">// other materials provided with the distribution.</span>
<a name="l00014"></a>00014 <span class="comment">// Neither the name of The University of British Columbia nor the names of its</span>
<a name="l00015"></a>00015 <span class="comment">// contributors may be used to endorse or promote products derived from this</span>
<a name="l00016"></a>00016 <span class="comment">// software without specific prior written permission.</span>
<a name="l00017"></a>00017 <span class="comment">//</span>
<a name="l00018"></a>00018 <span class="comment">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND</span>
<a name="l00019"></a>00019 <span class="comment">// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<a name="l00020"></a>00020 <span class="comment">// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<a name="l00021"></a>00021 <span class="comment">// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE</span>
<a name="l00022"></a>00022 <span class="comment">// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<a name="l00023"></a>00023 <span class="comment">// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
<a name="l00024"></a>00024 <span class="comment">// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
<a name="l00025"></a>00025 <span class="comment">// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span>
<a name="l00026"></a>00026 <span class="comment">// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<a name="l00027"></a>00027 <span class="comment">// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;float.h&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="shader_8h.html">shader.h</a>&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="gpu-sim_8h.html">gpu-sim.h</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="addrdec_8h.html">addrdec.h</a>&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="dram_8h.html">dram.h</a>&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="stat-tool_8h.html">stat-tool.h</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="gpu-misc_8h.html">gpu-misc.h</a>&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;../cuda-sim/ptx_sim.h&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;../cuda-sim/ptx-stats.h&quot;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;../cuda-sim/cuda-sim.h&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;<a class="code" href="gpu-sim_8h.html">gpu-sim.h</a>&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;<a class="code" href="mem__fetch_8h.html">mem_fetch.h</a>&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;<a class="code" href="mem__latency__stat_8h.html">mem_latency_stat.h</a>&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;<a class="code" href="visualizer_8h.html">visualizer.h</a>&quot;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &quot;../statwrapper.h&quot;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;<a class="code" href="icnt__wrapper_8h.html">icnt_wrapper.h</a>&quot;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;limits.h&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &quot;<a class="code" href="traffic__breakdown_8h.html">traffic_breakdown.h</a>&quot;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;<a class="code" href="shader__trace_8h.html">shader_trace.h</a>&quot;</span>
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="preprocessor">#define PRIORITIZE_MSHR_OVER_WB 1</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span><span class="preprocessor">#define MAX(a,b) (((a)&gt;(b))?(a):(b))</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">#define MIN(a,b) (((a)&lt;(b))?(a):(b))</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span>    
<a name="l00054"></a>00054 
<a name="l00056"></a>00056 
<a name="l00057"></a><a class="code" href="classshader__core__ctx.html#aed71e2ca04337bdac201f2d54378d7e1">00057</a> std::list&lt;unsigned&gt; <a class="code" href="classshader__core__ctx.html#aed71e2ca04337bdac201f2d54378d7e1">shader_core_ctx::get_regs_written</a>( <span class="keyword">const</span> <a class="code" href="classinst__t.html">inst_t</a> &amp;fvt )<span class="keyword"> const</span>
<a name="l00058"></a>00058 <span class="keyword"></span>{
<a name="l00059"></a>00059    std::list&lt;unsigned&gt; result;
<a name="l00060"></a>00060    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> op=0; op &lt; MAX_REG_OPERANDS; op++ ) {
<a name="l00061"></a>00061       <span class="keywordtype">int</span> reg_num = fvt.<a class="code" href="classinst__t.html#a88db6b095dc8d40a932891f69e4baa27">arch_reg</a>.<a class="code" href="classinst__t.html#a11e33f6b6e83bcea0590fa5de1c3dc7b">dst</a>[op]; <span class="comment">// this math needs to match that used in function_info::ptx_decode_inst</span>
<a name="l00062"></a>00062       <span class="keywordflow">if</span>( reg_num &gt;= 0 ) <span class="comment">// valid register</span>
<a name="l00063"></a>00063          result.push_back(reg_num);
<a name="l00064"></a>00064    }
<a name="l00065"></a>00065    <span class="keywordflow">return</span> result;
<a name="l00066"></a>00066 }
<a name="l00067"></a>00067 
<a name="l00068"></a><a class="code" href="classshader__core__ctx.html#ae0135cd740eab18089bdf5cf5e92702c">00068</a> <a class="code" href="classshader__core__ctx.html#ae0135cd740eab18089bdf5cf5e92702c">shader_core_ctx::shader_core_ctx</a>( <span class="keyword">class</span> <a class="code" href="classgpgpu__sim.html">gpgpu_sim</a> *gpu, 
<a name="l00069"></a>00069                                   <span class="keyword">class</span> <a class="code" href="classsimt__core__cluster.html">simt_core_cluster</a> *cluster,
<a name="l00070"></a>00070                                   <span class="keywordtype">unsigned</span> shader_id,
<a name="l00071"></a>00071                                   <span class="keywordtype">unsigned</span> tpc_id,
<a name="l00072"></a>00072                                   <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structshader__core__config.html">shader_core_config</a> *config,
<a name="l00073"></a>00073                                   <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structmemory__config.html">memory_config</a> *mem_config,
<a name="l00074"></a>00074                                   <a class="code" href="classshader__core__stats.html">shader_core_stats</a> *stats )
<a name="l00075"></a>00075    : <a class="code" href="classcore__t.html">core_t</a>( gpu, NULL, config-&gt;warp_size, config-&gt;n_thread_per_shader ),
<a name="l00076"></a>00076      m_barriers( config-&gt;max_warps_per_shader, config-&gt;max_cta_per_core ),
<a name="l00077"></a>00077      m_dynamic_warp_id(0)
<a name="l00078"></a>00078 {
<a name="l00079"></a>00079     <a class="code" href="classshader__core__ctx.html#a1f3c751f1d15c5b428a267a2eb766005">m_cluster</a> = cluster;
<a name="l00080"></a>00080     <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a> = config;
<a name="l00081"></a>00081     <a class="code" href="classshader__core__ctx.html#a1914ee82d2d4d1bc6433e9efdc9b45f9">m_memory_config</a> = mem_config;
<a name="l00082"></a>00082     <a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a> = stats;
<a name="l00083"></a>00083     <span class="keywordtype">unsigned</span> warp_size=config-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>;
<a name="l00084"></a>00084     
<a name="l00085"></a>00085     <a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a> = shader_id;
<a name="l00086"></a>00086     <a class="code" href="classshader__core__ctx.html#a74e020dbe1f39b0128d442b9468a51a4">m_tpc</a> = tpc_id;
<a name="l00087"></a>00087     
<a name="l00088"></a>00088     <a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>.reserve(<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21af07130bf590c52f42ff38ade3eb03c28">N_PIPELINE_STAGES</a>);
<a name="l00089"></a>00089     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j&lt;<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21af07130bf590c52f42ff38ade3eb03c28">N_PIPELINE_STAGES</a>; j++) {
<a name="l00090"></a>00090         <a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>.push_back(<a class="code" href="classregister__set.html">register_set</a>(<a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#ad2693743383b428410fee8a5259e2551">pipe_widths</a>[j],<a class="code" href="shader_8h.html#ac28bf9e6cd1d215249a70a7a1fb5acc5">pipeline_stage_name_decode</a>[j]));
<a name="l00091"></a>00091     }
<a name="l00092"></a>00092     
<a name="l00093"></a>00093     <a class="code" href="classshader__core__ctx.html#a1a699f42a6fb2ad03d3520d6361131a8">m_threadState</a> = (<a class="code" href="classthread__ctx__t.html">thread_ctx_t</a>*) calloc(<span class="keyword">sizeof</span>(<a class="code" href="classthread__ctx__t.html">thread_ctx_t</a>), config-&gt;<a class="code" href="structshader__core__config.html#a559092b8eaeffafe04a61f83cefe74d2">n_thread_per_shader</a>);
<a name="l00094"></a>00094     
<a name="l00095"></a>00095     <a class="code" href="classshader__core__ctx.html#a7e78acc4c95880eff06c9afcb65f62d0">m_not_completed</a> = 0;
<a name="l00096"></a>00096     <a class="code" href="classshader__core__ctx.html#a75ddec0750ed9a01b1f429bf048b7e0e">m_active_threads</a>.reset();
<a name="l00097"></a>00097     <a class="code" href="classshader__core__ctx.html#ababdc62e6b237cf2e3b2750138aef598">m_n_active_cta</a> = 0;
<a name="l00098"></a>00098     <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> i = 0; i&lt;MAX_CTA_PER_SHADER; i++ ) 
<a name="l00099"></a>00099         <a class="code" href="classshader__core__ctx.html#a0e6fc50e22a7c340b34556009f23de13">m_cta_status</a>[i]=0;
<a name="l00100"></a>00100     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i&lt;config-&gt;<a class="code" href="structshader__core__config.html#a559092b8eaeffafe04a61f83cefe74d2">n_thread_per_shader</a>; i++) {
<a name="l00101"></a>00101         <a class="code" href="classcore__t.html#a74ac58fba7a6ecd53ba31705ba5c38cd">m_thread</a>[i]= NULL;
<a name="l00102"></a>00102         <a class="code" href="classshader__core__ctx.html#a1a699f42a6fb2ad03d3520d6361131a8">m_threadState</a>[i].<a class="code" href="classthread__ctx__t.html#ab454d9215a73ad0678eb03184897142d">m_cta_id</a> = -1;
<a name="l00103"></a>00103         <a class="code" href="classshader__core__ctx.html#a1a699f42a6fb2ad03d3520d6361131a8">m_threadState</a>[i].<a class="code" href="classthread__ctx__t.html#a39b1b4dd36b2b6e6e13cbe08aa199498">m_active</a> = <span class="keyword">false</span>;
<a name="l00104"></a>00104     }
<a name="l00105"></a>00105     
<a name="l00106"></a>00106     <span class="comment">// m_icnt = new shader_memory_interface(this,cluster);</span>
<a name="l00107"></a>00107     <span class="keywordflow">if</span> ( <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#abe1f48d1bf3b8b7ec3531f957e15bbe1">gpgpu_perfect_mem</a> ) {
<a name="l00108"></a>00108         <a class="code" href="classshader__core__ctx.html#af43ebdc81717290b7ca24a3e689298c5">m_icnt</a> = <span class="keyword">new</span> <a class="code" href="classperfect__memory__interface.html">perfect_memory_interface</a>(<span class="keyword">this</span>,cluster);
<a name="l00109"></a>00109     } <span class="keywordflow">else</span> {
<a name="l00110"></a>00110         <a class="code" href="classshader__core__ctx.html#af43ebdc81717290b7ca24a3e689298c5">m_icnt</a> = <span class="keyword">new</span> <a class="code" href="classshader__memory__interface.html">shader_memory_interface</a>(<span class="keyword">this</span>,cluster);
<a name="l00111"></a>00111     }
<a name="l00112"></a>00112     <a class="code" href="classshader__core__ctx.html#a8315a5e471ff21243f635864aa31573e">m_mem_fetch_allocator</a> = <span class="keyword">new</span> <a class="code" href="classshader__core__mem__fetch__allocator.html">shader_core_mem_fetch_allocator</a>(shader_id,tpc_id,mem_config);
<a name="l00113"></a>00113     
<a name="l00114"></a>00114     <span class="comment">// fetch</span>
<a name="l00115"></a>00115     <a class="code" href="classshader__core__ctx.html#a7d677bf174ea63c5ea69dabec7a88726">m_last_warp_fetched</a> = 0;
<a name="l00116"></a>00116     
<a name="l00117"></a>00117 <span class="preprocessor">    #define STRSIZE 1024</span>
<a name="l00118"></a>00118 <span class="preprocessor"></span>    <span class="keywordtype">char</span> name[STRSIZE];
<a name="l00119"></a>00119     snprintf(name, STRSIZE, <span class="stringliteral">&quot;L1I_%03d&quot;</span>, <a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>);
<a name="l00120"></a>00120     <a class="code" href="classshader__core__ctx.html#ab4e5da01591cc8c202069addf3afad1c">m_L1I</a> = <span class="keyword">new</span> <a class="code" href="classread__only__cache.html" title="Read only cache.">read_only_cache</a>( name,<a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#ae5bc9b8f23f27a0cf437dd3f4bf1a497">m_L1I_config</a>,<a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>,<a class="code" href="stat-tool_8cc.html#a7c1d124be36b52ff4904d76971b6cb67">get_shader_instruction_cache_id</a>(),<a class="code" href="classshader__core__ctx.html#af43ebdc81717290b7ca24a3e689298c5">m_icnt</a>,IN_L1I_MISS_QUEUE);
<a name="l00121"></a>00121     
<a name="l00122"></a>00122     <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>.resize(<a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a9cacf20235b1c230a4d99920fc4b577e">max_warps_per_shader</a>, <a class="code" href="classshd__warp__t.html">shd_warp_t</a>(<span class="keyword">this</span>, warp_size));
<a name="l00123"></a>00123     <a class="code" href="classshader__core__ctx.html#aeeef0a2c13838c8d65a9614c2c7610f4">m_scoreboard</a> = <span class="keyword">new</span> <a class="code" href="classScoreboard.html">Scoreboard</a>(<a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>, <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a9cacf20235b1c230a4d99920fc4b577e">max_warps_per_shader</a>);
<a name="l00124"></a>00124     
<a name="l00125"></a>00125     <span class="comment">//scedulers</span>
<a name="l00126"></a>00126     <span class="comment">//must currently occur after all inputs have been initialized.</span>
<a name="l00127"></a>00127     std::string sched_config = <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a54e1d00c133d667243fd74c450e26d00">gpgpu_scheduler_string</a>;
<a name="l00128"></a>00128     <span class="keyword">const</span> <a class="code" href="shader_8h.html#a2f4453ea54b151f45cbcbd4f5659cb01">concrete_scheduler</a> scheduler = sched_config.find(<span class="stringliteral">&quot;lrr&quot;</span>) != std::string::npos ?
<a name="l00129"></a>00129                                          <a class="code" href="shader_8h.html#a2f4453ea54b151f45cbcbd4f5659cb01a89ae4e11f4ed251ac714dba453dd95ed">CONCRETE_SCHEDULER_LRR</a> :
<a name="l00130"></a>00130                                          sched_config.find(<span class="stringliteral">&quot;two_level_active&quot;</span>) != std::string::npos ?
<a name="l00131"></a>00131                                          <a class="code" href="shader_8h.html#a2f4453ea54b151f45cbcbd4f5659cb01a83b31b929ef1c7da45614fa4f558987a">CONCRETE_SCHEDULER_TWO_LEVEL_ACTIVE</a> :
<a name="l00132"></a>00132                                          sched_config.find(<span class="stringliteral">&quot;gto&quot;</span>) != std::string::npos ?
<a name="l00133"></a>00133                                          <a class="code" href="shader_8h.html#a2f4453ea54b151f45cbcbd4f5659cb01ac252f931cf22435304170fd10cce186b">CONCRETE_SCHEDULER_GTO</a> :
<a name="l00134"></a>00134                                          sched_config.find(<span class="stringliteral">&quot;warp_limiting&quot;</span>) != std::string::npos ?
<a name="l00135"></a>00135                                          <a class="code" href="shader_8h.html#a2f4453ea54b151f45cbcbd4f5659cb01ad007d8f43441c62ff4e7181ccb1f37c7">CONCRETE_SCHEDULER_WARP_LIMITING</a>:
<a name="l00136"></a>00136                                          <a class="code" href="shader_8h.html#a2f4453ea54b151f45cbcbd4f5659cb01ae38ac43927f738ed8f753fa378d435f9">NUM_CONCRETE_SCHEDULERS</a>;
<a name="l00137"></a>00137     assert ( scheduler != <a class="code" href="shader_8h.html#a2f4453ea54b151f45cbcbd4f5659cb01ae38ac43927f738ed8f753fa378d435f9">NUM_CONCRETE_SCHEDULERS</a> );
<a name="l00138"></a>00138     
<a name="l00139"></a>00139     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#acbc9904a0cd126e165f258b7750b8262">gpgpu_num_sched_per_core</a>; i++) {
<a name="l00140"></a>00140         <span class="keywordflow">switch</span>( scheduler )
<a name="l00141"></a>00141         {
<a name="l00142"></a>00142             <span class="keywordflow">case</span> <a class="code" href="shader_8h.html#a2f4453ea54b151f45cbcbd4f5659cb01a89ae4e11f4ed251ac714dba453dd95ed">CONCRETE_SCHEDULER_LRR</a>:
<a name="l00143"></a>00143                 <a class="code" href="classshader__core__ctx.html#ad5ec859a2adc916cbecf8255ba6c7c9e">schedulers</a>.push_back(
<a name="l00144"></a>00144                     <span class="keyword">new</span> <a class="code" href="classlrr__scheduler.html">lrr_scheduler</a>( <a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a>,
<a name="l00145"></a>00145                                        <span class="keyword">this</span>,
<a name="l00146"></a>00146                                        <a class="code" href="classshader__core__ctx.html#aeeef0a2c13838c8d65a9614c2c7610f4">m_scoreboard</a>,
<a name="l00147"></a>00147                                        <a class="code" href="classcore__t.html#abc85a3fb05c778cd6c06c95863a47ed6">m_simt_stack</a>,
<a name="l00148"></a>00148                                        &amp;<a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>,
<a name="l00149"></a>00149                                        &amp;<a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21a8906d4c229220a3101c3aaf602f414f3">ID_OC_SP</a>],
<a name="l00150"></a>00150                                        &amp;<a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21ae330780e8613942a40634f3ab5367a40">ID_OC_SFU</a>],
<a name="l00151"></a>00151                                        &amp;<a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21a0aec5a1493aa8cc7ca9b99b013149d91">ID_OC_MEM</a>],
<a name="l00152"></a>00152                                        i
<a name="l00153"></a>00153                                      )
<a name="l00154"></a>00154                 );
<a name="l00155"></a>00155                 <span class="keywordflow">break</span>;
<a name="l00156"></a>00156             <span class="keywordflow">case</span> <a class="code" href="shader_8h.html#a2f4453ea54b151f45cbcbd4f5659cb01a83b31b929ef1c7da45614fa4f558987a">CONCRETE_SCHEDULER_TWO_LEVEL_ACTIVE</a>:
<a name="l00157"></a>00157                 <a class="code" href="classshader__core__ctx.html#ad5ec859a2adc916cbecf8255ba6c7c9e">schedulers</a>.push_back(
<a name="l00158"></a>00158                     <span class="keyword">new</span> <a class="code" href="classtwo__level__active__scheduler.html">two_level_active_scheduler</a>( <a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a>,
<a name="l00159"></a>00159                                                     <span class="keyword">this</span>,
<a name="l00160"></a>00160                                                     <a class="code" href="classshader__core__ctx.html#aeeef0a2c13838c8d65a9614c2c7610f4">m_scoreboard</a>,
<a name="l00161"></a>00161                                                     <a class="code" href="classcore__t.html#abc85a3fb05c778cd6c06c95863a47ed6">m_simt_stack</a>,
<a name="l00162"></a>00162                                                     &amp;<a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>,
<a name="l00163"></a>00163                                                     &amp;<a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[ID_OC_SP],
<a name="l00164"></a>00164                                                     &amp;<a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[ID_OC_SFU],
<a name="l00165"></a>00165                                                     &amp;<a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[ID_OC_MEM],
<a name="l00166"></a>00166                                                     i,
<a name="l00167"></a>00167                                                     config-&gt;<a class="code" href="structshader__core__config.html#a54e1d00c133d667243fd74c450e26d00">gpgpu_scheduler_string</a>
<a name="l00168"></a>00168                                                   )
<a name="l00169"></a>00169                 );
<a name="l00170"></a>00170                 <span class="keywordflow">break</span>;
<a name="l00171"></a>00171             <span class="keywordflow">case</span> <a class="code" href="shader_8h.html#a2f4453ea54b151f45cbcbd4f5659cb01ac252f931cf22435304170fd10cce186b">CONCRETE_SCHEDULER_GTO</a>:
<a name="l00172"></a>00172                 <a class="code" href="classshader__core__ctx.html#ad5ec859a2adc916cbecf8255ba6c7c9e">schedulers</a>.push_back(
<a name="l00173"></a>00173                     <span class="keyword">new</span> <a class="code" href="classgto__scheduler.html">gto_scheduler</a>( <a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a>,
<a name="l00174"></a>00174                                        <span class="keyword">this</span>,
<a name="l00175"></a>00175                                        <a class="code" href="classshader__core__ctx.html#aeeef0a2c13838c8d65a9614c2c7610f4">m_scoreboard</a>,
<a name="l00176"></a>00176                                        <a class="code" href="classcore__t.html#abc85a3fb05c778cd6c06c95863a47ed6">m_simt_stack</a>,
<a name="l00177"></a>00177                                        &amp;<a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>,
<a name="l00178"></a>00178                                        &amp;<a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[ID_OC_SP],
<a name="l00179"></a>00179                                        &amp;<a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[ID_OC_SFU],
<a name="l00180"></a>00180                                        &amp;<a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[ID_OC_MEM],
<a name="l00181"></a>00181                                        i
<a name="l00182"></a>00182                                      )
<a name="l00183"></a>00183                 );
<a name="l00184"></a>00184                 <span class="keywordflow">break</span>;
<a name="l00185"></a>00185             <span class="keywordflow">case</span> <a class="code" href="shader_8h.html#a2f4453ea54b151f45cbcbd4f5659cb01ad007d8f43441c62ff4e7181ccb1f37c7">CONCRETE_SCHEDULER_WARP_LIMITING</a>:
<a name="l00186"></a>00186                 <a class="code" href="classshader__core__ctx.html#ad5ec859a2adc916cbecf8255ba6c7c9e">schedulers</a>.push_back(
<a name="l00187"></a>00187                     <span class="keyword">new</span> <a class="code" href="classswl__scheduler.html">swl_scheduler</a>( <a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a>,
<a name="l00188"></a>00188                                        <span class="keyword">this</span>,
<a name="l00189"></a>00189                                        <a class="code" href="classshader__core__ctx.html#aeeef0a2c13838c8d65a9614c2c7610f4">m_scoreboard</a>,
<a name="l00190"></a>00190                                        <a class="code" href="classcore__t.html#abc85a3fb05c778cd6c06c95863a47ed6">m_simt_stack</a>,
<a name="l00191"></a>00191                                        &amp;<a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>,
<a name="l00192"></a>00192                                        &amp;<a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[ID_OC_SP],
<a name="l00193"></a>00193                                        &amp;<a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[ID_OC_SFU],
<a name="l00194"></a>00194                                        &amp;<a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[ID_OC_MEM],
<a name="l00195"></a>00195                                        i,
<a name="l00196"></a>00196                                        config-&gt;<a class="code" href="structshader__core__config.html#a54e1d00c133d667243fd74c450e26d00">gpgpu_scheduler_string</a>
<a name="l00197"></a>00197                                      )
<a name="l00198"></a>00198                 );
<a name="l00199"></a>00199                 <span class="keywordflow">break</span>;
<a name="l00200"></a>00200             <span class="keywordflow">default</span>:
<a name="l00201"></a>00201                 abort();
<a name="l00202"></a>00202         };
<a name="l00203"></a>00203     }
<a name="l00204"></a>00204     
<a name="l00205"></a>00205     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>.size(); i++) {
<a name="l00206"></a>00206         <span class="comment">//distribute i&apos;s evenly though schedulers;</span>
<a name="l00207"></a>00207         <a class="code" href="classshader__core__ctx.html#ad5ec859a2adc916cbecf8255ba6c7c9e">schedulers</a>[i%<a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#acbc9904a0cd126e165f258b7750b8262">gpgpu_num_sched_per_core</a>]-&gt;add_supervised_warp_id(i);
<a name="l00208"></a>00208     }
<a name="l00209"></a>00209     <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#acbc9904a0cd126e165f258b7750b8262">gpgpu_num_sched_per_core</a>; ++i ) {
<a name="l00210"></a>00210         <a class="code" href="classshader__core__ctx.html#ad5ec859a2adc916cbecf8255ba6c7c9e">schedulers</a>[i]-&gt;done_adding_supervised_warps();
<a name="l00211"></a>00211     }
<a name="l00212"></a>00212     
<a name="l00213"></a>00213     <span class="comment">//op collector configuration</span>
<a name="l00214"></a>00214     <span class="keyword">enum</span> { SP_CUS, SFU_CUS, MEM_CUS, GEN_CUS };
<a name="l00215"></a>00215     <a class="code" href="classshader__core__ctx.html#aa8578f91af32b531ca48ccc31b440973">m_operand_collector</a>.<a class="code" href="classopndcoll__rfu__t.html#a02c9ca36eb4f3baf021bccb73e658b33">add_cu_set</a>(SP_CUS, <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a53457a08bf2d19dda737cc132b16989a">gpgpu_operand_collector_num_units_sp</a>, <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#afa67a7971a48b15395f854853ccc93cf">gpgpu_operand_collector_num_out_ports_sp</a>);
<a name="l00216"></a>00216     <a class="code" href="classshader__core__ctx.html#aa8578f91af32b531ca48ccc31b440973">m_operand_collector</a>.<a class="code" href="classopndcoll__rfu__t.html#a02c9ca36eb4f3baf021bccb73e658b33">add_cu_set</a>(SFU_CUS, <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#ae78d4c05cc4f98ed9acaa864921d272d">gpgpu_operand_collector_num_units_sfu</a>, <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a84464911d1ece073c41b0c858df82e3b">gpgpu_operand_collector_num_out_ports_sfu</a>);
<a name="l00217"></a>00217     <a class="code" href="classshader__core__ctx.html#aa8578f91af32b531ca48ccc31b440973">m_operand_collector</a>.<a class="code" href="classopndcoll__rfu__t.html#a02c9ca36eb4f3baf021bccb73e658b33">add_cu_set</a>(MEM_CUS, <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#ab73488ba6bb1eb6601311c2a975a92de">gpgpu_operand_collector_num_units_mem</a>, <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a5a8d763354f5678054b8aff24a490e88">gpgpu_operand_collector_num_out_ports_mem</a>);
<a name="l00218"></a>00218     <a class="code" href="classshader__core__ctx.html#aa8578f91af32b531ca48ccc31b440973">m_operand_collector</a>.<a class="code" href="classopndcoll__rfu__t.html#a02c9ca36eb4f3baf021bccb73e658b33">add_cu_set</a>(GEN_CUS, <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a3567c407a7fe1d65209cde36a0a3513c">gpgpu_operand_collector_num_units_gen</a>, <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#aeee25df8ecc890ef089528c704588594">gpgpu_operand_collector_num_out_ports_gen</a>);
<a name="l00219"></a>00219     
<a name="l00220"></a>00220     <a class="code" href="classopndcoll__rfu__t.html#a3e5a94e058a2841cfc9cb221e444434a">opndcoll_rfu_t::port_vector_t</a> in_ports;
<a name="l00221"></a>00221     <a class="code" href="classopndcoll__rfu__t.html#a3e5a94e058a2841cfc9cb221e444434a">opndcoll_rfu_t::port_vector_t</a> out_ports;
<a name="l00222"></a>00222     <a class="code" href="classopndcoll__rfu__t.html#a8159dc2ca6e88edd6372fed5d93a01ab">opndcoll_rfu_t::uint_vector_t</a> cu_sets;
<a name="l00223"></a>00223     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#aec92aa2c172b0c53cf29d94888a3a047">gpgpu_operand_collector_num_in_ports_sp</a>; i++) {
<a name="l00224"></a>00224         in_ports.push_back(&amp;<a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21a8906d4c229220a3101c3aaf602f414f3">ID_OC_SP</a>]);
<a name="l00225"></a>00225         out_ports.push_back(&amp;<a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21a19d62a9704f4e4ed250a432c1f4b8d4f">OC_EX_SP</a>]);
<a name="l00226"></a>00226         cu_sets.push_back((<span class="keywordtype">unsigned</span>)SP_CUS);
<a name="l00227"></a>00227         cu_sets.push_back((<span class="keywordtype">unsigned</span>)GEN_CUS);
<a name="l00228"></a>00228         <a class="code" href="classshader__core__ctx.html#aa8578f91af32b531ca48ccc31b440973">m_operand_collector</a>.<a class="code" href="classopndcoll__rfu__t.html#a761c70919115cf9f27ac2b976aa9c7bc">add_port</a>(in_ports,out_ports,cu_sets);
<a name="l00229"></a>00229         in_ports.clear(),out_ports.clear(),cu_sets.clear();
<a name="l00230"></a>00230     }
<a name="l00231"></a>00231     
<a name="l00232"></a>00232     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#aa42ebc13df02a25e1aef0f95b187cdd2">gpgpu_operand_collector_num_in_ports_sfu</a>; i++) {
<a name="l00233"></a>00233         in_ports.push_back(&amp;<a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21ae330780e8613942a40634f3ab5367a40">ID_OC_SFU</a>]);
<a name="l00234"></a>00234         out_ports.push_back(&amp;<a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21a95905139a1a91a154c54466311d272ca">OC_EX_SFU</a>]);
<a name="l00235"></a>00235         cu_sets.push_back((<span class="keywordtype">unsigned</span>)SFU_CUS);
<a name="l00236"></a>00236         cu_sets.push_back((<span class="keywordtype">unsigned</span>)GEN_CUS);
<a name="l00237"></a>00237         <a class="code" href="classshader__core__ctx.html#aa8578f91af32b531ca48ccc31b440973">m_operand_collector</a>.<a class="code" href="classopndcoll__rfu__t.html#a761c70919115cf9f27ac2b976aa9c7bc">add_port</a>(in_ports,out_ports,cu_sets);
<a name="l00238"></a>00238         in_ports.clear(),out_ports.clear(),cu_sets.clear();
<a name="l00239"></a>00239     }
<a name="l00240"></a>00240     
<a name="l00241"></a>00241     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a533bc5530c6742ae62987b8f9cd5a2f9">gpgpu_operand_collector_num_in_ports_mem</a>; i++) {
<a name="l00242"></a>00242         in_ports.push_back(&amp;<a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21a0aec5a1493aa8cc7ca9b99b013149d91">ID_OC_MEM</a>]);
<a name="l00243"></a>00243         out_ports.push_back(&amp;<a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21a0e6236e164b5a60385779f3fdfebcbc7">OC_EX_MEM</a>]);
<a name="l00244"></a>00244         cu_sets.push_back((<span class="keywordtype">unsigned</span>)MEM_CUS);
<a name="l00245"></a>00245         cu_sets.push_back((<span class="keywordtype">unsigned</span>)GEN_CUS);                       
<a name="l00246"></a>00246         <a class="code" href="classshader__core__ctx.html#aa8578f91af32b531ca48ccc31b440973">m_operand_collector</a>.<a class="code" href="classopndcoll__rfu__t.html#a761c70919115cf9f27ac2b976aa9c7bc">add_port</a>(in_ports,out_ports,cu_sets);
<a name="l00247"></a>00247         in_ports.clear(),out_ports.clear(),cu_sets.clear();
<a name="l00248"></a>00248     }   
<a name="l00249"></a>00249     
<a name="l00250"></a>00250     
<a name="l00251"></a>00251     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#aec2ad572d5aebad6afba51606e88cc28">gpgpu_operand_collector_num_in_ports_gen</a>; i++) {
<a name="l00252"></a>00252         in_ports.push_back(&amp;<a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21a8906d4c229220a3101c3aaf602f414f3">ID_OC_SP</a>]);
<a name="l00253"></a>00253         in_ports.push_back(&amp;<a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21ae330780e8613942a40634f3ab5367a40">ID_OC_SFU</a>]);
<a name="l00254"></a>00254         in_ports.push_back(&amp;<a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21a0aec5a1493aa8cc7ca9b99b013149d91">ID_OC_MEM</a>]);
<a name="l00255"></a>00255         out_ports.push_back(&amp;<a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21a19d62a9704f4e4ed250a432c1f4b8d4f">OC_EX_SP</a>]);
<a name="l00256"></a>00256         out_ports.push_back(&amp;<a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21a95905139a1a91a154c54466311d272ca">OC_EX_SFU</a>]);
<a name="l00257"></a>00257         out_ports.push_back(&amp;<a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21a0e6236e164b5a60385779f3fdfebcbc7">OC_EX_MEM</a>]);
<a name="l00258"></a>00258         cu_sets.push_back((<span class="keywordtype">unsigned</span>)GEN_CUS);   
<a name="l00259"></a>00259         <a class="code" href="classshader__core__ctx.html#aa8578f91af32b531ca48ccc31b440973">m_operand_collector</a>.<a class="code" href="classopndcoll__rfu__t.html#a761c70919115cf9f27ac2b976aa9c7bc">add_port</a>(in_ports,out_ports,cu_sets);
<a name="l00260"></a>00260         in_ports.clear(),out_ports.clear(),cu_sets.clear();
<a name="l00261"></a>00261     }
<a name="l00262"></a>00262     
<a name="l00263"></a>00263     <a class="code" href="classshader__core__ctx.html#aa8578f91af32b531ca48ccc31b440973">m_operand_collector</a>.<a class="code" href="classopndcoll__rfu__t.html#a6a69c8d3f2952ce95e6ea8fffbbdba97">init</a>( <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a4f97efa5a84b7173f2f874f702a0c347">gpgpu_num_reg_banks</a>, <span class="keyword">this</span> );
<a name="l00264"></a>00264     
<a name="l00265"></a>00265     <span class="comment">// execute</span>
<a name="l00266"></a>00266     <a class="code" href="classshader__core__ctx.html#aba08149bdd564b125968d3a754e2b000">m_num_function_units</a> = <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a3cc41472a119df508e1bb3ca0ee46a33">gpgpu_num_sp_units</a> + <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#aab7e81974275b87773f7defdcfc551d5">gpgpu_num_sfu_units</a> + 1; <span class="comment">// sp_unit, sfu, ldst_unit</span>
<a name="l00267"></a>00267     <span class="comment">//m_dispatch_port = new enum pipeline_stage_name_t[ m_num_function_units ];</span>
<a name="l00268"></a>00268     <span class="comment">//m_issue_port = new enum pipeline_stage_name_t[ m_num_function_units ];</span>
<a name="l00269"></a>00269     
<a name="l00270"></a>00270     <span class="comment">//m_fu = new simd_function_unit*[m_num_function_units];</span>
<a name="l00271"></a>00271     
<a name="l00272"></a>00272     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a3cc41472a119df508e1bb3ca0ee46a33">gpgpu_num_sp_units</a>; k++) {
<a name="l00273"></a>00273         <a class="code" href="classshader__core__ctx.html#aac172c9e5d3c7dc27c45d09146fc8d0b">m_fu</a>.push_back(<span class="keyword">new</span> <a class="code" href="classsp__unit.html">sp_unit</a>( &amp;<a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21a410f62d642cfe93d252e8faf55b89ea3">EX_WB</a>], <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>, <span class="keyword">this</span> ));
<a name="l00274"></a>00274         <a class="code" href="classshader__core__ctx.html#a4db59347debacad5ef518ba7e95a3841">m_dispatch_port</a>.push_back(<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21a8906d4c229220a3101c3aaf602f414f3">ID_OC_SP</a>);
<a name="l00275"></a>00275         <a class="code" href="classshader__core__ctx.html#a859f0864a86d62266688f0c767da0506">m_issue_port</a>.push_back(<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21a19d62a9704f4e4ed250a432c1f4b8d4f">OC_EX_SP</a>);
<a name="l00276"></a>00276     }
<a name="l00277"></a>00277     
<a name="l00278"></a>00278     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#aab7e81974275b87773f7defdcfc551d5">gpgpu_num_sfu_units</a>; k++) {
<a name="l00279"></a>00279         <a class="code" href="classshader__core__ctx.html#aac172c9e5d3c7dc27c45d09146fc8d0b">m_fu</a>.push_back(<span class="keyword">new</span> <a class="code" href="classsfu.html">sfu</a>( &amp;<a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21a410f62d642cfe93d252e8faf55b89ea3">EX_WB</a>], <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>, <span class="keyword">this</span> ));
<a name="l00280"></a>00280         <a class="code" href="classshader__core__ctx.html#a4db59347debacad5ef518ba7e95a3841">m_dispatch_port</a>.push_back(<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21ae330780e8613942a40634f3ab5367a40">ID_OC_SFU</a>);
<a name="l00281"></a>00281         <a class="code" href="classshader__core__ctx.html#a859f0864a86d62266688f0c767da0506">m_issue_port</a>.push_back(<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21a95905139a1a91a154c54466311d272ca">OC_EX_SFU</a>);
<a name="l00282"></a>00282     }
<a name="l00283"></a>00283     
<a name="l00284"></a>00284     <a class="code" href="classshader__core__ctx.html#a11facb48161a3079025f0602e276969b">m_ldst_unit</a> = <span class="keyword">new</span> <a class="code" href="classldst__unit.html">ldst_unit</a>( <a class="code" href="classshader__core__ctx.html#af43ebdc81717290b7ca24a3e689298c5">m_icnt</a>, <a class="code" href="classshader__core__ctx.html#a8315a5e471ff21243f635864aa31573e">m_mem_fetch_allocator</a>, <span class="keyword">this</span>, &amp;<a class="code" href="classshader__core__ctx.html#aa8578f91af32b531ca48ccc31b440973">m_operand_collector</a>, <a class="code" href="classshader__core__ctx.html#aeeef0a2c13838c8d65a9614c2c7610f4">m_scoreboard</a>, config, mem_config, stats, shader_id, tpc_id );
<a name="l00285"></a>00285     <a class="code" href="classshader__core__ctx.html#aac172c9e5d3c7dc27c45d09146fc8d0b">m_fu</a>.push_back(<a class="code" href="classshader__core__ctx.html#a11facb48161a3079025f0602e276969b">m_ldst_unit</a>);
<a name="l00286"></a>00286     <a class="code" href="classshader__core__ctx.html#a4db59347debacad5ef518ba7e95a3841">m_dispatch_port</a>.push_back(<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21a0aec5a1493aa8cc7ca9b99b013149d91">ID_OC_MEM</a>);
<a name="l00287"></a>00287     <a class="code" href="classshader__core__ctx.html#a859f0864a86d62266688f0c767da0506">m_issue_port</a>.push_back(<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21a0e6236e164b5a60385779f3fdfebcbc7">OC_EX_MEM</a>);
<a name="l00288"></a>00288     
<a name="l00289"></a>00289     assert(<a class="code" href="classshader__core__ctx.html#aba08149bdd564b125968d3a754e2b000">m_num_function_units</a> == <a class="code" href="classshader__core__ctx.html#aac172c9e5d3c7dc27c45d09146fc8d0b">m_fu</a>.size() and <a class="code" href="classshader__core__ctx.html#aac172c9e5d3c7dc27c45d09146fc8d0b">m_fu</a>.size() == <a class="code" href="classshader__core__ctx.html#a4db59347debacad5ef518ba7e95a3841">m_dispatch_port</a>.size() and <a class="code" href="classshader__core__ctx.html#aac172c9e5d3c7dc27c45d09146fc8d0b">m_fu</a>.size() == <a class="code" href="classshader__core__ctx.html#a859f0864a86d62266688f0c767da0506">m_issue_port</a>.size());
<a name="l00290"></a>00290     
<a name="l00291"></a>00291     <span class="comment">//there are as many result buses as the width of the EX_WB stage</span>
<a name="l00292"></a>00292     <a class="code" href="classshader__core__ctx.html#af3d87025a8db5074483bd4d93e135e16">num_result_bus</a> = config-&gt;<a class="code" href="structshader__core__config.html#ad2693743383b428410fee8a5259e2551">pipe_widths</a>[<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21a410f62d642cfe93d252e8faf55b89ea3">EX_WB</a>];
<a name="l00293"></a>00293     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0; i&lt;num_result_bus; i++){
<a name="l00294"></a>00294         this-&gt;<a class="code" href="classshader__core__ctx.html#abe3ba763b1358db760c2dd1d55865763">m_result_bus</a>.push_back(<span class="keyword">new</span> std::bitset&lt;MAX_ALU_LATENCY&gt;());
<a name="l00295"></a>00295     }
<a name="l00296"></a>00296     
<a name="l00297"></a>00297     <a class="code" href="classshader__core__ctx.html#ab4becab0479eefe9e3bb7c97e63f9b27">m_last_inst_gpu_sim_cycle</a> = 0;
<a name="l00298"></a>00298     <a class="code" href="classshader__core__ctx.html#a663a5f525e11a9e5dce120d7976aa24c">m_last_inst_gpu_tot_sim_cycle</a> = 0;
<a name="l00299"></a>00299 }
<a name="l00300"></a>00300 
<a name="l00301"></a><a class="code" href="classshader__core__ctx.html#ac84a2e7f125c497a9a2c7fa09fe49624">00301</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#ac84a2e7f125c497a9a2c7fa09fe49624">shader_core_ctx::reinit</a>(<span class="keywordtype">unsigned</span> start_thread, <span class="keywordtype">unsigned</span> end_thread, <span class="keywordtype">bool</span> reset_not_completed ) 
<a name="l00302"></a>00302 {
<a name="l00303"></a>00303    <span class="keywordflow">if</span>( reset_not_completed ) {
<a name="l00304"></a>00304        <a class="code" href="classshader__core__ctx.html#a7e78acc4c95880eff06c9afcb65f62d0">m_not_completed</a> = 0;
<a name="l00305"></a>00305        <a class="code" href="classshader__core__ctx.html#a75ddec0750ed9a01b1f429bf048b7e0e">m_active_threads</a>.reset();
<a name="l00306"></a>00306    }
<a name="l00307"></a>00307    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = start_thread; i&lt;end_thread; i++) {
<a name="l00308"></a>00308       <a class="code" href="classshader__core__ctx.html#a1a699f42a6fb2ad03d3520d6361131a8">m_threadState</a>[i].<a class="code" href="classthread__ctx__t.html#a7a37702c849b4c93fe9b86a5fe023fa3">n_insn</a> = 0;
<a name="l00309"></a>00309       <a class="code" href="classshader__core__ctx.html#a1a699f42a6fb2ad03d3520d6361131a8">m_threadState</a>[i].<a class="code" href="classthread__ctx__t.html#ab454d9215a73ad0678eb03184897142d">m_cta_id</a> = -1;
<a name="l00310"></a>00310    }
<a name="l00311"></a>00311    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = start_thread / <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>; i &lt; end_thread / m_config-&gt;warp_size; ++i) {
<a name="l00312"></a>00312       <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[i].reset();
<a name="l00313"></a>00313       <a class="code" href="classcore__t.html#abc85a3fb05c778cd6c06c95863a47ed6">m_simt_stack</a>[i]-&gt;<a class="code" href="classsimt__stack.html#a7dbef33d6da7f2e4bfec8594a361b72a">reset</a>();
<a name="l00314"></a>00314    }
<a name="l00315"></a>00315 }
<a name="l00316"></a>00316 
<a name="l00317"></a><a class="code" href="classshader__core__ctx.html#a8c68b7b9ffb958153af4d24008a9a4f7">00317</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#a8c68b7b9ffb958153af4d24008a9a4f7">shader_core_ctx::init_warps</a>( <span class="keywordtype">unsigned</span> cta_id, <span class="keywordtype">unsigned</span> start_thread, <span class="keywordtype">unsigned</span> end_thread )
<a name="l00318"></a>00318 {
<a name="l00319"></a>00319     <a class="code" href="abstract__hardware__model_8h.html#a4234d30919c0dcca6fca040a13ad6ae1">address_type</a> start_pc = <a class="code" href="classshader__core__ctx.html#a7774b19ba56fae8798b3c1b99cf6e178">next_pc</a>(start_thread);
<a name="l00320"></a>00320     <span class="keywordflow">if</span> (<a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#abd0a32b3d0fec341d656455aff2f66b7">model</a> == <a class="code" href="abstract__hardware__model_8h.html#a3c3e5c822956df0d19e61cbb11c5b12ba31993dfb97df7a2ea5aa5a9504b96c72">POST_DOMINATOR</a>) {
<a name="l00321"></a>00321         <span class="keywordtype">unsigned</span> start_warp = start_thread / <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>;
<a name="l00322"></a>00322         <span class="keywordtype">unsigned</span> end_warp = end_thread / <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a> + ((end_thread % <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>)? 1 : 0);
<a name="l00323"></a>00323         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = start_warp; i &lt; end_warp; ++i) {
<a name="l00324"></a>00324             <span class="keywordtype">unsigned</span> n_active=0;
<a name="l00325"></a>00325             <a class="code" href="abstract__hardware__model_8h.html#a72368cab3b31c68552473dbc5f4bd1bf">simt_mask_t</a> active_threads;
<a name="l00326"></a>00326             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> t = 0; t &lt; <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>; t++) {
<a name="l00327"></a>00327                 <span class="keywordtype">unsigned</span> hwtid = i * <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a> + t;
<a name="l00328"></a>00328                 <span class="keywordflow">if</span> ( hwtid &lt; end_thread ) {
<a name="l00329"></a>00329                     n_active++;
<a name="l00330"></a>00330                     assert( !<a class="code" href="classshader__core__ctx.html#a75ddec0750ed9a01b1f429bf048b7e0e">m_active_threads</a>.test(hwtid) );
<a name="l00331"></a>00331                     <a class="code" href="classshader__core__ctx.html#a75ddec0750ed9a01b1f429bf048b7e0e">m_active_threads</a>.set( hwtid );
<a name="l00332"></a>00332                     active_threads.set(t);
<a name="l00333"></a>00333                 }
<a name="l00334"></a>00334             }
<a name="l00335"></a>00335             <a class="code" href="classcore__t.html#abc85a3fb05c778cd6c06c95863a47ed6">m_simt_stack</a>[i]-&gt;<a class="code" href="classsimt__stack.html#a325140cfa69adf965d360790aa3412b9">launch</a>(start_pc,active_threads);
<a name="l00336"></a>00336             <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[i].init(start_pc,cta_id,i,active_threads, <a class="code" href="classshader__core__ctx.html#ada285fd9adeabde794123a84eaf2102f">m_dynamic_warp_id</a>);
<a name="l00337"></a>00337             ++<a class="code" href="classshader__core__ctx.html#ada285fd9adeabde794123a84eaf2102f">m_dynamic_warp_id</a>;
<a name="l00338"></a>00338             <a class="code" href="classshader__core__ctx.html#a7e78acc4c95880eff06c9afcb65f62d0">m_not_completed</a> += n_active;
<a name="l00339"></a>00339       }
<a name="l00340"></a>00340    }
<a name="l00341"></a>00341 }
<a name="l00342"></a>00342 
<a name="l00343"></a>00343 <span class="comment">// return the next pc of a thread </span>
<a name="l00344"></a><a class="code" href="classshader__core__ctx.html#a7774b19ba56fae8798b3c1b99cf6e178">00344</a> <a class="code" href="abstract__hardware__model_8h.html#a4234d30919c0dcca6fca040a13ad6ae1">address_type</a> <a class="code" href="classshader__core__ctx.html#a7774b19ba56fae8798b3c1b99cf6e178">shader_core_ctx::next_pc</a>( <span class="keywordtype">int</span> tid )<span class="keyword"> const</span>
<a name="l00345"></a>00345 <span class="keyword"></span>{
<a name="l00346"></a>00346     <span class="keywordflow">if</span>( tid == -1 ) 
<a name="l00347"></a>00347         <span class="keywordflow">return</span> -1;
<a name="l00348"></a>00348     <a class="code" href="classptx__thread__info.html">ptx_thread_info</a> *the_thread = <a class="code" href="classcore__t.html#a74ac58fba7a6ecd53ba31705ba5c38cd">m_thread</a>[tid];
<a name="l00349"></a>00349     <span class="keywordflow">if</span> ( the_thread == NULL )
<a name="l00350"></a>00350         <span class="keywordflow">return</span> -1;
<a name="l00351"></a>00351     <span class="keywordflow">return</span> the_thread-&gt;<a class="code" href="classptx__thread__info.html#a41b1e8fab5caac4c85f2e363b5857967">get_pc</a>(); <span class="comment">// PC should already be updatd to next PC at this point (was set in shader_decode() last time thread ran)</span>
<a name="l00352"></a>00352 }
<a name="l00353"></a>00353 
<a name="l00354"></a><a class="code" href="classgpgpu__sim.html#a588b1f73ab61883eb58cc3311fbd5d24">00354</a> <span class="keywordtype">void</span> <a class="code" href="classgpgpu__sim.html#a588b1f73ab61883eb58cc3311fbd5d24">gpgpu_sim::get_pdom_stack_top_info</a>( <span class="keywordtype">unsigned</span> sid, <span class="keywordtype">unsigned</span> tid, <span class="keywordtype">unsigned</span> *pc, <span class="keywordtype">unsigned</span> *rpc )
<a name="l00355"></a>00355 {
<a name="l00356"></a>00356     <span class="keywordtype">unsigned</span> cluster_id = <a class="code" href="classgpgpu__sim.html#a88a4e19b94bf5c3cfb7b05504527db9f">m_shader_config</a>-&gt;<a class="code" href="structshader__core__config.html#a5624eba922e66a992536b6a527496a6a">sid_to_cluster</a>(sid);
<a name="l00357"></a>00357     <a class="code" href="classgpgpu__sim.html#ae879377df64789d8591b6786afe6421c">m_cluster</a>[cluster_id]-&gt;<a class="code" href="classsimt__core__cluster.html#af90ed66c3f1d26b81bf2a2c6c05a69e4">get_pdom_stack_top_info</a>(sid,tid,pc,rpc);
<a name="l00358"></a>00358 }
<a name="l00359"></a>00359 
<a name="l00360"></a><a class="code" href="classshader__core__ctx.html#a2dacf18ba045bb4376ce5cca4581da99">00360</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#a2dacf18ba045bb4376ce5cca4581da99">shader_core_ctx::get_pdom_stack_top_info</a>( <span class="keywordtype">unsigned</span> tid, <span class="keywordtype">unsigned</span> *pc, <span class="keywordtype">unsigned</span> *rpc )<span class="keyword"> const</span>
<a name="l00361"></a>00361 <span class="keyword"></span>{
<a name="l00362"></a>00362     <span class="keywordtype">unsigned</span> warp_id = tid/<a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>;
<a name="l00363"></a>00363     <a class="code" href="classcore__t.html#abc85a3fb05c778cd6c06c95863a47ed6">m_simt_stack</a>[warp_id]-&gt;<a class="code" href="classsimt__stack.html#a6dc20c4969bbd3578891c2bb09db5081">get_pdom_stack_top_info</a>(pc,rpc);
<a name="l00364"></a>00364 }
<a name="l00365"></a>00365 
<a name="l00366"></a><a class="code" href="classshader__core__stats.html#ad40ffcdc2a884a42d19533edc8c3eb37">00366</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__stats.html#ad40ffcdc2a884a42d19533edc8c3eb37">shader_core_stats::print</a>( FILE* fout )<span class="keyword"> const</span>
<a name="l00367"></a>00367 <span class="keyword"></span>{
<a name="l00368"></a>00368     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>  thread_icount_uarch=0;
<a name="l00369"></a>00369     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>  warp_icount_uarch=0;
<a name="l00370"></a>00370 
<a name="l00371"></a>00371     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0; i &lt; <a class="code" href="classshader__core__stats.html#a249ff73257bad58fd68c143d18d63e29">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a30949c72f2ebab12287ca4e801dc0b49">num_shader</a>(); i++) {
<a name="l00372"></a>00372         thread_icount_uarch += <a class="code" href="structshader__core__stats__pod.html#a4ea030a625b67f9f2149ad0c09f144d1">m_num_sim_insn</a>[i];
<a name="l00373"></a>00373         warp_icount_uarch += <a class="code" href="structshader__core__stats__pod.html#a104d929981b7f61a21a3f32728e6ac9c">m_num_sim_winsn</a>[i];
<a name="l00374"></a>00374     }
<a name="l00375"></a>00375     fprintf(fout,<span class="stringliteral">&quot;gpgpu_n_tot_thrd_icount = %lld\n&quot;</span>, thread_icount_uarch);
<a name="l00376"></a>00376     fprintf(fout,<span class="stringliteral">&quot;gpgpu_n_tot_w_icount = %lld\n&quot;</span>, warp_icount_uarch);
<a name="l00377"></a>00377 
<a name="l00378"></a>00378     fprintf(fout,<span class="stringliteral">&quot;gpgpu_n_stall_shd_mem = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a932af1c7f7b0e3c8dc49f89fab80bc80">gpgpu_n_stall_shd_mem</a> );
<a name="l00379"></a>00379     fprintf(fout,<span class="stringliteral">&quot;gpgpu_n_mem_read_local = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a9c2ef17eb5ea99529c46dac56f6e3d43">gpgpu_n_mem_read_local</a>);
<a name="l00380"></a>00380     fprintf(fout,<span class="stringliteral">&quot;gpgpu_n_mem_write_local = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#aaf3d94f40863d9638d8d2941d7bc786a">gpgpu_n_mem_write_local</a>);
<a name="l00381"></a>00381     fprintf(fout,<span class="stringliteral">&quot;gpgpu_n_mem_read_global = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a2c3350864c49e362b1d6dae945ceab53">gpgpu_n_mem_read_global</a>);
<a name="l00382"></a>00382     fprintf(fout,<span class="stringliteral">&quot;gpgpu_n_mem_write_global = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#afebac3fd1caa9f3fe318c6aff1d0e90a">gpgpu_n_mem_write_global</a>);
<a name="l00383"></a>00383     fprintf(fout,<span class="stringliteral">&quot;gpgpu_n_mem_texture = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a531a02dc928208a1fed1981db287f8b6">gpgpu_n_mem_texture</a>);
<a name="l00384"></a>00384     fprintf(fout,<span class="stringliteral">&quot;gpgpu_n_mem_const = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#aa017876bbdc07c96da87f0320fcaff64">gpgpu_n_mem_const</a>);
<a name="l00385"></a>00385 
<a name="l00386"></a>00386    fprintf(fout, <span class="stringliteral">&quot;gpgpu_n_load_insn  = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a03b13edeb707df349da4a5918ab52164">gpgpu_n_load_insn</a>);
<a name="l00387"></a>00387    fprintf(fout, <span class="stringliteral">&quot;gpgpu_n_store_insn = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a094b5edb0dc9920044980fdcadc36fcb">gpgpu_n_store_insn</a>);
<a name="l00388"></a>00388    fprintf(fout, <span class="stringliteral">&quot;gpgpu_n_shmem_insn = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#abd0fa14088586f71bd0e4939ec2b022f">gpgpu_n_shmem_insn</a>);
<a name="l00389"></a>00389    fprintf(fout, <span class="stringliteral">&quot;gpgpu_n_tex_insn = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a8f6c1cde5e9c35dc0c916f7f811d1273">gpgpu_n_tex_insn</a>);
<a name="l00390"></a>00390    fprintf(fout, <span class="stringliteral">&quot;gpgpu_n_const_mem_insn = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a51167d1f1abde004925e2fc695c0bbea">gpgpu_n_const_insn</a>);
<a name="l00391"></a>00391    fprintf(fout, <span class="stringliteral">&quot;gpgpu_n_param_mem_insn = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#aa1aedf0dc235de85343b75048061fe4b">gpgpu_n_param_insn</a>);
<a name="l00392"></a>00392 
<a name="l00393"></a>00393    fprintf(fout, <span class="stringliteral">&quot;gpgpu_n_shmem_bkconflict = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a6d36181031418a3a8e92d7b411a87085">gpgpu_n_shmem_bkconflict</a>);
<a name="l00394"></a>00394    fprintf(fout, <span class="stringliteral">&quot;gpgpu_n_cache_bkconflict = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#ad5d01a838269da68a374cbd39a81bac8">gpgpu_n_cache_bkconflict</a>);   
<a name="l00395"></a>00395 
<a name="l00396"></a>00396    fprintf(fout, <span class="stringliteral">&quot;gpgpu_n_intrawarp_mshr_merge = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#ad5c8ced7064a3c1e6bab3e813b06dbf0">gpgpu_n_intrawarp_mshr_merge</a>);
<a name="l00397"></a>00397    fprintf(fout, <span class="stringliteral">&quot;gpgpu_n_cmem_portconflict = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a127137bb46f65167a8359e1a8896780c">gpgpu_n_cmem_portconflict</a>);
<a name="l00398"></a>00398 
<a name="l00399"></a>00399    fprintf(fout, <span class="stringliteral">&quot;gpgpu_stall_shd_mem[c_mem][bk_conf] = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba64e2520dc68772a0eb40cd5d374b2e6b">C_MEM</a>][<a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7aeff5b672a5cc1e217a576cf635b173f4">BK_CONF</a>]);
<a name="l00400"></a>00400    fprintf(fout, <span class="stringliteral">&quot;gpgpu_stall_shd_mem[c_mem][mshr_rc] = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba64e2520dc68772a0eb40cd5d374b2e6b">C_MEM</a>][<a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7af5a378ef16b96b5229f796e775b35187">MSHR_RC_FAIL</a>]);
<a name="l00401"></a>00401    fprintf(fout, <span class="stringliteral">&quot;gpgpu_stall_shd_mem[c_mem][icnt_rc] = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba64e2520dc68772a0eb40cd5d374b2e6b">C_MEM</a>][<a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7a7ffa00b440a82b64996be240be743ea2">ICNT_RC_FAIL</a>]);
<a name="l00402"></a>00402    fprintf(fout, <span class="stringliteral">&quot;gpgpu_stall_shd_mem[c_mem][data_port_stall] = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba64e2520dc68772a0eb40cd5d374b2e6b">C_MEM</a>][<a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7aeecc08cc96a1660a2f6aac0e0748f0a0">DATA_PORT_STALL</a>]);
<a name="l00403"></a>00403    fprintf(fout, <span class="stringliteral">&quot;gpgpu_stall_shd_mem[t_mem][mshr_rc] = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba5705e3ad2281df35ebcedce51899ce5e">T_MEM</a>][MSHR_RC_FAIL]);
<a name="l00404"></a>00404    fprintf(fout, <span class="stringliteral">&quot;gpgpu_stall_shd_mem[t_mem][icnt_rc] = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba5705e3ad2281df35ebcedce51899ce5e">T_MEM</a>][ICNT_RC_FAIL]);
<a name="l00405"></a>00405    fprintf(fout, <span class="stringliteral">&quot;gpgpu_stall_shd_mem[t_mem][data_port_stall] = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba5705e3ad2281df35ebcedce51899ce5e">T_MEM</a>][DATA_PORT_STALL]);
<a name="l00406"></a>00406    fprintf(fout, <span class="stringliteral">&quot;gpgpu_stall_shd_mem[s_mem][bk_conf] = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6baafaab45103061ad97e27ac06b8eea121">S_MEM</a>][BK_CONF]);
<a name="l00407"></a>00407    fprintf(fout, <span class="stringliteral">&quot;gpgpu_stall_shd_mem[gl_mem][bk_conf] = %d\n&quot;</span>, 
<a name="l00408"></a>00408            <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba237d2f12f219a732c3d67526b2b4df34">G_MEM_LD</a>][BK_CONF] + 
<a name="l00409"></a>00409            <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6bafeb5fc327919b9f67e00bda3110b1197">G_MEM_ST</a>][BK_CONF] + 
<a name="l00410"></a>00410            <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba3e389b44611ee9099dd377891b9ea3e7">L_MEM_LD</a>][BK_CONF] + 
<a name="l00411"></a>00411            <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba787ee7762f9e00740f1ee06e037a61f1">L_MEM_ST</a>][BK_CONF]   
<a name="l00412"></a>00412            ); <span class="comment">// coalescing stall at data cache </span>
<a name="l00413"></a>00413    fprintf(fout, <span class="stringliteral">&quot;gpgpu_stall_shd_mem[gl_mem][coal_stall] = %d\n&quot;</span>, 
<a name="l00414"></a>00414            <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba237d2f12f219a732c3d67526b2b4df34">G_MEM_LD</a>][<a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7a69e7a22f4b547c6292b30a5c5f1ad161">COAL_STALL</a>] + 
<a name="l00415"></a>00415            <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6bafeb5fc327919b9f67e00bda3110b1197">G_MEM_ST</a>][<a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7a69e7a22f4b547c6292b30a5c5f1ad161">COAL_STALL</a>] + 
<a name="l00416"></a>00416            <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba3e389b44611ee9099dd377891b9ea3e7">L_MEM_LD</a>][<a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7a69e7a22f4b547c6292b30a5c5f1ad161">COAL_STALL</a>] + 
<a name="l00417"></a>00417            <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba787ee7762f9e00740f1ee06e037a61f1">L_MEM_ST</a>][<a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7a69e7a22f4b547c6292b30a5c5f1ad161">COAL_STALL</a>]    
<a name="l00418"></a>00418            ); <span class="comment">// coalescing stall + bank conflict at data cache </span>
<a name="l00419"></a>00419    fprintf(fout, <span class="stringliteral">&quot;gpgpu_stall_shd_mem[gl_mem][data_port_stall] = %d\n&quot;</span>, 
<a name="l00420"></a>00420            <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba237d2f12f219a732c3d67526b2b4df34">G_MEM_LD</a>][DATA_PORT_STALL] + 
<a name="l00421"></a>00421            <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6bafeb5fc327919b9f67e00bda3110b1197">G_MEM_ST</a>][DATA_PORT_STALL] + 
<a name="l00422"></a>00422            <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba3e389b44611ee9099dd377891b9ea3e7">L_MEM_LD</a>][DATA_PORT_STALL] + 
<a name="l00423"></a>00423            <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba787ee7762f9e00740f1ee06e037a61f1">L_MEM_ST</a>][DATA_PORT_STALL]    
<a name="l00424"></a>00424            ); <span class="comment">// data port stall at data cache </span>
<a name="l00425"></a>00425    fprintf(fout, <span class="stringliteral">&quot;gpgpu_stall_shd_mem[g_mem_ld][mshr_rc] = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba237d2f12f219a732c3d67526b2b4df34">G_MEM_LD</a>][MSHR_RC_FAIL]);
<a name="l00426"></a>00426    fprintf(fout, <span class="stringliteral">&quot;gpgpu_stall_shd_mem[g_mem_ld][icnt_rc] = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba237d2f12f219a732c3d67526b2b4df34">G_MEM_LD</a>][ICNT_RC_FAIL]);
<a name="l00427"></a>00427    fprintf(fout, <span class="stringliteral">&quot;gpgpu_stall_shd_mem[g_mem_ld][wb_icnt_rc] = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba237d2f12f219a732c3d67526b2b4df34">G_MEM_LD</a>][<a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7ab9b0daa93da2bc3bcabdd5e9fbb3ee19">WB_ICNT_RC_FAIL</a>]);
<a name="l00428"></a>00428    fprintf(fout, <span class="stringliteral">&quot;gpgpu_stall_shd_mem[g_mem_ld][wb_rsrv_fail] = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba237d2f12f219a732c3d67526b2b4df34">G_MEM_LD</a>][<a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7a4cdcc4997460beba05f43267efad6ba8">WB_CACHE_RSRV_FAIL</a>]);
<a name="l00429"></a>00429    fprintf(fout, <span class="stringliteral">&quot;gpgpu_stall_shd_mem[g_mem_st][mshr_rc] = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6bafeb5fc327919b9f67e00bda3110b1197">G_MEM_ST</a>][MSHR_RC_FAIL]);
<a name="l00430"></a>00430    fprintf(fout, <span class="stringliteral">&quot;gpgpu_stall_shd_mem[g_mem_st][icnt_rc] = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6bafeb5fc327919b9f67e00bda3110b1197">G_MEM_ST</a>][ICNT_RC_FAIL]);
<a name="l00431"></a>00431    fprintf(fout, <span class="stringliteral">&quot;gpgpu_stall_shd_mem[g_mem_st][wb_icnt_rc] = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6bafeb5fc327919b9f67e00bda3110b1197">G_MEM_ST</a>][WB_ICNT_RC_FAIL]);
<a name="l00432"></a>00432    fprintf(fout, <span class="stringliteral">&quot;gpgpu_stall_shd_mem[g_mem_st][wb_rsrv_fail] = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6bafeb5fc327919b9f67e00bda3110b1197">G_MEM_ST</a>][WB_CACHE_RSRV_FAIL]);
<a name="l00433"></a>00433    fprintf(fout, <span class="stringliteral">&quot;gpgpu_stall_shd_mem[l_mem_ld][mshr_rc] = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba3e389b44611ee9099dd377891b9ea3e7">L_MEM_LD</a>][MSHR_RC_FAIL]);
<a name="l00434"></a>00434    fprintf(fout, <span class="stringliteral">&quot;gpgpu_stall_shd_mem[l_mem_ld][icnt_rc] = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba3e389b44611ee9099dd377891b9ea3e7">L_MEM_LD</a>][ICNT_RC_FAIL]);
<a name="l00435"></a>00435    fprintf(fout, <span class="stringliteral">&quot;gpgpu_stall_shd_mem[l_mem_ld][wb_icnt_rc] = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba3e389b44611ee9099dd377891b9ea3e7">L_MEM_LD</a>][WB_ICNT_RC_FAIL]);
<a name="l00436"></a>00436    fprintf(fout, <span class="stringliteral">&quot;gpgpu_stall_shd_mem[l_mem_ld][wb_rsrv_fail] = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba3e389b44611ee9099dd377891b9ea3e7">L_MEM_LD</a>][WB_CACHE_RSRV_FAIL]);
<a name="l00437"></a>00437    fprintf(fout, <span class="stringliteral">&quot;gpgpu_stall_shd_mem[l_mem_st][mshr_rc] = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba787ee7762f9e00740f1ee06e037a61f1">L_MEM_ST</a>][MSHR_RC_FAIL]);
<a name="l00438"></a>00438    fprintf(fout, <span class="stringliteral">&quot;gpgpu_stall_shd_mem[l_mem_st][icnt_rc] = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba787ee7762f9e00740f1ee06e037a61f1">L_MEM_ST</a>][ICNT_RC_FAIL]);
<a name="l00439"></a>00439    fprintf(fout, <span class="stringliteral">&quot;gpgpu_stall_shd_mem[l_mem_ld][wb_icnt_rc] = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba787ee7762f9e00740f1ee06e037a61f1">L_MEM_ST</a>][WB_ICNT_RC_FAIL]);
<a name="l00440"></a>00440    fprintf(fout, <span class="stringliteral">&quot;gpgpu_stall_shd_mem[l_mem_ld][wb_rsrv_fail] = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba787ee7762f9e00740f1ee06e037a61f1">L_MEM_ST</a>][WB_CACHE_RSRV_FAIL]);
<a name="l00441"></a>00441 
<a name="l00442"></a>00442    fprintf(fout, <span class="stringliteral">&quot;gpu_reg_bank_conflict_stalls = %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#ac1e7c0721a4fe57492e36d2a7897abee">gpu_reg_bank_conflict_stalls</a>);
<a name="l00443"></a>00443 
<a name="l00444"></a>00444    fprintf(fout, <span class="stringliteral">&quot;Warp Occupancy Distribution:\n&quot;</span>);
<a name="l00445"></a>00445    fprintf(fout, <span class="stringliteral">&quot;Stall:%d\t&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a2fc179319f857beff2665e91ee87d708">shader_cycle_distro</a>[2]);
<a name="l00446"></a>00446    fprintf(fout, <span class="stringliteral">&quot;W0_Idle:%d\t&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a2fc179319f857beff2665e91ee87d708">shader_cycle_distro</a>[0]);
<a name="l00447"></a>00447    fprintf(fout, <span class="stringliteral">&quot;W0_Scoreboard:%d&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a2fc179319f857beff2665e91ee87d708">shader_cycle_distro</a>[1]);
<a name="l00448"></a>00448    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 3; i &lt; <a class="code" href="classshader__core__stats.html#a249ff73257bad58fd68c143d18d63e29">m_config</a>-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a> + 3; i++) 
<a name="l00449"></a>00449       fprintf(fout, <span class="stringliteral">&quot;\tW%d:%d&quot;</span>, i-2, <a class="code" href="structshader__core__stats__pod.html#a2fc179319f857beff2665e91ee87d708">shader_cycle_distro</a>[i]);
<a name="l00450"></a>00450    fprintf(fout, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l00451"></a>00451 
<a name="l00452"></a>00452    <a class="code" href="classshader__core__stats.html#aea480ad72e59b87d900ef4b9491e4225">m_outgoing_traffic_stats</a>-&gt;<a class="code" href="classtraffic__breakdown.html#a0bc34fb4417ae7b5ed88bfc066262903">print</a>(fout); 
<a name="l00453"></a>00453    <a class="code" href="classshader__core__stats.html#a30a43fd19ee6b9f808f21ff2c11012fe">m_incoming_traffic_stats</a>-&gt;<a class="code" href="classtraffic__breakdown.html#a0bc34fb4417ae7b5ed88bfc066262903">print</a>(fout); 
<a name="l00454"></a>00454 }
<a name="l00455"></a>00455 
<a name="l00456"></a><a class="code" href="classshader__core__stats.html#ad1ec6fdd482ca95ced85a8748be1ce21">00456</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__stats.html#ad1ec6fdd482ca95ced85a8748be1ce21">shader_core_stats::event_warp_issued</a>( <span class="keywordtype">unsigned</span> s_id, <span class="keywordtype">unsigned</span> warp_id, <span class="keywordtype">unsigned</span> num_issued, <span class="keywordtype">unsigned</span> dynamic_warp_id ) {
<a name="l00457"></a>00457     assert( warp_id &lt;= m_config-&gt;max_warps_per_shader );
<a name="l00458"></a>00458     <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> i = 0; i &lt; num_issued; ++i ) {
<a name="l00459"></a>00459         <span class="keywordflow">if</span> ( <a class="code" href="classshader__core__stats.html#a3e9405908b8cee2581fa76e9cb16bcbe">m_shader_dynamic_warp_issue_distro</a>[ s_id ].size() &lt;= dynamic_warp_id ) {
<a name="l00460"></a>00460             <a class="code" href="classshader__core__stats.html#a3e9405908b8cee2581fa76e9cb16bcbe">m_shader_dynamic_warp_issue_distro</a>[ s_id ].resize(dynamic_warp_id + 1);
<a name="l00461"></a>00461         }
<a name="l00462"></a>00462         ++<a class="code" href="classshader__core__stats.html#a3e9405908b8cee2581fa76e9cb16bcbe">m_shader_dynamic_warp_issue_distro</a>[ s_id ][ dynamic_warp_id ];
<a name="l00463"></a>00463         <span class="keywordflow">if</span> ( <a class="code" href="classshader__core__stats.html#a09a485a9a43fca28cd42512203b01a0c">m_shader_warp_slot_issue_distro</a>[ s_id ].size() &lt;= warp_id ) {
<a name="l00464"></a>00464             <a class="code" href="classshader__core__stats.html#a09a485a9a43fca28cd42512203b01a0c">m_shader_warp_slot_issue_distro</a>[ s_id ].resize(warp_id + 1);
<a name="l00465"></a>00465         }
<a name="l00466"></a>00466         ++<a class="code" href="classshader__core__stats.html#a09a485a9a43fca28cd42512203b01a0c">m_shader_warp_slot_issue_distro</a>[ s_id ][ warp_id ];
<a name="l00467"></a>00467     }
<a name="l00468"></a>00468 }
<a name="l00469"></a>00469 
<a name="l00470"></a><a class="code" href="classshader__core__stats.html#ae0c1ff3c7d617ca8af3fb3b000032a28">00470</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__stats.html#ae0c1ff3c7d617ca8af3fb3b000032a28">shader_core_stats::visualizer_print</a>( gzFile visualizer_file )
<a name="l00471"></a>00471 {
<a name="l00472"></a>00472     <span class="comment">// warp divergence breakdown</span>
<a name="l00473"></a>00473     gzprintf(visualizer_file, <span class="stringliteral">&quot;WarpDivergenceBreakdown:&quot;</span>);
<a name="l00474"></a>00474     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> total=0;
<a name="l00475"></a>00475     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cf = (<a class="code" href="classshader__core__stats.html#a249ff73257bad58fd68c143d18d63e29">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#aef865ffa389adf962002a2fa46630d46">gpgpu_warpdistro_shader</a>==-1)?<a class="code" href="classshader__core__stats.html#a249ff73257bad58fd68c143d18d63e29">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a30949c72f2ebab12287ca4e801dc0b49">num_shader</a>():1;
<a name="l00476"></a>00476     gzprintf(visualizer_file, <span class="stringliteral">&quot; %d&quot;</span>, (<a class="code" href="structshader__core__stats__pod.html#a2fc179319f857beff2665e91ee87d708">shader_cycle_distro</a>[0] - <a class="code" href="structshader__core__stats__pod.html#aa536e35dbd25f2a41bcba0102d7ded7a">last_shader_cycle_distro</a>[0]) / cf );
<a name="l00477"></a>00477     gzprintf(visualizer_file, <span class="stringliteral">&quot; %d&quot;</span>, (<a class="code" href="structshader__core__stats__pod.html#a2fc179319f857beff2665e91ee87d708">shader_cycle_distro</a>[1] - <a class="code" href="structshader__core__stats__pod.html#aa536e35dbd25f2a41bcba0102d7ded7a">last_shader_cycle_distro</a>[1]) / cf );
<a name="l00478"></a>00478     gzprintf(visualizer_file, <span class="stringliteral">&quot; %d&quot;</span>, (<a class="code" href="structshader__core__stats__pod.html#a2fc179319f857beff2665e91ee87d708">shader_cycle_distro</a>[2] - <a class="code" href="structshader__core__stats__pod.html#aa536e35dbd25f2a41bcba0102d7ded7a">last_shader_cycle_distro</a>[2]) / cf );
<a name="l00479"></a>00479     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;<a class="code" href="classshader__core__stats.html#a249ff73257bad58fd68c143d18d63e29">m_config</a>-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>+3; i++) {
<a name="l00480"></a>00480        <span class="keywordflow">if</span> ( i&gt;=3 ) {
<a name="l00481"></a>00481           total += (<a class="code" href="structshader__core__stats__pod.html#a2fc179319f857beff2665e91ee87d708">shader_cycle_distro</a>[i] - <a class="code" href="structshader__core__stats__pod.html#aa536e35dbd25f2a41bcba0102d7ded7a">last_shader_cycle_distro</a>[i]);
<a name="l00482"></a>00482           <span class="keywordflow">if</span> ( ((i-3) % (<a class="code" href="classshader__core__stats.html#a249ff73257bad58fd68c143d18d63e29">m_config</a>-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>/8)) == ((<a class="code" href="classshader__core__stats.html#a249ff73257bad58fd68c143d18d63e29">m_config</a>-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>/8)-1) ) {
<a name="l00483"></a>00483              gzprintf(visualizer_file, <span class="stringliteral">&quot; %d&quot;</span>, total / cf );
<a name="l00484"></a>00484              total=0;
<a name="l00485"></a>00485           }
<a name="l00486"></a>00486        }
<a name="l00487"></a>00487        <a class="code" href="structshader__core__stats__pod.html#aa536e35dbd25f2a41bcba0102d7ded7a">last_shader_cycle_distro</a>[i] = <a class="code" href="structshader__core__stats__pod.html#a2fc179319f857beff2665e91ee87d708">shader_cycle_distro</a>[i];
<a name="l00488"></a>00488     }
<a name="l00489"></a>00489     gzprintf(visualizer_file,<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l00490"></a>00490 
<a name="l00491"></a>00491     <span class="comment">// warp issue breakdown</span>
<a name="l00492"></a>00492     <span class="keywordtype">unsigned</span> sid = <a class="code" href="classshader__core__stats.html#a249ff73257bad58fd68c143d18d63e29">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#ad129f33cb35aea68b2f9b3b846aaee6d">gpgpu_warp_issue_shader</a>;
<a name="l00493"></a>00493     <span class="keywordtype">unsigned</span> count = 0;
<a name="l00494"></a>00494     <span class="keywordtype">unsigned</span> warp_id_issued_sum = 0;
<a name="l00495"></a>00495     gzprintf(visualizer_file, <span class="stringliteral">&quot;WarpIssueSlotBreakdown:&quot;</span>);
<a name="l00496"></a>00496     <span class="keywordflow">if</span>(<a class="code" href="classshader__core__stats.html#a09a485a9a43fca28cd42512203b01a0c">m_shader_warp_slot_issue_distro</a>[sid].size() &gt; 0){
<a name="l00497"></a>00497         <span class="keywordflow">for</span> ( std::vector&lt;unsigned&gt;::const_iterator iter = <a class="code" href="classshader__core__stats.html#a09a485a9a43fca28cd42512203b01a0c">m_shader_warp_slot_issue_distro</a>[ sid ].begin();
<a name="l00498"></a>00498               iter != <a class="code" href="classshader__core__stats.html#a09a485a9a43fca28cd42512203b01a0c">m_shader_warp_slot_issue_distro</a>[ sid ].end(); iter++, count++ ) {
<a name="l00499"></a>00499             <span class="keywordtype">unsigned</span> diff = count &lt; <a class="code" href="classshader__core__stats.html#acf9b16e53d5588ee8c4f251e89b8a339">m_last_shader_warp_slot_issue_distro</a>.size() ?
<a name="l00500"></a>00500                             *iter - <a class="code" href="classshader__core__stats.html#acf9b16e53d5588ee8c4f251e89b8a339">m_last_shader_warp_slot_issue_distro</a>[ count ] :
<a name="l00501"></a>00501                             *iter;
<a name="l00502"></a>00502             gzprintf( visualizer_file, <span class="stringliteral">&quot; %d&quot;</span>, diff );
<a name="l00503"></a>00503             warp_id_issued_sum += diff;
<a name="l00504"></a>00504         }
<a name="l00505"></a>00505         <a class="code" href="classshader__core__stats.html#acf9b16e53d5588ee8c4f251e89b8a339">m_last_shader_warp_slot_issue_distro</a> = <a class="code" href="classshader__core__stats.html#a09a485a9a43fca28cd42512203b01a0c">m_shader_warp_slot_issue_distro</a>[ sid ];
<a name="l00506"></a>00506     }<span class="keywordflow">else</span>{
<a name="l00507"></a>00507         gzprintf( visualizer_file, <span class="stringliteral">&quot; 0&quot;</span>);
<a name="l00508"></a>00508     }
<a name="l00509"></a>00509     gzprintf(visualizer_file,<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l00510"></a>00510 
<a name="l00511"></a>00511 <span class="preprocessor">    #define DYNAMIC_WARP_PRINT_RESOLUTION 32</span>
<a name="l00512"></a>00512 <span class="preprocessor"></span>    <span class="keywordtype">unsigned</span> total_issued_this_resolution = 0;
<a name="l00513"></a>00513     <span class="keywordtype">unsigned</span> dynamic_id_issued_sum = 0;
<a name="l00514"></a>00514     count = 0;
<a name="l00515"></a>00515     gzprintf(visualizer_file, <span class="stringliteral">&quot;WarpIssueDynamicIdBreakdown:&quot;</span>);
<a name="l00516"></a>00516     <span class="keywordflow">if</span>(<a class="code" href="classshader__core__stats.html#a3e9405908b8cee2581fa76e9cb16bcbe">m_shader_dynamic_warp_issue_distro</a>[sid].size() &gt; 0){
<a name="l00517"></a>00517         <span class="keywordflow">for</span> ( std::vector&lt;unsigned&gt;::const_iterator iter = <a class="code" href="classshader__core__stats.html#a3e9405908b8cee2581fa76e9cb16bcbe">m_shader_dynamic_warp_issue_distro</a>[ sid ].begin();
<a name="l00518"></a>00518               iter != <a class="code" href="classshader__core__stats.html#a3e9405908b8cee2581fa76e9cb16bcbe">m_shader_dynamic_warp_issue_distro</a>[ sid ].end(); iter++, count++ ) {
<a name="l00519"></a>00519             <span class="keywordtype">unsigned</span> diff = count &lt; <a class="code" href="classshader__core__stats.html#a9044cc13f041609e52dfcff09563661e">m_last_shader_dynamic_warp_issue_distro</a>.size() ?
<a name="l00520"></a>00520                             *iter - <a class="code" href="classshader__core__stats.html#a9044cc13f041609e52dfcff09563661e">m_last_shader_dynamic_warp_issue_distro</a>[ count ] :
<a name="l00521"></a>00521                             *iter;
<a name="l00522"></a>00522             total_issued_this_resolution += diff;
<a name="l00523"></a>00523             <span class="keywordflow">if</span> ( ( count + 1 ) % DYNAMIC_WARP_PRINT_RESOLUTION == 0 ) {
<a name="l00524"></a>00524                 gzprintf( visualizer_file, <span class="stringliteral">&quot; %d&quot;</span>, total_issued_this_resolution );
<a name="l00525"></a>00525                 dynamic_id_issued_sum += total_issued_this_resolution;
<a name="l00526"></a>00526                 total_issued_this_resolution = 0;
<a name="l00527"></a>00527             }
<a name="l00528"></a>00528         }
<a name="l00529"></a>00529         <span class="keywordflow">if</span> ( count % DYNAMIC_WARP_PRINT_RESOLUTION != 0 ) {
<a name="l00530"></a>00530             gzprintf( visualizer_file, <span class="stringliteral">&quot; %d&quot;</span>, total_issued_this_resolution );
<a name="l00531"></a>00531             dynamic_id_issued_sum += total_issued_this_resolution;
<a name="l00532"></a>00532         }
<a name="l00533"></a>00533         <a class="code" href="classshader__core__stats.html#a9044cc13f041609e52dfcff09563661e">m_last_shader_dynamic_warp_issue_distro</a> = <a class="code" href="classshader__core__stats.html#a3e9405908b8cee2581fa76e9cb16bcbe">m_shader_dynamic_warp_issue_distro</a>[ sid ];
<a name="l00534"></a>00534         assert( warp_id_issued_sum == dynamic_id_issued_sum );
<a name="l00535"></a>00535     }<span class="keywordflow">else</span>{
<a name="l00536"></a>00536         gzprintf( visualizer_file, <span class="stringliteral">&quot; 0&quot;</span>);
<a name="l00537"></a>00537     }
<a name="l00538"></a>00538     gzprintf(visualizer_file,<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l00539"></a>00539 
<a name="l00540"></a>00540     <span class="comment">// overall cache miss rates</span>
<a name="l00541"></a>00541     gzprintf(visualizer_file, <span class="stringliteral">&quot;gpgpu_n_cache_bkconflict: %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#ad5d01a838269da68a374cbd39a81bac8">gpgpu_n_cache_bkconflict</a>);
<a name="l00542"></a>00542     gzprintf(visualizer_file, <span class="stringliteral">&quot;gpgpu_n_shmem_bkconflict: %d\n&quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a6d36181031418a3a8e92d7b411a87085">gpgpu_n_shmem_bkconflict</a>);     
<a name="l00543"></a>00543 
<a name="l00544"></a>00544 
<a name="l00545"></a>00545    <span class="comment">// instruction count per shader core</span>
<a name="l00546"></a>00546    gzprintf(visualizer_file, <span class="stringliteral">&quot;shaderinsncount:  &quot;</span>);
<a name="l00547"></a>00547    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;<a class="code" href="classshader__core__stats.html#a249ff73257bad58fd68c143d18d63e29">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a30949c72f2ebab12287ca4e801dc0b49">num_shader</a>();i++) 
<a name="l00548"></a>00548       gzprintf(visualizer_file, <span class="stringliteral">&quot;%u &quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a4ea030a625b67f9f2149ad0c09f144d1">m_num_sim_insn</a>[i] );
<a name="l00549"></a>00549    gzprintf(visualizer_file, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l00550"></a>00550    <span class="comment">// warp instruction count per shader core</span>
<a name="l00551"></a>00551    gzprintf(visualizer_file, <span class="stringliteral">&quot;shaderwarpinsncount:  &quot;</span>);
<a name="l00552"></a>00552    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;<a class="code" href="classshader__core__stats.html#a249ff73257bad58fd68c143d18d63e29">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a30949c72f2ebab12287ca4e801dc0b49">num_shader</a>();i++)
<a name="l00553"></a>00553       gzprintf(visualizer_file, <span class="stringliteral">&quot;%u &quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a104d929981b7f61a21a3f32728e6ac9c">m_num_sim_winsn</a>[i] );
<a name="l00554"></a>00554    gzprintf(visualizer_file, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l00555"></a>00555    <span class="comment">// warp divergence per shader core</span>
<a name="l00556"></a>00556    gzprintf(visualizer_file, <span class="stringliteral">&quot;shaderwarpdiv: &quot;</span>);
<a name="l00557"></a>00557    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;<a class="code" href="classshader__core__stats.html#a249ff73257bad58fd68c143d18d63e29">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a30949c72f2ebab12287ca4e801dc0b49">num_shader</a>();i++) 
<a name="l00558"></a>00558       gzprintf(visualizer_file, <span class="stringliteral">&quot;%u &quot;</span>, <a class="code" href="structshader__core__stats__pod.html#a22ad26c44f8e45c88bc0a74bbd3616fe">m_n_diverge</a>[i] );
<a name="l00559"></a>00559    gzprintf(visualizer_file, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l00560"></a>00560 }
<a name="l00561"></a>00561 
<a name="l00562"></a>00562 <span class="preprocessor">#define PROGRAM_MEM_START 0xF0000000 </span><span class="comment">/* should be distinct from other memory spaces... </span>
<a name="l00563"></a>00563 <span class="comment">                                        check ptx_ir.h to verify this does not overlap </span>
<a name="l00564"></a>00564 <span class="comment">                                        other memory spaces */</span>
<a name="l00565"></a><a class="code" href="classshader__core__ctx.html#ac9e24aa89f4c2a7a7902d562ba102c99">00565</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#ac9e24aa89f4c2a7a7902d562ba102c99">shader_core_ctx::decode</a>()
<a name="l00566"></a>00566 {
<a name="l00567"></a>00567     <span class="keywordflow">if</span>( <a class="code" href="classshader__core__ctx.html#ad8587963973cf67d7b495a057ddd698b">m_inst_fetch_buffer</a>.<a class="code" href="structifetch__buffer__t.html#a6b997d8b8afe0fbc2e24dc35dcd6c886">m_valid</a> ) {
<a name="l00568"></a>00568         <span class="comment">// decode 1 or 2 instructions and place them into ibuffer</span>
<a name="l00569"></a>00569         <a class="code" href="abstract__hardware__model_8h.html#a4234d30919c0dcca6fca040a13ad6ae1">address_type</a> pc = <a class="code" href="classshader__core__ctx.html#ad8587963973cf67d7b495a057ddd698b">m_inst_fetch_buffer</a>.<a class="code" href="structifetch__buffer__t.html#a10d5ec4a713ba62f1fa0b20aa1e6e8c8">m_pc</a>;
<a name="l00570"></a>00570         <span class="keyword">const</span> <a class="code" href="classwarp__inst__t.html">warp_inst_t</a>* pI1 = <a class="code" href="cuda-sim_8cc.html#a2598a2a8589cd0a55c15cd594eb439ae">ptx_fetch_inst</a>(pc);
<a name="l00571"></a>00571         <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[<a class="code" href="classshader__core__ctx.html#ad8587963973cf67d7b495a057ddd698b">m_inst_fetch_buffer</a>.<a class="code" href="structifetch__buffer__t.html#a9c3251c9b9be09045f330591f4ea09c1">m_warp_id</a>].ibuffer_fill(0,pI1);
<a name="l00572"></a>00572         <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[<a class="code" href="classshader__core__ctx.html#ad8587963973cf67d7b495a057ddd698b">m_inst_fetch_buffer</a>.<a class="code" href="structifetch__buffer__t.html#a9c3251c9b9be09045f330591f4ea09c1">m_warp_id</a>].inc_inst_in_pipeline();
<a name="l00573"></a>00573         <span class="keywordflow">if</span>( pI1 ) {
<a name="l00574"></a>00574             <a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a7cc6057ef4d2f6136f43fdd5c5579e7c">m_num_decoded_insn</a>[<a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>]++;
<a name="l00575"></a>00575             <span class="keywordflow">if</span>(pI1-&gt;<a class="code" href="classinst__t.html#ac7a035218233cd400ee53e07292b3e19">oprnd_type</a>==<a class="code" href="abstract__hardware__model_8h.html#a2f268fb920f58fceda179b2a908e48fda040b39cb7f3650d354295568d5fa4398">INT_OP</a>){
<a name="l00576"></a>00576                 <a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a6cad9d68ea80f26ec78a677d92b5d0fe">m_num_INTdecoded_insn</a>[<a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>]++;
<a name="l00577"></a>00577             }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(pI1-&gt;<a class="code" href="classinst__t.html#ac7a035218233cd400ee53e07292b3e19">oprnd_type</a>==<a class="code" href="abstract__hardware__model_8h.html#a2f268fb920f58fceda179b2a908e48fda1dbcb0fd00afe65cabbb315ca9d763d6">FP_OP</a>) {
<a name="l00578"></a>00578                 <a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a0b9292d33fdc3500fcc1872f21dffea0">m_num_FPdecoded_insn</a>[<a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>]++;
<a name="l00579"></a>00579             }
<a name="l00580"></a>00580            <span class="keyword">const</span> <a class="code" href="classwarp__inst__t.html">warp_inst_t</a>* pI2 = <a class="code" href="cuda-sim_8cc.html#a2598a2a8589cd0a55c15cd594eb439ae">ptx_fetch_inst</a>(pc+pI1-&gt;<a class="code" href="classinst__t.html#ab86890cdd0a9a3f624e1439a9552b053">isize</a>);
<a name="l00581"></a>00581            <span class="keywordflow">if</span>( pI2 ) {
<a name="l00582"></a>00582                <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[<a class="code" href="classshader__core__ctx.html#ad8587963973cf67d7b495a057ddd698b">m_inst_fetch_buffer</a>.<a class="code" href="structifetch__buffer__t.html#a9c3251c9b9be09045f330591f4ea09c1">m_warp_id</a>].ibuffer_fill(1,pI2);
<a name="l00583"></a>00583                <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[<a class="code" href="classshader__core__ctx.html#ad8587963973cf67d7b495a057ddd698b">m_inst_fetch_buffer</a>.<a class="code" href="structifetch__buffer__t.html#a9c3251c9b9be09045f330591f4ea09c1">m_warp_id</a>].inc_inst_in_pipeline();
<a name="l00584"></a>00584                <a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a7cc6057ef4d2f6136f43fdd5c5579e7c">m_num_decoded_insn</a>[<a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>]++;
<a name="l00585"></a>00585                <span class="keywordflow">if</span>(pI2-&gt;<a class="code" href="classinst__t.html#ac7a035218233cd400ee53e07292b3e19">oprnd_type</a>==<a class="code" href="abstract__hardware__model_8h.html#a2f268fb920f58fceda179b2a908e48fda040b39cb7f3650d354295568d5fa4398">INT_OP</a>){
<a name="l00586"></a>00586                    <a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a6cad9d68ea80f26ec78a677d92b5d0fe">m_num_INTdecoded_insn</a>[<a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>]++;
<a name="l00587"></a>00587                }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(pI2-&gt;<a class="code" href="classinst__t.html#ac7a035218233cd400ee53e07292b3e19">oprnd_type</a>==<a class="code" href="abstract__hardware__model_8h.html#a2f268fb920f58fceda179b2a908e48fda1dbcb0fd00afe65cabbb315ca9d763d6">FP_OP</a>) {
<a name="l00588"></a>00588                    <a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a0b9292d33fdc3500fcc1872f21dffea0">m_num_FPdecoded_insn</a>[<a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>]++;
<a name="l00589"></a>00589                }
<a name="l00590"></a>00590            }
<a name="l00591"></a>00591         }
<a name="l00592"></a>00592         <a class="code" href="classshader__core__ctx.html#ad8587963973cf67d7b495a057ddd698b">m_inst_fetch_buffer</a>.<a class="code" href="structifetch__buffer__t.html#a6b997d8b8afe0fbc2e24dc35dcd6c886">m_valid</a> = <span class="keyword">false</span>;
<a name="l00593"></a>00593     }
<a name="l00594"></a>00594 }
<a name="l00595"></a>00595 
<a name="l00596"></a><a class="code" href="classshader__core__ctx.html#a441aca930d85ca6a169ea0e1ed60daa4">00596</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#a441aca930d85ca6a169ea0e1ed60daa4">shader_core_ctx::fetch</a>()
<a name="l00597"></a>00597 {
<a name="l00598"></a>00598     <span class="keywordflow">if</span>( !<a class="code" href="classshader__core__ctx.html#ad8587963973cf67d7b495a057ddd698b">m_inst_fetch_buffer</a>.<a class="code" href="structifetch__buffer__t.html#a6b997d8b8afe0fbc2e24dc35dcd6c886">m_valid</a> ) {
<a name="l00599"></a>00599         <span class="comment">// find an active warp with space in instruction buffer that is not already waiting on a cache miss</span>
<a name="l00600"></a>00600         <span class="comment">// and get next 1-2 instructions from i-cache...</span>
<a name="l00601"></a>00601         <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i &lt; <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a9cacf20235b1c230a4d99920fc4b577e">max_warps_per_shader</a>; i++ ) {
<a name="l00602"></a>00602             <span class="keywordtype">unsigned</span> warp_id = (<a class="code" href="classshader__core__ctx.html#a7d677bf174ea63c5ea69dabec7a88726">m_last_warp_fetched</a>+1+i) % <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a9cacf20235b1c230a4d99920fc4b577e">max_warps_per_shader</a>;
<a name="l00603"></a>00603 
<a name="l00604"></a>00604             <span class="comment">// this code checks if this warp has finished executing and can be reclaimed</span>
<a name="l00605"></a>00605             <span class="keywordflow">if</span>( <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[warp_id].hardware_done() &amp;&amp; !<a class="code" href="classshader__core__ctx.html#aeeef0a2c13838c8d65a9614c2c7610f4">m_scoreboard</a>-&gt;<a class="code" href="classScoreboard.html#acd976836194b50a0c1dcfd8404ebc155">pendingWrites</a>(warp_id) &amp;&amp; !<a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[warp_id].done_exit() ) {
<a name="l00606"></a>00606                 <span class="keywordtype">bool</span> did_exit=<span class="keyword">false</span>;
<a name="l00607"></a>00607                 <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> t=0; t&lt;<a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>;t++) {
<a name="l00608"></a>00608                     <span class="keywordtype">unsigned</span> tid=warp_id*<a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>+t;
<a name="l00609"></a>00609                     <span class="keywordflow">if</span>( <a class="code" href="classshader__core__ctx.html#a1a699f42a6fb2ad03d3520d6361131a8">m_threadState</a>[tid].m_active == <span class="keyword">true</span> ) {
<a name="l00610"></a>00610                         <a class="code" href="classshader__core__ctx.html#a1a699f42a6fb2ad03d3520d6361131a8">m_threadState</a>[tid].<a class="code" href="classthread__ctx__t.html#a39b1b4dd36b2b6e6e13cbe08aa199498">m_active</a> = <span class="keyword">false</span>; 
<a name="l00611"></a>00611                         <span class="keywordtype">unsigned</span> cta_id = <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[warp_id].get_cta_id();
<a name="l00612"></a>00612                         <a class="code" href="classshader__core__ctx.html#af12dcb274a9cd1001ef20f417c11e598">register_cta_thread_exit</a>(cta_id);
<a name="l00613"></a>00613                         <a class="code" href="classshader__core__ctx.html#a7e78acc4c95880eff06c9afcb65f62d0">m_not_completed</a> -= 1;
<a name="l00614"></a>00614                         <a class="code" href="classshader__core__ctx.html#a75ddec0750ed9a01b1f429bf048b7e0e">m_active_threads</a>.reset(tid);
<a name="l00615"></a>00615                         assert( <a class="code" href="classcore__t.html#a74ac58fba7a6ecd53ba31705ba5c38cd">m_thread</a>[tid]!= NULL );
<a name="l00616"></a>00616                         did_exit=<span class="keyword">true</span>;
<a name="l00617"></a>00617                     }
<a name="l00618"></a>00618                 }
<a name="l00619"></a>00619                 <span class="keywordflow">if</span>( did_exit ) 
<a name="l00620"></a>00620                     <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[warp_id].set_done_exit();
<a name="l00621"></a>00621             }
<a name="l00622"></a>00622 
<a name="l00623"></a>00623             <span class="comment">// this code fetches instructions from the i-cache or generates memory requests</span>
<a name="l00624"></a>00624             <span class="keywordflow">if</span>( !<a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[warp_id].functional_done() &amp;&amp; !<a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[warp_id].imiss_pending() &amp;&amp; <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[warp_id].ibuffer_empty() ) {
<a name="l00625"></a>00625                 <a class="code" href="abstract__hardware__model_8h.html#a4234d30919c0dcca6fca040a13ad6ae1">address_type</a> pc  = <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[warp_id].get_pc();
<a name="l00626"></a>00626                 <a class="code" href="abstract__hardware__model_8h.html#a4234d30919c0dcca6fca040a13ad6ae1">address_type</a> ppc = pc + PROGRAM_MEM_START;
<a name="l00627"></a>00627                 <span class="keywordtype">unsigned</span> nbytes=16; 
<a name="l00628"></a>00628                 <span class="keywordtype">unsigned</span> offset_in_block = pc &amp; (<a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#ae5bc9b8f23f27a0cf437dd3f4bf1a497">m_L1I_config</a>.<a class="code" href="classcache__config.html#a845e3ea5153e60e928350db8472ae3c5">get_line_sz</a>()-1);
<a name="l00629"></a>00629                 <span class="keywordflow">if</span>( (offset_in_block+nbytes) &gt; <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#ae5bc9b8f23f27a0cf437dd3f4bf1a497">m_L1I_config</a>.<a class="code" href="classcache__config.html#a845e3ea5153e60e928350db8472ae3c5">get_line_sz</a>() )
<a name="l00630"></a>00630                     nbytes = (<a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#ae5bc9b8f23f27a0cf437dd3f4bf1a497">m_L1I_config</a>.<a class="code" href="classcache__config.html#a845e3ea5153e60e928350db8472ae3c5">get_line_sz</a>()-offset_in_block);
<a name="l00631"></a>00631 
<a name="l00632"></a>00632                 <span class="comment">// TODO: replace with use of allocator</span>
<a name="l00633"></a>00633                 <span class="comment">// mem_fetch *mf = m_mem_fetch_allocator-&gt;alloc()</span>
<a name="l00634"></a>00634                 <a class="code" href="classmem__access__t.html">mem_access_t</a> acc(INST_ACC_R,ppc,nbytes,<span class="keyword">false</span>);
<a name="l00635"></a>00635                 <a class="code" href="classmem__fetch.html">mem_fetch</a> *mf = <span class="keyword">new</span> <a class="code" href="classmem__fetch.html">mem_fetch</a>(acc,
<a name="l00636"></a>00636                                               NULL<span class="comment">/*we don&apos;t have an instruction yet*/</span>,
<a name="l00637"></a>00637                                               READ_PACKET_SIZE,
<a name="l00638"></a>00638                                               warp_id,
<a name="l00639"></a>00639                                               <a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>,
<a name="l00640"></a>00640                                               <a class="code" href="classshader__core__ctx.html#a74e020dbe1f39b0128d442b9468a51a4">m_tpc</a>,
<a name="l00641"></a>00641                                               <a class="code" href="classshader__core__ctx.html#a1914ee82d2d4d1bc6433e9efdc9b45f9">m_memory_config</a> );
<a name="l00642"></a>00642                 std::list&lt;cache_event&gt; events;
<a name="l00643"></a>00643                 <span class="keyword">enum</span> <a class="code" href="gpu-cache_8h.html#a6ca15cb60df1ccf2f7d8e677d11a1bbe">cache_request_status</a> status = <a class="code" href="classshader__core__ctx.html#ab4e5da01591cc8c202069addf3afad1c">m_L1I</a>-&gt;<a class="code" href="classread__only__cache.html#a4641d150f3cf646b8d3f8640051ffcfe" title="Access cache for read_only_cache: returns RESERVATION_FAIL if request could not be...">access</a>( (<a class="code" href="abstract__hardware__model_8h.html#adcde2e548bc855c5cb446e23e38bd12d">new_addr_type</a>)ppc, mf, <a class="code" href="gpu-sim_8cc.html#a659fec271553d05e676c52314c8fcfe1">gpu_sim_cycle</a>+<a class="code" href="gpu-sim_8cc.html#acef6bbfd6ec09fe29e2641cace785058">gpu_tot_sim_cycle</a>,events);
<a name="l00644"></a>00644                 <span class="keywordflow">if</span>( status == <a class="code" href="gpu-cache_8h.html#a6ca15cb60df1ccf2f7d8e677d11a1bbeaf15e118f26fd4e7acd598ef7e4291b2a">MISS</a> ) {
<a name="l00645"></a>00645                     <a class="code" href="classshader__core__ctx.html#a7d677bf174ea63c5ea69dabec7a88726">m_last_warp_fetched</a>=warp_id;
<a name="l00646"></a>00646                     <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[warp_id].set_imiss_pending();
<a name="l00647"></a>00647                     <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[warp_id].set_last_fetch(<a class="code" href="gpu-sim_8cc.html#a659fec271553d05e676c52314c8fcfe1">gpu_sim_cycle</a>);
<a name="l00648"></a>00648                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( status == <a class="code" href="gpu-cache_8h.html#a6ca15cb60df1ccf2f7d8e677d11a1bbead4cf8619fedf804702c72835be555da0">HIT</a> ) {
<a name="l00649"></a>00649                     <a class="code" href="classshader__core__ctx.html#a7d677bf174ea63c5ea69dabec7a88726">m_last_warp_fetched</a>=warp_id;
<a name="l00650"></a>00650                     <a class="code" href="classshader__core__ctx.html#ad8587963973cf67d7b495a057ddd698b">m_inst_fetch_buffer</a> = <a class="code" href="structifetch__buffer__t.html">ifetch_buffer_t</a>(pc,nbytes,warp_id);
<a name="l00651"></a>00651                     <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[warp_id].set_last_fetch(<a class="code" href="gpu-sim_8cc.html#a659fec271553d05e676c52314c8fcfe1">gpu_sim_cycle</a>);
<a name="l00652"></a>00652                     <span class="keyword">delete</span> mf;
<a name="l00653"></a>00653                 } <span class="keywordflow">else</span> {
<a name="l00654"></a>00654                     <a class="code" href="classshader__core__ctx.html#a7d677bf174ea63c5ea69dabec7a88726">m_last_warp_fetched</a>=warp_id;
<a name="l00655"></a>00655                     assert( status == <a class="code" href="gpu-cache_8h.html#a6ca15cb60df1ccf2f7d8e677d11a1bbead6cd0ba3ddc29343844c2c23345a2460">RESERVATION_FAIL</a> );
<a name="l00656"></a>00656                     <span class="keyword">delete</span> mf;
<a name="l00657"></a>00657                 }
<a name="l00658"></a>00658                 <span class="keywordflow">break</span>;
<a name="l00659"></a>00659             }
<a name="l00660"></a>00660         }
<a name="l00661"></a>00661     }
<a name="l00662"></a>00662 
<a name="l00663"></a>00663     <a class="code" href="classshader__core__ctx.html#ab4e5da01591cc8c202069addf3afad1c">m_L1I</a>-&gt;<a class="code" href="classbaseline__cache.html#a0622c3b477d40f97b694dd5d76de23cd" title="Sends next request to lower level of memory.">cycle</a>();
<a name="l00664"></a>00664 
<a name="l00665"></a>00665     <span class="keywordflow">if</span>( <a class="code" href="classshader__core__ctx.html#ab4e5da01591cc8c202069addf3afad1c">m_L1I</a>-&gt;<a class="code" href="classbaseline__cache.html#a35718e662874edff48a21967e79d5f4e" title="Are any (accepted) accesses that had to wait for memory now ready? (does not include...">access_ready</a>() ) {
<a name="l00666"></a>00666         <a class="code" href="classmem__fetch.html">mem_fetch</a> *mf = <a class="code" href="classshader__core__ctx.html#ab4e5da01591cc8c202069addf3afad1c">m_L1I</a>-&gt;<a class="code" href="classbaseline__cache.html#a2130cc5c06e1642d3a5ab1ec77e54446" title="Pop next ready access (does not include accesses that &amp;quot;HIT&amp;quot;).">next_access</a>();
<a name="l00667"></a>00667         <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[mf-&gt;<a class="code" href="classmem__fetch.html#aa9e3a06ff563324393980d3d78bdba11">get_wid</a>()].clear_imiss_pending();
<a name="l00668"></a>00668         <span class="keyword">delete</span> mf;
<a name="l00669"></a>00669     }
<a name="l00670"></a>00670 }
<a name="l00671"></a>00671 
<a name="l00672"></a><a class="code" href="classshader__core__ctx.html#ab45da94b0aacd0dd7ef97a1e3e1160ea">00672</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#ab45da94b0aacd0dd7ef97a1e3e1160ea">shader_core_ctx::func_exec_inst</a>( <a class="code" href="classwarp__inst__t.html">warp_inst_t</a> &amp;inst )
<a name="l00673"></a>00673 {
<a name="l00674"></a>00674     <a class="code" href="classcore__t.html#a19a45810ebc463b29ecffaf9024a58f3">execute_warp_inst_t</a>(inst);
<a name="l00675"></a>00675     <span class="keywordflow">if</span>( inst.<a class="code" href="classinst__t.html#a2a7f0ff5bdc4a059f744487d2cf255bd">is_load</a>() || inst.<a class="code" href="classinst__t.html#a4a4af03ae60d4f77f84d07c0264a5354">is_store</a>() )
<a name="l00676"></a>00676         inst.<a class="code" href="classwarp__inst__t.html#a427312133d093a9251a1cc8b80c3e194">generate_mem_accesses</a>();
<a name="l00677"></a>00677 }
<a name="l00678"></a>00678 
<a name="l00679"></a><a class="code" href="classshader__core__ctx.html#aebcb8501b034bcef51c0c19152865a47">00679</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#aebcb8501b034bcef51c0c19152865a47">shader_core_ctx::issue_warp</a>( <a class="code" href="classregister__set.html">register_set</a>&amp; pipe_reg_set, <span class="keyword">const</span> <a class="code" href="classwarp__inst__t.html">warp_inst_t</a>* next_inst, <span class="keyword">const</span> <a class="code" href="abstract__hardware__model_8h.html#a7a04052f9f95a9e16de0283eb0b22c3e">active_mask_t</a> &amp;active_mask, <span class="keywordtype">unsigned</span> warp_id )
<a name="l00680"></a>00680 {
<a name="l00681"></a>00681     <a class="code" href="classwarp__inst__t.html">warp_inst_t</a>** pipe_reg = pipe_reg_set.<a class="code" href="classregister__set.html#a44c85736aff09e152a81bad99ddf7911">get_free</a>();
<a name="l00682"></a>00682     assert(pipe_reg);
<a name="l00683"></a>00683     
<a name="l00684"></a>00684     <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[warp_id].ibuffer_free();
<a name="l00685"></a>00685     assert(next_inst-&gt;<a class="code" href="classinst__t.html#af5b6be7232de77623fbe8b3c818913cd">valid</a>());
<a name="l00686"></a>00686     **pipe_reg = *next_inst; <span class="comment">// static instruction information</span>
<a name="l00687"></a>00687     (*pipe_reg)-&gt;<a class="code" href="classwarp__inst__t.html#adc77a69bc71b8568276ba753551bd492">issue</a>( active_mask, warp_id, <a class="code" href="gpu-sim_8cc.html#acef6bbfd6ec09fe29e2641cace785058">gpu_tot_sim_cycle</a> + <a class="code" href="gpu-sim_8cc.html#a659fec271553d05e676c52314c8fcfe1">gpu_sim_cycle</a>, <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[warp_id].get_dynamic_warp_id() ); <span class="comment">// dynamic instruction information</span>
<a name="l00688"></a>00688     <a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a2fc179319f857beff2665e91ee87d708">shader_cycle_distro</a>[2+(*pipe_reg)-&gt;active_count()]++;
<a name="l00689"></a>00689     <a class="code" href="classshader__core__ctx.html#ab45da94b0aacd0dd7ef97a1e3e1160ea">func_exec_inst</a>( **pipe_reg );
<a name="l00690"></a>00690     <span class="keywordflow">if</span>( next_inst-&gt;<a class="code" href="classinst__t.html#a5e7e56fb753710a255876d382fda08c3">op</a> == <a class="code" href="abstract__hardware__model_8h.html#a35b8f4223626361f0e0cb24d0c0b0f4ca998c92693120b6eb67f03e3c9590ed29">BARRIER_OP</a> ) 
<a name="l00691"></a>00691         <a class="code" href="classshader__core__ctx.html#ad1128668e0cb4889bcb9d257710e6f42">m_barriers</a>.<a class="code" href="classbarrier__set__t.html#a4ad261ac60abddad5d03f849a32967c3">warp_reaches_barrier</a>(<a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[warp_id].get_cta_id(),warp_id);
<a name="l00692"></a>00692     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( next_inst-&gt;<a class="code" href="classinst__t.html#a5e7e56fb753710a255876d382fda08c3">op</a> == <a class="code" href="abstract__hardware__model_8h.html#a35b8f4223626361f0e0cb24d0c0b0f4cadaf34556ed6315ab53fe011adebe70c9">MEMORY_BARRIER_OP</a> ) 
<a name="l00693"></a>00693         <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[warp_id].set_membar();
<a name="l00694"></a>00694 
<a name="l00695"></a>00695     <a class="code" href="classcore__t.html#aa11c9f449e913436ec99099c1a650424">updateSIMTStack</a>(warp_id,*pipe_reg);
<a name="l00696"></a>00696     <a class="code" href="classshader__core__ctx.html#aeeef0a2c13838c8d65a9614c2c7610f4">m_scoreboard</a>-&gt;<a class="code" href="classScoreboard.html#ae57da54b72c29b940c5338574987b79d">reserveRegisters</a>(*pipe_reg);
<a name="l00697"></a>00697     <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[warp_id].set_next_pc(next_inst-&gt;<a class="code" href="classinst__t.html#a76aea27709c3a0256c2615451c7daa56">pc</a> + next_inst-&gt;<a class="code" href="classinst__t.html#ab86890cdd0a9a3f624e1439a9552b053">isize</a>);
<a name="l00698"></a>00698 }
<a name="l00699"></a>00699 
<a name="l00700"></a><a class="code" href="classshader__core__ctx.html#a70f3500c956d0ce2fc3fd122880aa662">00700</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#a70f3500c956d0ce2fc3fd122880aa662">shader_core_ctx::issue</a>(){
<a name="l00701"></a>00701     <span class="comment">//really is issue;</span>
<a name="l00702"></a>00702     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; <a class="code" href="classshader__core__ctx.html#ad5ec859a2adc916cbecf8255ba6c7c9e">schedulers</a>.size(); i++) {
<a name="l00703"></a>00703         <a class="code" href="classshader__core__ctx.html#ad5ec859a2adc916cbecf8255ba6c7c9e">schedulers</a>[i]-&gt;cycle();
<a name="l00704"></a>00704     }
<a name="l00705"></a>00705 }
<a name="l00706"></a>00706 
<a name="l00707"></a><a class="code" href="classscheduler__unit.html#a4d5bcb2099dd71d45d567c413a17175a">00707</a> <a class="code" href="classshd__warp__t.html">shd_warp_t</a>&amp; <a class="code" href="classscheduler__unit.html#a4d5bcb2099dd71d45d567c413a17175a">scheduler_unit::warp</a>(<span class="keywordtype">int</span> i){
<a name="l00708"></a>00708     <span class="keywordflow">return</span> (*<a class="code" href="classscheduler__unit.html#ab32935e049dca3a0d9ad9c4e9153b301">m_warp</a>)[i];
<a name="l00709"></a>00709 }
<a name="l00710"></a>00710 
<a name="l00711"></a>00711 
<a name="l00731"></a>00731 <span class="keyword">template</span> &lt; <span class="keyword">class</span> T &gt;
<a name="l00732"></a><a class="code" href="classscheduler__unit.html#a58620ddfcd76bd9470f754f38b244c34">00732</a> <span class="keywordtype">void</span> <a class="code" href="classscheduler__unit.html#a58620ddfcd76bd9470f754f38b244c34">scheduler_unit::order_lrr</a>( std::vector&lt; T &gt;&amp; result_list,
<a name="l00733"></a>00733                                 <span class="keyword">const</span> <span class="keyword">typename</span> std::vector&lt; T &gt;&amp; input_list,
<a name="l00734"></a>00734                                 <span class="keyword">const</span> <span class="keyword">typename</span> std::vector&lt; T &gt;::const_iterator&amp; last_issued_from_input,
<a name="l00735"></a>00735                                 <span class="keywordtype">unsigned</span> num_warps_to_add )
<a name="l00736"></a>00736 {
<a name="l00737"></a>00737     assert( num_warps_to_add &lt;= input_list.size() );
<a name="l00738"></a>00738     result_list.clear();
<a name="l00739"></a>00739     <span class="keyword">typename</span> std::vector&lt; T &gt;::const_iterator iter
<a name="l00740"></a>00740         = ( last_issued_from_input ==  input_list.end() ) ? input_list.begin()
<a name="l00741"></a>00741                                                           : last_issued_from_input + 1;
<a name="l00742"></a>00742 
<a name="l00743"></a>00743     <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> count = 0;
<a name="l00744"></a>00744           count &lt; num_warps_to_add;
<a name="l00745"></a>00745           ++iter, ++count) {
<a name="l00746"></a>00746         <span class="keywordflow">if</span> ( iter ==  input_list.end() ) {
<a name="l00747"></a>00747             iter = input_list.begin();
<a name="l00748"></a>00748         }
<a name="l00749"></a>00749         result_list.push_back( *iter );
<a name="l00750"></a>00750     }
<a name="l00751"></a>00751 }
<a name="l00752"></a>00752 
<a name="l00764"></a>00764 <span class="keyword">template</span> &lt; <span class="keyword">class</span> T &gt;
<a name="l00765"></a><a class="code" href="classscheduler__unit.html#ab668da9c24687c8fd466b2a50a8be813">00765</a> <span class="keywordtype">void</span> <a class="code" href="classscheduler__unit.html#a10863caa95bd3ce03458451eb66d270d">scheduler_unit::order_by_priority</a>( std::vector&lt; T &gt;&amp; result_list,
<a name="l00766"></a>00766                                         <span class="keyword">const</span> <span class="keyword">typename</span> std::vector&lt; T &gt;&amp; input_list,
<a name="l00767"></a>00767                                         <span class="keyword">const</span> <span class="keyword">typename</span> std::vector&lt; T &gt;::const_iterator&amp; last_issued_from_input,
<a name="l00768"></a>00768                                         <span class="keywordtype">unsigned</span> num_warps_to_add,
<a name="l00769"></a>00769                                         <a class="code" href="classscheduler__unit.html#a14ce574cf8996f904ff29a9f6e744f7a">OrderingType</a> ordering,
<a name="l00770"></a>00770                                         <span class="keywordtype">bool</span> (*priority_func)(T lhs, T rhs) )
<a name="l00771"></a>00771 {
<a name="l00772"></a>00772     assert( num_warps_to_add &lt;= input_list.size() );
<a name="l00773"></a>00773     result_list.clear();
<a name="l00774"></a>00774     <span class="keyword">typename</span> std::vector&lt; T &gt; temp = input_list;
<a name="l00775"></a>00775 
<a name="l00776"></a>00776     <span class="keywordflow">if</span> ( <a class="code" href="classscheduler__unit.html#a14ce574cf8996f904ff29a9f6e744f7aa18121527f07e6a2dc6319b755593eff7">ORDERING_GREEDY_THEN_PRIORITY_FUNC</a> == ordering ) {
<a name="l00777"></a>00777         T greedy_value = *last_issued_from_input;
<a name="l00778"></a>00778         result_list.push_back( greedy_value );
<a name="l00779"></a>00779 
<a name="l00780"></a>00780         std::sort( temp.begin(), temp.end(), priority_func );
<a name="l00781"></a>00781         <span class="keyword">typename</span> std::vector&lt; T &gt;::iterator iter = temp.begin();
<a name="l00782"></a>00782         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> count = 0; count &lt; num_warps_to_add; ++count, ++iter ) {
<a name="l00783"></a>00783             <span class="keywordflow">if</span> ( *iter != greedy_value ) {
<a name="l00784"></a>00784                 result_list.push_back( *iter );
<a name="l00785"></a>00785             }
<a name="l00786"></a>00786         }
<a name="l00787"></a>00787     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="classscheduler__unit.html#a14ce574cf8996f904ff29a9f6e744f7aa0dabcc2794b5c2adaf5060e680396fca">ORDERED_PRIORITY_FUNC_ONLY</a> == ordering ) {
<a name="l00788"></a>00788         std::sort( temp.begin(), temp.end(), priority_func );
<a name="l00789"></a>00789         <span class="keyword">typename</span> std::vector&lt; T &gt;::iterator iter = temp.begin();
<a name="l00790"></a>00790         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> count = 0; count &lt; num_warps_to_add; ++count, ++iter ) {
<a name="l00791"></a>00791             result_list.push_back( *iter );
<a name="l00792"></a>00792         }
<a name="l00793"></a>00793     } <span class="keywordflow">else</span> {
<a name="l00794"></a>00794         fprintf( stderr, <span class="stringliteral">&quot;Unknown ordering - %d\n&quot;</span>, ordering );
<a name="l00795"></a>00795         abort();
<a name="l00796"></a>00796     }
<a name="l00797"></a>00797 }
<a name="l00798"></a>00798 
<a name="l00799"></a><a class="code" href="classscheduler__unit.html#a47c4325ef60af799b123f1cca0bba904">00799</a> <span class="keywordtype">void</span> <a class="code" href="classscheduler__unit.html#a47c4325ef60af799b123f1cca0bba904">scheduler_unit::cycle</a>()
<a name="l00800"></a>00800 {
<a name="l00801"></a>00801     SCHED_DPRINTF( <span class="stringliteral">&quot;scheduler_unit::cycle()\n&quot;</span> );
<a name="l00802"></a>00802     <span class="keywordtype">bool</span> valid_inst = <span class="keyword">false</span>;  <span class="comment">// there was one warp with a valid instruction to issue (didn&apos;t require flush due to control hazard)</span>
<a name="l00803"></a>00803     <span class="keywordtype">bool</span> ready_inst = <span class="keyword">false</span>;  <span class="comment">// of the valid instructions, there was one not waiting for pending register writes</span>
<a name="l00804"></a>00804     <span class="keywordtype">bool</span> issued_inst = <span class="keyword">false</span>; <span class="comment">// of these we issued one</span>
<a name="l00805"></a>00805 
<a name="l00806"></a>00806     <a class="code" href="classscheduler__unit.html#a0955c4447396bf1311be0881ffc6ec6d">order_warps</a>();
<a name="l00807"></a>00807     <span class="keywordflow">for</span> ( std::vector&lt; shd_warp_t* &gt;::const_iterator iter = <a class="code" href="classscheduler__unit.html#aed0dfcbf7afcf8bfffb0405dc4a2cf57">m_next_cycle_prioritized_warps</a>.begin();
<a name="l00808"></a>00808           iter != <a class="code" href="classscheduler__unit.html#aed0dfcbf7afcf8bfffb0405dc4a2cf57">m_next_cycle_prioritized_warps</a>.end();
<a name="l00809"></a>00809           iter++ ) {
<a name="l00810"></a>00810         <span class="comment">// Don&apos;t consider warps that are not yet valid</span>
<a name="l00811"></a>00811         <span class="keywordflow">if</span> ( (*iter) == NULL || (*iter)-&gt;done_exit() ) {
<a name="l00812"></a>00812             <span class="keywordflow">continue</span>;
<a name="l00813"></a>00813         }
<a name="l00814"></a>00814         SCHED_DPRINTF( <span class="stringliteral">&quot;Testing (warp_id %u, dynamic_warp_id %u)\n&quot;</span>,
<a name="l00815"></a>00815                        (*iter)-&gt;get_warp_id(), (*iter)-&gt;get_dynamic_warp_id() );
<a name="l00816"></a>00816         <span class="keywordtype">unsigned</span> warp_id = (*iter)-&gt;get_warp_id();
<a name="l00817"></a>00817         <span class="keywordtype">unsigned</span> checked=0;
<a name="l00818"></a>00818         <span class="keywordtype">unsigned</span> issued=0;
<a name="l00819"></a>00819         <span class="keywordtype">unsigned</span> max_issue = <a class="code" href="classscheduler__unit.html#a8f4804329c218ddce1cc5a8c33f295df">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#aa5e09854f08316f4f2e4bf45f8c6579b">gpgpu_max_insn_issue_per_warp</a>;
<a name="l00820"></a>00820         <span class="keywordflow">while</span>( !<a class="code" href="classscheduler__unit.html#a4d5bcb2099dd71d45d567c413a17175a">warp</a>(warp_id).waiting() &amp;&amp; !<a class="code" href="classscheduler__unit.html#a4d5bcb2099dd71d45d567c413a17175a">warp</a>(warp_id).ibuffer_empty() &amp;&amp; (checked &lt; max_issue) &amp;&amp; (checked &lt;= issued) &amp;&amp; (issued &lt; max_issue) ) {
<a name="l00821"></a>00821             <span class="keyword">const</span> <a class="code" href="classwarp__inst__t.html">warp_inst_t</a> *pI = <a class="code" href="classscheduler__unit.html#a4d5bcb2099dd71d45d567c413a17175a">warp</a>(warp_id).<a class="code" href="classshd__warp__t.html#a2a54effad2773c8613e20c9168174703">ibuffer_next_inst</a>();
<a name="l00822"></a>00822             <span class="keywordtype">bool</span> valid = <a class="code" href="classscheduler__unit.html#a4d5bcb2099dd71d45d567c413a17175a">warp</a>(warp_id).<a class="code" href="classshd__warp__t.html#a5d24cb6b90d2b59e150bf96613e9d45e">ibuffer_next_valid</a>();
<a name="l00823"></a>00823             <span class="keywordtype">bool</span> warp_inst_issued = <span class="keyword">false</span>;
<a name="l00824"></a>00824             <span class="keywordtype">unsigned</span> pc,rpc;
<a name="l00825"></a>00825             <a class="code" href="classscheduler__unit.html#aaf03ef8ac18c87cef9e0efee4e2e4be2">m_simt_stack</a>[warp_id]-&gt;<a class="code" href="classsimt__stack.html#a6dc20c4969bbd3578891c2bb09db5081">get_pdom_stack_top_info</a>(&amp;pc,&amp;rpc);
<a name="l00826"></a>00826             SCHED_DPRINTF( <span class="stringliteral">&quot;Warp (warp_id %u, dynamic_warp_id %u) has valid instruction (%s)\n&quot;</span>,
<a name="l00827"></a>00827                            (*iter)-&gt;get_warp_id(), (*iter)-&gt;get_dynamic_warp_id(),
<a name="l00828"></a>00828                            <a class="code" href="cuda-sim_8cc.html#abd22a5c6610e1c731ec5f36810cc1857">ptx_get_insn_str</a>( pc).c_str() );
<a name="l00829"></a>00829             <span class="keywordflow">if</span>( pI ) {
<a name="l00830"></a>00830                 assert(valid);
<a name="l00831"></a>00831                 <span class="keywordflow">if</span>( pc != pI-&gt;<a class="code" href="classinst__t.html#a76aea27709c3a0256c2615451c7daa56">pc</a> ) {
<a name="l00832"></a>00832                     SCHED_DPRINTF( <span class="stringliteral">&quot;Warp (warp_id %u, dynamic_warp_id %u) control hazard instruction flush\n&quot;</span>,
<a name="l00833"></a>00833                                    (*iter)-&gt;get_warp_id(), (*iter)-&gt;get_dynamic_warp_id() );
<a name="l00834"></a>00834                     <span class="comment">// control hazard</span>
<a name="l00835"></a>00835                     <a class="code" href="classscheduler__unit.html#a4d5bcb2099dd71d45d567c413a17175a">warp</a>(warp_id).<a class="code" href="classshd__warp__t.html#a008c5826f2c766b88114b77551d965ae">set_next_pc</a>(pc);
<a name="l00836"></a>00836                     <a class="code" href="classscheduler__unit.html#a4d5bcb2099dd71d45d567c413a17175a">warp</a>(warp_id).<a class="code" href="classshd__warp__t.html#a6dc46f828fde98082047e1c7ca7d2f6d">ibuffer_flush</a>();
<a name="l00837"></a>00837                 } <span class="keywordflow">else</span> {
<a name="l00838"></a>00838                     valid_inst = <span class="keyword">true</span>;
<a name="l00839"></a>00839                     <span class="keywordflow">if</span> ( !<a class="code" href="classscheduler__unit.html#abbbddd52d99014fbc6b1f677c103b620">m_scoreboard</a>-&gt;<a class="code" href="classScoreboard.html#a3e2e790167e0e825442bf6995f2234b3">checkCollision</a>(warp_id, pI) ) {
<a name="l00840"></a>00840                         SCHED_DPRINTF( <span class="stringliteral">&quot;Warp (warp_id %u, dynamic_warp_id %u) passes scoreboard\n&quot;</span>,
<a name="l00841"></a>00841                                        (*iter)-&gt;get_warp_id(), (*iter)-&gt;get_dynamic_warp_id() );
<a name="l00842"></a>00842                         ready_inst = <span class="keyword">true</span>;
<a name="l00843"></a>00843                         <span class="keyword">const</span> <a class="code" href="abstract__hardware__model_8h.html#a7a04052f9f95a9e16de0283eb0b22c3e">active_mask_t</a> &amp;active_mask = <a class="code" href="classscheduler__unit.html#aaf03ef8ac18c87cef9e0efee4e2e4be2">m_simt_stack</a>[warp_id]-&gt;<a class="code" href="classsimt__stack.html#ad5a9d6dda7565fbdbf62c7ebf6acdde2">get_active_mask</a>();
<a name="l00844"></a>00844                         assert( <a class="code" href="classscheduler__unit.html#a4d5bcb2099dd71d45d567c413a17175a">warp</a>(warp_id).inst_in_pipeline() );
<a name="l00845"></a>00845                         <span class="keywordflow">if</span> ( (pI-&gt;<a class="code" href="classinst__t.html#a5e7e56fb753710a255876d382fda08c3">op</a> == <a class="code" href="abstract__hardware__model_8h.html#a35b8f4223626361f0e0cb24d0c0b0f4ca5129cce70aaf0f68261db0c4bf273709">LOAD_OP</a>) || (pI-&gt;<a class="code" href="classinst__t.html#a5e7e56fb753710a255876d382fda08c3">op</a> == <a class="code" href="abstract__hardware__model_8h.html#a35b8f4223626361f0e0cb24d0c0b0f4cafd107fa80c07dee943713884d06dea31">STORE_OP</a>) || (pI-&gt;<a class="code" href="classinst__t.html#a5e7e56fb753710a255876d382fda08c3">op</a> == <a class="code" href="abstract__hardware__model_8h.html#a35b8f4223626361f0e0cb24d0c0b0f4cadaf34556ed6315ab53fe011adebe70c9">MEMORY_BARRIER_OP</a>) ) {
<a name="l00846"></a>00846                             <span class="keywordflow">if</span>( <a class="code" href="classscheduler__unit.html#a488165c543f824c8e0b7d11ba6889e62">m_mem_out</a>-&gt;<a class="code" href="classregister__set.html#afc6a582f983b8f883c513c3d718cd222">has_free</a>() ) {
<a name="l00847"></a>00847                                 <a class="code" href="classscheduler__unit.html#a8f4804329c218ddce1cc5a8c33f295df">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#aebcb8501b034bcef51c0c19152865a47">issue_warp</a>(*<a class="code" href="classscheduler__unit.html#a488165c543f824c8e0b7d11ba6889e62">m_mem_out</a>,pI,active_mask,warp_id);
<a name="l00848"></a>00848                                 issued++;
<a name="l00849"></a>00849                                 issued_inst=<span class="keyword">true</span>;
<a name="l00850"></a>00850                                 warp_inst_issued = <span class="keyword">true</span>;
<a name="l00851"></a>00851                             }
<a name="l00852"></a>00852                         } <span class="keywordflow">else</span> {
<a name="l00853"></a>00853                             <span class="keywordtype">bool</span> sp_pipe_avail = <a class="code" href="classscheduler__unit.html#a10f828d63b12de06fd53632f7de91292">m_sp_out</a>-&gt;<a class="code" href="classregister__set.html#afc6a582f983b8f883c513c3d718cd222">has_free</a>();
<a name="l00854"></a>00854                             <span class="keywordtype">bool</span> sfu_pipe_avail = <a class="code" href="classscheduler__unit.html#aae84ef320edcad2a19813e454767bb91">m_sfu_out</a>-&gt;<a class="code" href="classregister__set.html#afc6a582f983b8f883c513c3d718cd222">has_free</a>();
<a name="l00855"></a>00855                             <span class="keywordflow">if</span>( sp_pipe_avail &amp;&amp; (pI-&gt;<a class="code" href="classinst__t.html#a5e7e56fb753710a255876d382fda08c3">op</a> != <a class="code" href="abstract__hardware__model_8h.html#a35b8f4223626361f0e0cb24d0c0b0f4cad2afe8f18d7b86344eb33fed3e78bfff">SFU_OP</a>) ) {
<a name="l00856"></a>00856                                 <span class="comment">// always prefer SP pipe for operations that can use both SP and SFU pipelines</span>
<a name="l00857"></a>00857                                 <a class="code" href="classscheduler__unit.html#a8f4804329c218ddce1cc5a8c33f295df">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#aebcb8501b034bcef51c0c19152865a47">issue_warp</a>(*<a class="code" href="classscheduler__unit.html#a10f828d63b12de06fd53632f7de91292">m_sp_out</a>,pI,active_mask,warp_id);
<a name="l00858"></a>00858                                 issued++;
<a name="l00859"></a>00859                                 issued_inst=<span class="keyword">true</span>;
<a name="l00860"></a>00860                                 warp_inst_issued = <span class="keyword">true</span>;
<a name="l00861"></a>00861                             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (pI-&gt;<a class="code" href="classinst__t.html#a5e7e56fb753710a255876d382fda08c3">op</a> == <a class="code" href="abstract__hardware__model_8h.html#a35b8f4223626361f0e0cb24d0c0b0f4cad2afe8f18d7b86344eb33fed3e78bfff">SFU_OP</a>) || (pI-&gt;<a class="code" href="classinst__t.html#a5e7e56fb753710a255876d382fda08c3">op</a> == <a class="code" href="abstract__hardware__model_8h.html#a35b8f4223626361f0e0cb24d0c0b0f4cac403f33e6938422c5ad1eead4e7dbc7b">ALU_SFU_OP</a>) ) {
<a name="l00862"></a>00862                                 <span class="keywordflow">if</span>( sfu_pipe_avail ) {
<a name="l00863"></a>00863                                     <a class="code" href="classscheduler__unit.html#a8f4804329c218ddce1cc5a8c33f295df">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#aebcb8501b034bcef51c0c19152865a47">issue_warp</a>(*<a class="code" href="classscheduler__unit.html#aae84ef320edcad2a19813e454767bb91">m_sfu_out</a>,pI,active_mask,warp_id);
<a name="l00864"></a>00864                                     issued++;
<a name="l00865"></a>00865                                     issued_inst=<span class="keyword">true</span>;
<a name="l00866"></a>00866                                     warp_inst_issued = <span class="keyword">true</span>;
<a name="l00867"></a>00867                                 }
<a name="l00868"></a>00868                             } 
<a name="l00869"></a>00869                         }
<a name="l00870"></a>00870                     } <span class="keywordflow">else</span> {
<a name="l00871"></a>00871                         SCHED_DPRINTF( <span class="stringliteral">&quot;Warp (warp_id %u, dynamic_warp_id %u) fails scoreboard\n&quot;</span>,
<a name="l00872"></a>00872                                        (*iter)-&gt;get_warp_id(), (*iter)-&gt;get_dynamic_warp_id() );
<a name="l00873"></a>00873                     }
<a name="l00874"></a>00874                 }
<a name="l00875"></a>00875             } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( valid ) {
<a name="l00876"></a>00876                <span class="comment">// this case can happen after a return instruction in diverged warp</span>
<a name="l00877"></a>00877                SCHED_DPRINTF( <span class="stringliteral">&quot;Warp (warp_id %u, dynamic_warp_id %u) return from diverged warp flush\n&quot;</span>,
<a name="l00878"></a>00878                               (*iter)-&gt;get_warp_id(), (*iter)-&gt;get_dynamic_warp_id() );
<a name="l00879"></a>00879                <a class="code" href="classscheduler__unit.html#a4d5bcb2099dd71d45d567c413a17175a">warp</a>(warp_id).<a class="code" href="classshd__warp__t.html#a008c5826f2c766b88114b77551d965ae">set_next_pc</a>(pc);
<a name="l00880"></a>00880                <a class="code" href="classscheduler__unit.html#a4d5bcb2099dd71d45d567c413a17175a">warp</a>(warp_id).<a class="code" href="classshd__warp__t.html#a6dc46f828fde98082047e1c7ca7d2f6d">ibuffer_flush</a>();
<a name="l00881"></a>00881             }
<a name="l00882"></a>00882             <span class="keywordflow">if</span>(warp_inst_issued) {
<a name="l00883"></a>00883                 SCHED_DPRINTF( <span class="stringliteral">&quot;Warp (warp_id %u, dynamic_warp_id %u) issued %u instructions\n&quot;</span>,
<a name="l00884"></a>00884                                (*iter)-&gt;get_warp_id(),
<a name="l00885"></a>00885                                (*iter)-&gt;get_dynamic_warp_id(),
<a name="l00886"></a>00886                                issued );
<a name="l00887"></a>00887                 <a class="code" href="classscheduler__unit.html#a7368e04cfd2d2c7894e9bd03bdd21d38">do_on_warp_issued</a>( warp_id, issued, iter );
<a name="l00888"></a>00888             }
<a name="l00889"></a>00889             checked++;
<a name="l00890"></a>00890         }
<a name="l00891"></a>00891         <span class="keywordflow">if</span> ( issued ) {
<a name="l00892"></a>00892             <span class="comment">// This might be a bit inefficient, but we need to maintain</span>
<a name="l00893"></a>00893             <span class="comment">// two ordered list for proper scheduler execution.</span>
<a name="l00894"></a>00894             <span class="comment">// We could remove the need for this loop by associating a</span>
<a name="l00895"></a>00895             <span class="comment">// supervised_is index with each entry in the m_next_cycle_prioritized_warps</span>
<a name="l00896"></a>00896             <span class="comment">// vector. For now, just run through until you find the right warp_id</span>
<a name="l00897"></a>00897             <span class="keywordflow">for</span> ( std::vector&lt; shd_warp_t* &gt;::const_iterator supervised_iter = <a class="code" href="classscheduler__unit.html#a9832571431a34f4c29f4745657f76f23">m_supervised_warps</a>.begin();
<a name="l00898"></a>00898                   supervised_iter != <a class="code" href="classscheduler__unit.html#a9832571431a34f4c29f4745657f76f23">m_supervised_warps</a>.end();
<a name="l00899"></a>00899                   ++supervised_iter ) {
<a name="l00900"></a>00900                 <span class="keywordflow">if</span> ( *iter == *supervised_iter ) {
<a name="l00901"></a>00901                     <a class="code" href="classscheduler__unit.html#aa97781b913455f6977abf0218bb3515e">m_last_supervised_issued</a> = supervised_iter;
<a name="l00902"></a>00902                 }
<a name="l00903"></a>00903             }
<a name="l00904"></a>00904             <span class="keywordflow">break</span>;
<a name="l00905"></a>00905         } 
<a name="l00906"></a>00906     }
<a name="l00907"></a>00907 
<a name="l00908"></a>00908     <span class="comment">// issue stall statistics:</span>
<a name="l00909"></a>00909     <span class="keywordflow">if</span>( !valid_inst ) 
<a name="l00910"></a>00910         <a class="code" href="classscheduler__unit.html#ad0259ab9afb96550c2d2d1f62326b8cc">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a2fc179319f857beff2665e91ee87d708">shader_cycle_distro</a>[0]++; <span class="comment">// idle or control hazard</span>
<a name="l00911"></a>00911     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( !ready_inst ) 
<a name="l00912"></a>00912         <a class="code" href="classscheduler__unit.html#ad0259ab9afb96550c2d2d1f62326b8cc">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a2fc179319f857beff2665e91ee87d708">shader_cycle_distro</a>[1]++; <span class="comment">// waiting for RAW hazards (possibly due to memory) </span>
<a name="l00913"></a>00913     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( !issued_inst ) 
<a name="l00914"></a>00914         <a class="code" href="classscheduler__unit.html#ad0259ab9afb96550c2d2d1f62326b8cc">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a2fc179319f857beff2665e91ee87d708">shader_cycle_distro</a>[2]++; <span class="comment">// pipeline stalled</span>
<a name="l00915"></a>00915 }
<a name="l00916"></a>00916 
<a name="l00917"></a><a class="code" href="classscheduler__unit.html#a7368e04cfd2d2c7894e9bd03bdd21d38">00917</a> <span class="keywordtype">void</span> <a class="code" href="classscheduler__unit.html#a7368e04cfd2d2c7894e9bd03bdd21d38">scheduler_unit::do_on_warp_issued</a>( <span class="keywordtype">unsigned</span> warp_id,
<a name="l00918"></a>00918                                         <span class="keywordtype">unsigned</span> num_issued,
<a name="l00919"></a>00919                                         <span class="keyword">const</span> std::vector&lt; shd_warp_t* &gt;::const_iterator&amp; prioritized_iter )
<a name="l00920"></a>00920 {
<a name="l00921"></a>00921     <a class="code" href="classscheduler__unit.html#ad0259ab9afb96550c2d2d1f62326b8cc">m_stats</a>-&gt;<a class="code" href="classshader__core__stats.html#ad1ec6fdd482ca95ced85a8748be1ce21">event_warp_issued</a>( <a class="code" href="classscheduler__unit.html#a8f4804329c218ddce1cc5a8c33f295df">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#aa300eafa842284451211fc47e61be07c">get_sid</a>(),
<a name="l00922"></a>00922                                 warp_id,
<a name="l00923"></a>00923                                 num_issued,
<a name="l00924"></a>00924                                 <a class="code" href="classscheduler__unit.html#a4d5bcb2099dd71d45d567c413a17175a">warp</a>(warp_id).<a class="code" href="classshd__warp__t.html#a0c3fbb7723caa04efc91e53ff0e30299">get_dynamic_warp_id</a>() );
<a name="l00925"></a>00925     <a class="code" href="classscheduler__unit.html#a4d5bcb2099dd71d45d567c413a17175a">warp</a>(warp_id).<a class="code" href="classshd__warp__t.html#a0f1ea6ccb93ab7cf9e121e891913087d">ibuffer_step</a>();
<a name="l00926"></a>00926 }
<a name="l00927"></a>00927 
<a name="l00928"></a><a class="code" href="classscheduler__unit.html#a0ff78ed75a5b33fbe6e441c65e06a9d1">00928</a> <span class="keywordtype">bool</span> <a class="code" href="classscheduler__unit.html#a0ff78ed75a5b33fbe6e441c65e06a9d1">scheduler_unit::sort_warps_by_oldest_dynamic_id</a>(<a class="code" href="classshd__warp__t.html">shd_warp_t</a>* lhs, <a class="code" href="classshd__warp__t.html">shd_warp_t</a>* rhs)
<a name="l00929"></a>00929 {
<a name="l00930"></a>00930     <span class="keywordflow">if</span> (rhs &amp;&amp; lhs) {
<a name="l00931"></a>00931         <span class="keywordflow">if</span> ( lhs-&gt;<a class="code" href="classshd__warp__t.html#afd25c3deec8a38e7f920162986034c13">done_exit</a>() || lhs-&gt;<a class="code" href="classshd__warp__t.html#ac6fc987f2b4fd09b6610a41ea0e6ffba">waiting</a>() ) {
<a name="l00932"></a>00932             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00933"></a>00933         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( rhs-&gt;<a class="code" href="classshd__warp__t.html#afd25c3deec8a38e7f920162986034c13">done_exit</a>() || rhs-&gt;<a class="code" href="classshd__warp__t.html#ac6fc987f2b4fd09b6610a41ea0e6ffba">waiting</a>() ) {
<a name="l00934"></a>00934             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00935"></a>00935         } <span class="keywordflow">else</span> {
<a name="l00936"></a>00936             <span class="keywordflow">return</span> lhs-&gt;<a class="code" href="classshd__warp__t.html#a0c3fbb7723caa04efc91e53ff0e30299">get_dynamic_warp_id</a>() &lt; rhs-&gt;<a class="code" href="classshd__warp__t.html#a0c3fbb7723caa04efc91e53ff0e30299">get_dynamic_warp_id</a>();
<a name="l00937"></a>00937         }
<a name="l00938"></a>00938     } <span class="keywordflow">else</span> {
<a name="l00939"></a>00939         <span class="keywordflow">return</span> lhs &lt; rhs;
<a name="l00940"></a>00940     }
<a name="l00941"></a>00941 }
<a name="l00942"></a>00942 
<a name="l00943"></a><a class="code" href="classlrr__scheduler.html#a0792db3ec851fbab106957621f72c8ae">00943</a> <span class="keywordtype">void</span> <a class="code" href="classlrr__scheduler.html#a0792db3ec851fbab106957621f72c8ae">lrr_scheduler::order_warps</a>()
<a name="l00944"></a>00944 {
<a name="l00945"></a>00945     <a class="code" href="classscheduler__unit.html#a58620ddfcd76bd9470f754f38b244c34">order_lrr</a>( <a class="code" href="classscheduler__unit.html#aed0dfcbf7afcf8bfffb0405dc4a2cf57">m_next_cycle_prioritized_warps</a>,
<a name="l00946"></a>00946                <a class="code" href="classscheduler__unit.html#a9832571431a34f4c29f4745657f76f23">m_supervised_warps</a>,
<a name="l00947"></a>00947                <a class="code" href="classscheduler__unit.html#aa97781b913455f6977abf0218bb3515e">m_last_supervised_issued</a>,
<a name="l00948"></a>00948                <a class="code" href="classscheduler__unit.html#a9832571431a34f4c29f4745657f76f23">m_supervised_warps</a>.size() );
<a name="l00949"></a>00949 }
<a name="l00950"></a>00950 
<a name="l00951"></a><a class="code" href="classgto__scheduler.html#a6765c39f5008d493a085ce0d42fec8a8">00951</a> <span class="keywordtype">void</span> <a class="code" href="classgto__scheduler.html#a6765c39f5008d493a085ce0d42fec8a8">gto_scheduler::order_warps</a>()
<a name="l00952"></a>00952 {
<a name="l00953"></a>00953     <a class="code" href="classscheduler__unit.html#a10863caa95bd3ce03458451eb66d270d">order_by_priority</a>( <a class="code" href="classscheduler__unit.html#aed0dfcbf7afcf8bfffb0405dc4a2cf57">m_next_cycle_prioritized_warps</a>,
<a name="l00954"></a>00954                        <a class="code" href="classscheduler__unit.html#a9832571431a34f4c29f4745657f76f23">m_supervised_warps</a>,
<a name="l00955"></a>00955                        <a class="code" href="classscheduler__unit.html#aa97781b913455f6977abf0218bb3515e">m_last_supervised_issued</a>,
<a name="l00956"></a>00956                        <a class="code" href="classscheduler__unit.html#a9832571431a34f4c29f4745657f76f23">m_supervised_warps</a>.size(),
<a name="l00957"></a>00957                        <a class="code" href="classscheduler__unit.html#a14ce574cf8996f904ff29a9f6e744f7aa18121527f07e6a2dc6319b755593eff7">ORDERING_GREEDY_THEN_PRIORITY_FUNC</a>,
<a name="l00958"></a>00958                        <a class="code" href="classscheduler__unit.html#a0ff78ed75a5b33fbe6e441c65e06a9d1">scheduler_unit::sort_warps_by_oldest_dynamic_id</a> );
<a name="l00959"></a>00959 }
<a name="l00960"></a>00960 
<a name="l00961"></a>00961 <span class="keywordtype">void</span>
<a name="l00962"></a><a class="code" href="classtwo__level__active__scheduler.html#a36aaccec8ed2c42868179542d1f005bc">00962</a> <a class="code" href="classtwo__level__active__scheduler.html#a36aaccec8ed2c42868179542d1f005bc">two_level_active_scheduler::do_on_warp_issued</a>( <span class="keywordtype">unsigned</span> warp_id,
<a name="l00963"></a>00963                                                <span class="keywordtype">unsigned</span> num_issued,
<a name="l00964"></a>00964                                                <span class="keyword">const</span> std::vector&lt; shd_warp_t* &gt;::const_iterator&amp; prioritized_iter )
<a name="l00965"></a>00965 {
<a name="l00966"></a>00966     <a class="code" href="classtwo__level__active__scheduler.html#a36aaccec8ed2c42868179542d1f005bc">scheduler_unit::do_on_warp_issued</a>( warp_id, num_issued, prioritized_iter );
<a name="l00967"></a>00967     <span class="keywordflow">if</span> ( <a class="code" href="shader_8h.html#a0b9f082557a63ceb16f148c9e2d11d86a2a5d8779ca5b7e72093f608682211077">SCHEDULER_PRIORITIZATION_LRR</a> == <a class="code" href="classtwo__level__active__scheduler.html#a1647832546938855478146befa84ff22">m_inner_level_prioritization</a> ) {
<a name="l00968"></a>00968         std::vector&lt; shd_warp_t* &gt; new_active; 
<a name="l00969"></a>00969         <a class="code" href="classscheduler__unit.html#a58620ddfcd76bd9470f754f38b244c34">order_lrr</a>( new_active,
<a name="l00970"></a>00970                    <a class="code" href="classscheduler__unit.html#aed0dfcbf7afcf8bfffb0405dc4a2cf57">m_next_cycle_prioritized_warps</a>,
<a name="l00971"></a>00971                    prioritized_iter,
<a name="l00972"></a>00972                    <a class="code" href="classscheduler__unit.html#aed0dfcbf7afcf8bfffb0405dc4a2cf57">m_next_cycle_prioritized_warps</a>.size() );
<a name="l00973"></a>00973         <a class="code" href="classscheduler__unit.html#aed0dfcbf7afcf8bfffb0405dc4a2cf57">m_next_cycle_prioritized_warps</a> = new_active;
<a name="l00974"></a>00974     } <span class="keywordflow">else</span> {
<a name="l00975"></a>00975         fprintf( stderr,
<a name="l00976"></a>00976                  <span class="stringliteral">&quot;Unimplemented m_inner_level_prioritization: %d\n&quot;</span>,
<a name="l00977"></a>00977                  <a class="code" href="classtwo__level__active__scheduler.html#a1647832546938855478146befa84ff22">m_inner_level_prioritization</a> );
<a name="l00978"></a>00978         abort();
<a name="l00979"></a>00979     }
<a name="l00980"></a>00980 }
<a name="l00981"></a>00981 
<a name="l00982"></a><a class="code" href="classtwo__level__active__scheduler.html#a9536551e9338f1130914c4219c3be94f">00982</a> <span class="keywordtype">void</span> <a class="code" href="classtwo__level__active__scheduler.html#a9536551e9338f1130914c4219c3be94f">two_level_active_scheduler::order_warps</a>()
<a name="l00983"></a>00983 {
<a name="l00984"></a>00984     <span class="comment">//Move waiting warps to m_pending_warps</span>
<a name="l00985"></a>00985     <span class="keywordtype">unsigned</span> num_demoted = 0;
<a name="l00986"></a>00986     <span class="keywordflow">for</span> (   std::vector&lt; shd_warp_t* &gt;::iterator iter = <a class="code" href="classscheduler__unit.html#aed0dfcbf7afcf8bfffb0405dc4a2cf57">m_next_cycle_prioritized_warps</a>.begin();
<a name="l00987"></a>00987             iter != <a class="code" href="classscheduler__unit.html#aed0dfcbf7afcf8bfffb0405dc4a2cf57">m_next_cycle_prioritized_warps</a>.end(); ) {
<a name="l00988"></a>00988         <span class="keywordtype">bool</span> waiting = (*iter)-&gt;waiting();
<a name="l00989"></a>00989         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;4; i++){
<a name="l00990"></a>00990             <span class="keyword">const</span> <a class="code" href="classwarp__inst__t.html">warp_inst_t</a>* inst = (*iter)-&gt;ibuffer_next_inst();
<a name="l00991"></a>00991             <span class="comment">//Is the instruction waiting on a long operation?</span>
<a name="l00992"></a>00992             <span class="keywordflow">if</span> ( inst &amp;&amp; inst-&gt;<a class="code" href="classinst__t.html#a5fb3f3e1f0a98e2c25f51251cf495e9a">in</a>[i] &gt; 0 &amp;&amp; this-&gt;m_scoreboard-&gt;islongop((*iter)-&gt;get_warp_id(), inst-&gt;<a class="code" href="classinst__t.html#a5fb3f3e1f0a98e2c25f51251cf495e9a">in</a>[i])){
<a name="l00993"></a>00993                 waiting = <span class="keyword">true</span>;
<a name="l00994"></a>00994             }
<a name="l00995"></a>00995         }
<a name="l00996"></a>00996 
<a name="l00997"></a>00997         <span class="keywordflow">if</span>( waiting ) {
<a name="l00998"></a>00998             <a class="code" href="classtwo__level__active__scheduler.html#a3f216074d4a855f307427d151b0f0b02">m_pending_warps</a>.push_back(*iter);
<a name="l00999"></a>00999             iter = <a class="code" href="classscheduler__unit.html#aed0dfcbf7afcf8bfffb0405dc4a2cf57">m_next_cycle_prioritized_warps</a>.erase(iter);
<a name="l01000"></a>01000             SCHED_DPRINTF( <span class="stringliteral">&quot;DEMOTED warp_id=%d, dynamic_warp_id=%d\n&quot;</span>,
<a name="l01001"></a>01001                            (*iter)-&gt;get_warp_id(),
<a name="l01002"></a>01002                            (*iter)-&gt;get_dynamic_warp_id() );
<a name="l01003"></a>01003             ++num_demoted;
<a name="l01004"></a>01004         } <span class="keywordflow">else</span> {
<a name="l01005"></a>01005             ++iter;
<a name="l01006"></a>01006         }
<a name="l01007"></a>01007     }
<a name="l01008"></a>01008 
<a name="l01009"></a>01009     <span class="comment">//If there is space in m_next_cycle_prioritized_warps, promote the next m_pending_warps</span>
<a name="l01010"></a>01010     <span class="keywordtype">unsigned</span> num_promoted = 0;
<a name="l01011"></a>01011     <span class="keywordflow">if</span> ( <a class="code" href="shader_8h.html#a0b9f082557a63ceb16f148c9e2d11d86a2742f15e9ce0a8f8a97e123ecbc1a304">SCHEDULER_PRIORITIZATION_SRR</a> == <a class="code" href="classtwo__level__active__scheduler.html#a5558eac5e6bef0b391940426ca7d13b5">m_outer_level_prioritization</a> ) {
<a name="l01012"></a>01012         <span class="keywordflow">while</span> ( <a class="code" href="classscheduler__unit.html#aed0dfcbf7afcf8bfffb0405dc4a2cf57">m_next_cycle_prioritized_warps</a>.size() &lt; <a class="code" href="classtwo__level__active__scheduler.html#a0856d136d2b536848ab9c63192cc8126">m_max_active_warps</a> ) {
<a name="l01013"></a>01013             <a class="code" href="classscheduler__unit.html#aed0dfcbf7afcf8bfffb0405dc4a2cf57">m_next_cycle_prioritized_warps</a>.push_back(<a class="code" href="classtwo__level__active__scheduler.html#a3f216074d4a855f307427d151b0f0b02">m_pending_warps</a>.front());
<a name="l01014"></a>01014             <a class="code" href="classtwo__level__active__scheduler.html#a3f216074d4a855f307427d151b0f0b02">m_pending_warps</a>.pop_front();
<a name="l01015"></a>01015             SCHED_DPRINTF( <span class="stringliteral">&quot;PROMOTED warp_id=%d, dynamic_warp_id=%d\n&quot;</span>,
<a name="l01016"></a>01016                            (<a class="code" href="classscheduler__unit.html#aed0dfcbf7afcf8bfffb0405dc4a2cf57">m_next_cycle_prioritized_warps</a>.back())-&gt;get_warp_id(),
<a name="l01017"></a>01017                            (<a class="code" href="classscheduler__unit.html#aed0dfcbf7afcf8bfffb0405dc4a2cf57">m_next_cycle_prioritized_warps</a>.back())-&gt;get_dynamic_warp_id() );
<a name="l01018"></a>01018             ++num_promoted;
<a name="l01019"></a>01019         }
<a name="l01020"></a>01020     } <span class="keywordflow">else</span> {
<a name="l01021"></a>01021         fprintf( stderr,
<a name="l01022"></a>01022                  <span class="stringliteral">&quot;Unimplemented m_outer_level_prioritization: %d\n&quot;</span>,
<a name="l01023"></a>01023                  <a class="code" href="classtwo__level__active__scheduler.html#a5558eac5e6bef0b391940426ca7d13b5">m_outer_level_prioritization</a> );
<a name="l01024"></a>01024         abort();
<a name="l01025"></a>01025     }
<a name="l01026"></a>01026     assert( num_promoted == num_demoted );
<a name="l01027"></a>01027 }
<a name="l01028"></a>01028 
<a name="l01029"></a><a class="code" href="classswl__scheduler.html#a1f0e43d1143a0dba6f1b54e8f7d4a306">01029</a> <a class="code" href="classswl__scheduler.html#a1f0e43d1143a0dba6f1b54e8f7d4a306">swl_scheduler::swl_scheduler</a> ( <a class="code" href="classshader__core__stats.html">shader_core_stats</a>* stats, <a class="code" href="classshader__core__ctx.html">shader_core_ctx</a>* shader,
<a name="l01030"></a>01030                                <a class="code" href="classScoreboard.html">Scoreboard</a>* scoreboard, <a class="code" href="classsimt__stack.html">simt_stack</a>** simt,
<a name="l01031"></a>01031                                std::vector&lt;shd_warp_t&gt;* warp,
<a name="l01032"></a>01032                                <a class="code" href="classregister__set.html">register_set</a>* sp_out,
<a name="l01033"></a>01033                                <a class="code" href="classregister__set.html">register_set</a>* sfu_out,
<a name="l01034"></a>01034                                <a class="code" href="classregister__set.html">register_set</a>* mem_out,
<a name="l01035"></a>01035                                <span class="keywordtype">int</span> <span class="keywordtype">id</span>,
<a name="l01036"></a>01036                                <span class="keywordtype">char</span>* config_string )
<a name="l01037"></a>01037     : <a class="code" href="classscheduler__unit.html">scheduler_unit</a> ( stats, shader, scoreboard, simt, warp, sp_out, sfu_out, mem_out, id )
<a name="l01038"></a>01038 {
<a name="l01039"></a>01039     <span class="keywordtype">unsigned</span> m_prioritization_readin;
<a name="l01040"></a>01040     <span class="keywordtype">int</span> ret = sscanf( config_string,
<a name="l01041"></a>01041                       <span class="stringliteral">&quot;warp_limiting:%d:%d&quot;</span>,
<a name="l01042"></a>01042                       &amp;m_prioritization_readin,
<a name="l01043"></a>01043                       &amp;<a class="code" href="classswl__scheduler.html#a91ac627e723fcb800e7a499b78e4bbe9">m_num_warps_to_limit</a>
<a name="l01044"></a>01044                      );
<a name="l01045"></a>01045     assert( 2 == ret );
<a name="l01046"></a>01046     <a class="code" href="classswl__scheduler.html#a4bc4741350447a0cd50fc099dbd80657">m_prioritization</a> = (<a class="code" href="shader_8h.html#a0b9f082557a63ceb16f148c9e2d11d86">scheduler_prioritization_type</a>)m_prioritization_readin;
<a name="l01047"></a>01047     <span class="comment">// Currently only GTO is implemented</span>
<a name="l01048"></a>01048     assert( <a class="code" href="classswl__scheduler.html#a4bc4741350447a0cd50fc099dbd80657">m_prioritization</a> == <a class="code" href="shader_8h.html#a0b9f082557a63ceb16f148c9e2d11d86a8e3a26c3de4596bb932b32ac69156de0">SCHEDULER_PRIORITIZATION_GTO</a> );
<a name="l01049"></a>01049     assert( m_num_warps_to_limit &lt;= shader-&gt;get_config()-&gt;max_warps_per_shader );
<a name="l01050"></a>01050 }
<a name="l01051"></a>01051 
<a name="l01052"></a><a class="code" href="classswl__scheduler.html#ad9ed9eb161f0f629fc2740b5d52b59d9">01052</a> <span class="keywordtype">void</span> <a class="code" href="classswl__scheduler.html#ad9ed9eb161f0f629fc2740b5d52b59d9">swl_scheduler::order_warps</a>()
<a name="l01053"></a>01053 {
<a name="l01054"></a>01054     <span class="keywordflow">if</span> ( <a class="code" href="shader_8h.html#a0b9f082557a63ceb16f148c9e2d11d86a8e3a26c3de4596bb932b32ac69156de0">SCHEDULER_PRIORITIZATION_GTO</a> == <a class="code" href="classswl__scheduler.html#a4bc4741350447a0cd50fc099dbd80657">m_prioritization</a> ) {
<a name="l01055"></a>01055         <a class="code" href="classscheduler__unit.html#a10863caa95bd3ce03458451eb66d270d">order_by_priority</a>( <a class="code" href="classscheduler__unit.html#aed0dfcbf7afcf8bfffb0405dc4a2cf57">m_next_cycle_prioritized_warps</a>,
<a name="l01056"></a>01056                            <a class="code" href="classscheduler__unit.html#a9832571431a34f4c29f4745657f76f23">m_supervised_warps</a>,
<a name="l01057"></a>01057                            <a class="code" href="classscheduler__unit.html#aa97781b913455f6977abf0218bb3515e">m_last_supervised_issued</a>,
<a name="l01058"></a>01058                            MIN( <a class="code" href="classswl__scheduler.html#a91ac627e723fcb800e7a499b78e4bbe9">m_num_warps_to_limit</a>, <a class="code" href="classscheduler__unit.html#a9832571431a34f4c29f4745657f76f23">m_supervised_warps</a>.size() ),
<a name="l01059"></a>01059                            <a class="code" href="classscheduler__unit.html#a14ce574cf8996f904ff29a9f6e744f7aa18121527f07e6a2dc6319b755593eff7">ORDERING_GREEDY_THEN_PRIORITY_FUNC</a>,
<a name="l01060"></a>01060                            <a class="code" href="classscheduler__unit.html#a0ff78ed75a5b33fbe6e441c65e06a9d1">scheduler_unit::sort_warps_by_oldest_dynamic_id</a> );
<a name="l01061"></a>01061     } <span class="keywordflow">else</span> {
<a name="l01062"></a>01062         fprintf(stderr, <span class="stringliteral">&quot;swl_scheduler m_prioritization = %d\n&quot;</span>, <a class="code" href="classswl__scheduler.html#a4bc4741350447a0cd50fc099dbd80657">m_prioritization</a>);
<a name="l01063"></a>01063         abort();
<a name="l01064"></a>01064     }
<a name="l01065"></a>01065 }
<a name="l01066"></a>01066 
<a name="l01067"></a><a class="code" href="classshader__core__ctx.html#a50ad3c0923e18df0e704ef91da6eb9e1">01067</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#a50ad3c0923e18df0e704ef91da6eb9e1">shader_core_ctx::read_operands</a>()
<a name="l01068"></a>01068 {
<a name="l01069"></a>01069 }
<a name="l01070"></a>01070 
<a name="l01071"></a><a class="code" href="shader_8cc.html#aa227115e7055ae8021861b1aae9a715a">01071</a> <a class="code" href="abstract__hardware__model_8h.html#a4234d30919c0dcca6fca040a13ad6ae1">address_type</a> <a class="code" href="shader_8cc.html#aa227115e7055ae8021861b1aae9a715a">coalesced_segment</a>(<a class="code" href="abstract__hardware__model_8h.html#a4234d30919c0dcca6fca040a13ad6ae1">address_type</a> addr, <span class="keywordtype">unsigned</span> segment_size_lg2bytes)
<a name="l01072"></a>01072 {
<a name="l01073"></a>01073    <span class="keywordflow">return</span>  (addr &gt;&gt; segment_size_lg2bytes);
<a name="l01074"></a>01074 }
<a name="l01075"></a>01075 
<a name="l01076"></a>01076 <span class="comment">// Returns numbers of addresses in translated_addrs, each addr points to a 4B (32-bit) word</span>
<a name="l01077"></a><a class="code" href="classshader__core__ctx.html#a0c8c252c80ac39881d7f9e9e509bfb92">01077</a> <span class="keywordtype">unsigned</span> <a class="code" href="classshader__core__ctx.html#a0c8c252c80ac39881d7f9e9e509bfb92">shader_core_ctx::translate_local_memaddr</a>( <a class="code" href="abstract__hardware__model_8h.html#a4234d30919c0dcca6fca040a13ad6ae1">address_type</a> localaddr, <span class="keywordtype">unsigned</span> tid, <span class="keywordtype">unsigned</span> num_shader, <span class="keywordtype">unsigned</span> datasize, <a class="code" href="abstract__hardware__model_8h.html#adcde2e548bc855c5cb446e23e38bd12d">new_addr_type</a>* translated_addrs )
<a name="l01078"></a>01078 {
<a name="l01079"></a>01079    <span class="comment">// During functional execution, each thread sees its own memory space for local memory, but these</span>
<a name="l01080"></a>01080    <span class="comment">// need to be mapped to a shared address space for timing simulation.  We do that mapping here.</span>
<a name="l01081"></a>01081 
<a name="l01082"></a>01082    <a class="code" href="abstract__hardware__model_8h.html#a4234d30919c0dcca6fca040a13ad6ae1">address_type</a> thread_base = 0;
<a name="l01083"></a>01083    <span class="keywordtype">unsigned</span> max_concurrent_threads=0;
<a name="l01084"></a>01084    <span class="keywordflow">if</span> (<a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a7efed49664bb50e62ee0991c698bee31">gpgpu_local_mem_map</a>) {
<a name="l01085"></a>01085       <span class="comment">// Dnew = D*N + T%nTpC + nTpC*C</span>
<a name="l01086"></a>01086       <span class="comment">// N = nTpC*nCpS*nS (max concurent threads)</span>
<a name="l01087"></a>01087       <span class="comment">// C = nS*K + S (hw cta number per gpu)</span>
<a name="l01088"></a>01088       <span class="comment">// K = T/nTpC   (hw cta number per core)</span>
<a name="l01089"></a>01089       <span class="comment">// D = data index</span>
<a name="l01090"></a>01090       <span class="comment">// T = thread</span>
<a name="l01091"></a>01091       <span class="comment">// nTpC = number of threads per CTA</span>
<a name="l01092"></a>01092       <span class="comment">// nCpS = number of CTA per shader</span>
<a name="l01093"></a>01093       <span class="comment">// </span>
<a name="l01094"></a>01094       <span class="comment">// for a given local memory address threads in a CTA map to contiguous addresses,</span>
<a name="l01095"></a>01095       <span class="comment">// then distribute across memory space by CTAs from successive shader cores first, </span>
<a name="l01096"></a>01096       <span class="comment">// then by successive CTA in same shader core</span>
<a name="l01097"></a>01097       thread_base = 4*(<a class="code" href="classshader__core__ctx.html#ae5d139cc58f75380f48612110a917aec">kernel_padded_threads_per_cta</a> * (<a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a> + num_shader * (tid / <a class="code" href="classshader__core__ctx.html#ae5d139cc58f75380f48612110a917aec">kernel_padded_threads_per_cta</a>))
<a name="l01098"></a>01098                        + tid % <a class="code" href="classshader__core__ctx.html#ae5d139cc58f75380f48612110a917aec">kernel_padded_threads_per_cta</a>); 
<a name="l01099"></a>01099       max_concurrent_threads = <a class="code" href="classshader__core__ctx.html#ae5d139cc58f75380f48612110a917aec">kernel_padded_threads_per_cta</a> * <a class="code" href="classshader__core__ctx.html#a22242c73ea577d8feda0674d2dc5d46a">kernel_max_cta_per_shader</a> * num_shader;
<a name="l01100"></a>01100    } <span class="keywordflow">else</span> {
<a name="l01101"></a>01101       <span class="comment">// legacy mapping that maps the same address in the local memory space of all threads </span>
<a name="l01102"></a>01102       <span class="comment">// to a single contiguous address region </span>
<a name="l01103"></a>01103       thread_base = 4*(<a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a559092b8eaeffafe04a61f83cefe74d2">n_thread_per_shader</a> * <a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a> + tid);
<a name="l01104"></a>01104       max_concurrent_threads = num_shader * <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a559092b8eaeffafe04a61f83cefe74d2">n_thread_per_shader</a>;
<a name="l01105"></a>01105    }
<a name="l01106"></a>01106    assert( thread_base &lt; 4<span class="comment">/*word size*/</span>*max_concurrent_threads );
<a name="l01107"></a>01107 
<a name="l01108"></a>01108    <span class="comment">// If requested datasize &gt; 4B, split into multiple 4B accesses</span>
<a name="l01109"></a>01109    <span class="comment">// otherwise do one sub-4 byte memory access</span>
<a name="l01110"></a>01110    <span class="keywordtype">unsigned</span> num_accesses = 0;
<a name="l01111"></a>01111 
<a name="l01112"></a>01112    <span class="keywordflow">if</span>(datasize &gt;= 4) {
<a name="l01113"></a>01113       <span class="comment">// &gt;4B access, split into 4B chunks</span>
<a name="l01114"></a>01114       assert(datasize%4 == 0);   <span class="comment">// Must be a multiple of 4B</span>
<a name="l01115"></a>01115       num_accesses = datasize/4;
<a name="l01116"></a>01116       assert(num_accesses &lt;= <a class="code" href="abstract__hardware__model_8h.html#acc19e1a3f40248ac6a83b3cdb3df9449">MAX_ACCESSES_PER_INSN_PER_THREAD</a>); <span class="comment">// max 32B</span>
<a name="l01117"></a>01117       assert(localaddr%4 == 0); <span class="comment">// Address must be 4B aligned - required if accessing 4B per request, otherwise access will overflow into next thread&apos;s space</span>
<a name="l01118"></a>01118       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0; i&lt;num_accesses; i++) {
<a name="l01119"></a>01119           <a class="code" href="abstract__hardware__model_8h.html#a4234d30919c0dcca6fca040a13ad6ae1">address_type</a> local_word = localaddr/4 + i;
<a name="l01120"></a>01120           <a class="code" href="abstract__hardware__model_8h.html#a4234d30919c0dcca6fca040a13ad6ae1">address_type</a> linear_address = local_word*max_concurrent_threads*4 + thread_base + LOCAL_GENERIC_START;
<a name="l01121"></a>01121           translated_addrs[i] = linear_address;
<a name="l01122"></a>01122       }
<a name="l01123"></a>01123    } <span class="keywordflow">else</span> {
<a name="l01124"></a>01124       <span class="comment">// Sub-4B access, do only one access</span>
<a name="l01125"></a>01125       assert(datasize &gt; 0);
<a name="l01126"></a>01126       num_accesses = 1;
<a name="l01127"></a>01127       <a class="code" href="abstract__hardware__model_8h.html#a4234d30919c0dcca6fca040a13ad6ae1">address_type</a> local_word = localaddr/4;
<a name="l01128"></a>01128       <a class="code" href="abstract__hardware__model_8h.html#a4234d30919c0dcca6fca040a13ad6ae1">address_type</a> local_word_offset = localaddr%4;
<a name="l01129"></a>01129       assert( (localaddr+datasize-1)/4  == local_word ); <span class="comment">// Make sure access doesn&apos;t overflow into next 4B chunk</span>
<a name="l01130"></a>01130       <a class="code" href="abstract__hardware__model_8h.html#a4234d30919c0dcca6fca040a13ad6ae1">address_type</a> linear_address = local_word*max_concurrent_threads*4 + local_word_offset + thread_base + LOCAL_GENERIC_START;
<a name="l01131"></a>01131       translated_addrs[0] = linear_address;
<a name="l01132"></a>01132    }
<a name="l01133"></a>01133    <span class="keywordflow">return</span> num_accesses;
<a name="l01134"></a>01134 }
<a name="l01135"></a>01135 
<a name="l01137"></a><a class="code" href="classshader__core__ctx.html#a2d8548e11df143925641ce3ad6e59959">01137</a> <span class="keywordtype">int</span> <a class="code" href="classshader__core__ctx.html#a2d8548e11df143925641ce3ad6e59959">shader_core_ctx::test_res_bus</a>(<span class="keywordtype">int</span> latency){
<a name="l01138"></a>01138     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0; i&lt;<a class="code" href="classshader__core__ctx.html#af3d87025a8db5074483bd4d93e135e16">num_result_bus</a>; i++){
<a name="l01139"></a>01139         <span class="keywordflow">if</span>(!<a class="code" href="classshader__core__ctx.html#abe3ba763b1358db760c2dd1d55865763">m_result_bus</a>[i]-&gt;test(latency)){<span class="keywordflow">return</span> i;}
<a name="l01140"></a>01140     }
<a name="l01141"></a>01141     <span class="keywordflow">return</span> -1;
<a name="l01142"></a>01142 }
<a name="l01143"></a>01143 
<a name="l01144"></a><a class="code" href="classshader__core__ctx.html#a523f6439287036297d49d1dcc847d2d9">01144</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#a523f6439287036297d49d1dcc847d2d9">shader_core_ctx::execute</a>()
<a name="l01145"></a>01145 {
<a name="l01146"></a>01146     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0; i&lt;<a class="code" href="classshader__core__ctx.html#af3d87025a8db5074483bd4d93e135e16">num_result_bus</a>; i++){
<a name="l01147"></a>01147         *(<a class="code" href="classshader__core__ctx.html#abe3ba763b1358db760c2dd1d55865763">m_result_bus</a>[i]) &gt;&gt;=1;
<a name="l01148"></a>01148     }
<a name="l01149"></a>01149     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <a class="code" href="rng_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>=0; <a class="code" href="rng_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a> &lt; <a class="code" href="classshader__core__ctx.html#aba08149bdd564b125968d3a754e2b000">m_num_function_units</a>; <a class="code" href="rng_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>++ ) {
<a name="l01150"></a>01150         <span class="keywordtype">unsigned</span> multiplier = <a class="code" href="classshader__core__ctx.html#aac172c9e5d3c7dc27c45d09146fc8d0b">m_fu</a>[<a class="code" href="rng_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>]-&gt;clock_multiplier();
<a name="l01151"></a>01151         <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> c=0; c &lt; multiplier; c++ ) 
<a name="l01152"></a>01152             <a class="code" href="classshader__core__ctx.html#aac172c9e5d3c7dc27c45d09146fc8d0b">m_fu</a>[<a class="code" href="rng_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>]-&gt;<a class="code" href="classshader__core__ctx.html#aa890a6df3b96a815cb62448fd28409c6">cycle</a>();
<a name="l01153"></a>01153         <a class="code" href="classshader__core__ctx.html#aac172c9e5d3c7dc27c45d09146fc8d0b">m_fu</a>[<a class="code" href="rng_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>]-&gt;active_lanes_in_pipeline();
<a name="l01154"></a>01154         <span class="keyword">enum</span> <a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21">pipeline_stage_name_t</a> issue_port = <a class="code" href="classshader__core__ctx.html#a859f0864a86d62266688f0c767da0506">m_issue_port</a>[<a class="code" href="rng_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>];
<a name="l01155"></a>01155         <a class="code" href="classregister__set.html">register_set</a>&amp; issue_inst = <a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[ issue_port ];
<a name="l01156"></a>01156     <a class="code" href="classwarp__inst__t.html">warp_inst_t</a>** ready_reg = issue_inst.<a class="code" href="classregister__set.html#a736ba5ce2956c0c6814177768f50f07b">get_ready</a>();
<a name="l01157"></a>01157         <span class="keywordflow">if</span>( issue_inst.<a class="code" href="classregister__set.html#a4dd3f829dec172021e66ebeed9d59b20">has_ready</a>() &amp;&amp; <a class="code" href="classshader__core__ctx.html#aac172c9e5d3c7dc27c45d09146fc8d0b">m_fu</a>[<a class="code" href="rng_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>]-&gt;can_issue( **ready_reg ) ) {
<a name="l01158"></a>01158             <span class="keywordtype">bool</span> schedule_wb_now = !<a class="code" href="classshader__core__ctx.html#aac172c9e5d3c7dc27c45d09146fc8d0b">m_fu</a>[<a class="code" href="rng_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>]-&gt;stallable();
<a name="l01159"></a>01159             <span class="keywordtype">int</span> resbus = -1;
<a name="l01160"></a>01160             <span class="keywordflow">if</span>( schedule_wb_now &amp;&amp; (resbus=<a class="code" href="classshader__core__ctx.html#a2d8548e11df143925641ce3ad6e59959">test_res_bus</a>( (*ready_reg)-&gt;latency ))!=-1 ) {
<a name="l01161"></a>01161                 assert( (*ready_reg)-&gt;latency &lt; <a class="code" href="classshader__core__ctx.html#a476b3ec0519c3f14ebd6e24dbc86e4ca">MAX_ALU_LATENCY</a> );
<a name="l01162"></a>01162                 <a class="code" href="classshader__core__ctx.html#abe3ba763b1358db760c2dd1d55865763">m_result_bus</a>[resbus]-&gt;set( (*ready_reg)-&gt;latency );
<a name="l01163"></a>01163                 <a class="code" href="classshader__core__ctx.html#aac172c9e5d3c7dc27c45d09146fc8d0b">m_fu</a>[<a class="code" href="rng_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>]-&gt;issue( issue_inst );
<a name="l01164"></a>01164             } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( !schedule_wb_now ) {
<a name="l01165"></a>01165                 <a class="code" href="classshader__core__ctx.html#aac172c9e5d3c7dc27c45d09146fc8d0b">m_fu</a>[<a class="code" href="rng_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>]-&gt;issue( issue_inst );
<a name="l01166"></a>01166             } <span class="keywordflow">else</span> {
<a name="l01167"></a>01167                 <span class="comment">// stall issue (cannot reserve result bus)</span>
<a name="l01168"></a>01168             }
<a name="l01169"></a>01169         }
<a name="l01170"></a>01170     }
<a name="l01171"></a>01171 }
<a name="l01172"></a>01172 
<a name="l01173"></a><a class="code" href="classldst__unit.html#a46d1e56cefbc64198dbc747a16625563">01173</a> <span class="keywordtype">void</span> <a class="code" href="classldst__unit.html#a46d1e56cefbc64198dbc747a16625563">ldst_unit::print_cache_stats</a>( FILE *fp, <span class="keywordtype">unsigned</span>&amp; dl1_accesses, <span class="keywordtype">unsigned</span>&amp; dl1_misses ) {
<a name="l01174"></a>01174    <span class="keywordflow">if</span>( <a class="code" href="classldst__unit.html#ac96de3512e64b5526049ede4d3aef42c">m_L1D</a> ) {
<a name="l01175"></a>01175        <a class="code" href="classldst__unit.html#ac96de3512e64b5526049ede4d3aef42c">m_L1D</a>-&gt;<a class="code" href="classbaseline__cache.html#a742af2dacfc8bcb7d75f8aa647420b52">print</a>( fp, dl1_accesses, dl1_misses );
<a name="l01176"></a>01176    }
<a name="l01177"></a>01177 }
<a name="l01178"></a>01178 
<a name="l01179"></a><a class="code" href="classldst__unit.html#a7f41621beb9dc7d54cb6e75161770608">01179</a> <span class="keywordtype">void</span> <a class="code" href="classldst__unit.html#a8b8b9263bf9322ef1b2494d2a488ef94">ldst_unit::get_cache_stats</a>(<a class="code" href="classcache__stats.html">cache_stats</a> &amp;cs) {
<a name="l01180"></a>01180     <span class="comment">// Adds stats to &apos;cs&apos; from each cache</span>
<a name="l01181"></a>01181     <span class="keywordflow">if</span>(<a class="code" href="classldst__unit.html#ac96de3512e64b5526049ede4d3aef42c">m_L1D</a>)
<a name="l01182"></a>01182         cs += <a class="code" href="classldst__unit.html#ac96de3512e64b5526049ede4d3aef42c">m_L1D</a>-&gt;<a class="code" href="classbaseline__cache.html#af3d41b44d4bdea8c07eb66693d0dcc4e">get_stats</a>();
<a name="l01183"></a>01183     <span class="keywordflow">if</span>(<a class="code" href="classldst__unit.html#a22126652fa2f4b074e54065fc1bf0e73">m_L1C</a>)
<a name="l01184"></a>01184         cs += <a class="code" href="classldst__unit.html#a22126652fa2f4b074e54065fc1bf0e73">m_L1C</a>-&gt;<a class="code" href="classbaseline__cache.html#af3d41b44d4bdea8c07eb66693d0dcc4e">get_stats</a>();
<a name="l01185"></a>01185     <span class="keywordflow">if</span>(<a class="code" href="classldst__unit.html#aac01b4330f6596459192bbe09b7aba8f">m_L1T</a>)
<a name="l01186"></a>01186         cs += <a class="code" href="classldst__unit.html#aac01b4330f6596459192bbe09b7aba8f">m_L1T</a>-&gt;<a class="code" href="classtex__cache.html#a53717ed416ce0b7474b039eaa5d504f3">get_stats</a>();
<a name="l01187"></a>01187 
<a name="l01188"></a>01188 }
<a name="l01189"></a>01189 
<a name="l01190"></a><a class="code" href="classldst__unit.html#afe5626eb00ad9a185fd692abf4ab1ae5">01190</a> <span class="keywordtype">void</span> <a class="code" href="classldst__unit.html#afe5626eb00ad9a185fd692abf4ab1ae5">ldst_unit::get_L1D_sub_stats</a>(<span class="keyword">struct</span> <a class="code" href="structcache__sub__stats.html">cache_sub_stats</a> &amp;css)<span class="keyword"> const</span>{
<a name="l01191"></a>01191     <span class="keywordflow">if</span>(<a class="code" href="classldst__unit.html#ac96de3512e64b5526049ede4d3aef42c">m_L1D</a>)
<a name="l01192"></a>01192         <a class="code" href="classldst__unit.html#ac96de3512e64b5526049ede4d3aef42c">m_L1D</a>-&gt;<a class="code" href="classbaseline__cache.html#ab18435fe3071f7d77a41cc221e9a774d">get_sub_stats</a>(css);
<a name="l01193"></a>01193 }
<a name="l01194"></a><a class="code" href="classldst__unit.html#a0f3e0103e1a9e7ab3e52217608680fff">01194</a> <span class="keywordtype">void</span> <a class="code" href="classldst__unit.html#a0f3e0103e1a9e7ab3e52217608680fff">ldst_unit::get_L1C_sub_stats</a>(<span class="keyword">struct</span> <a class="code" href="structcache__sub__stats.html">cache_sub_stats</a> &amp;css)<span class="keyword"> const</span>{
<a name="l01195"></a>01195     <span class="keywordflow">if</span>(<a class="code" href="classldst__unit.html#a22126652fa2f4b074e54065fc1bf0e73">m_L1C</a>)
<a name="l01196"></a>01196         <a class="code" href="classldst__unit.html#a22126652fa2f4b074e54065fc1bf0e73">m_L1C</a>-&gt;<a class="code" href="classbaseline__cache.html#ab18435fe3071f7d77a41cc221e9a774d">get_sub_stats</a>(css);
<a name="l01197"></a>01197 }
<a name="l01198"></a><a class="code" href="classldst__unit.html#a4f1d72773132613e05ed8a761c2d2d0f">01198</a> <span class="keywordtype">void</span> <a class="code" href="classldst__unit.html#a4f1d72773132613e05ed8a761c2d2d0f">ldst_unit::get_L1T_sub_stats</a>(<span class="keyword">struct</span> <a class="code" href="structcache__sub__stats.html">cache_sub_stats</a> &amp;css)<span class="keyword"> const</span>{
<a name="l01199"></a>01199     <span class="keywordflow">if</span>(<a class="code" href="classldst__unit.html#aac01b4330f6596459192bbe09b7aba8f">m_L1T</a>)
<a name="l01200"></a>01200         <a class="code" href="classldst__unit.html#aac01b4330f6596459192bbe09b7aba8f">m_L1T</a>-&gt;<a class="code" href="classtex__cache.html#ac78983f81c54aec2d151415a6b0336fa">get_sub_stats</a>(css);
<a name="l01201"></a>01201 }
<a name="l01202"></a>01202 
<a name="l01203"></a><a class="code" href="classshader__core__ctx.html#a95c27fe36f8f1384340e671c964fce56">01203</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#a95c27fe36f8f1384340e671c964fce56">shader_core_ctx::warp_inst_complete</a>(<span class="keyword">const</span> <a class="code" href="classwarp__inst__t.html">warp_inst_t</a> &amp;inst)
<a name="l01204"></a>01204 {
<a name="l01205"></a>01205 <span class="preprocessor">   #if 0</span>
<a name="l01206"></a>01206 <span class="preprocessor"></span>      printf(<span class="stringliteral">&quot;[warp_inst_complete] uid=%u core=%u warp=%u pc=%#x @ time=%llu issued@%llu\n&quot;</span>, 
<a name="l01207"></a>01207              inst.<a class="code" href="classwarp__inst__t.html#ade8230e949579209fa2e9cb0873ecd48">get_uid</a>(), <a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>, inst.<a class="code" href="classwarp__inst__t.html#ab1dd215e5b3d4083cdb473d4f8bf8bf2">warp_id</a>(), inst.<a class="code" href="classinst__t.html#a76aea27709c3a0256c2615451c7daa56">pc</a>, <a class="code" href="gpu-sim_8cc.html#acef6bbfd6ec09fe29e2641cace785058">gpu_tot_sim_cycle</a> + <a class="code" href="gpu-sim_8cc.html#a659fec271553d05e676c52314c8fcfe1">gpu_sim_cycle</a>, inst.get_issue_cycle()); 
<a name="l01208"></a>01208 <span class="preprocessor">   #endif</span>
<a name="l01209"></a>01209 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(inst.<a class="code" href="classinst__t.html#aa8f66610c2913e2ce7a7db303c70ef74">op_pipe</a>==<a class="code" href="abstract__hardware__model_8h.html#a23365de714a3880b41addd50b5d4fcd0adeaf133c755d397f693da386cf6dd6dd">SP__OP</a>)
<a name="l01210"></a>01210       <a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a8331353ef53b351bb4b3fc04bc851955">m_num_sp_committed</a>[<a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>]++;
<a name="l01211"></a>01211   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(inst.<a class="code" href="classinst__t.html#aa8f66610c2913e2ce7a7db303c70ef74">op_pipe</a>==<a class="code" href="abstract__hardware__model_8h.html#a23365de714a3880b41addd50b5d4fcd0a9929303242a7117ef9dc3fbeb9d3a2b7">SFU__OP</a>)
<a name="l01212"></a>01212       <a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a455431d458d81bafb69bdc04f27b3297">m_num_sfu_committed</a>[<a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>]++;
<a name="l01213"></a>01213   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(inst.<a class="code" href="classinst__t.html#aa8f66610c2913e2ce7a7db303c70ef74">op_pipe</a>==<a class="code" href="abstract__hardware__model_8h.html#a23365de714a3880b41addd50b5d4fcd0aca23354825aa411d91bf0b10724b9c42">MEM__OP</a>)
<a name="l01214"></a>01214       <a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a815c147b732ec257d04a71af7280be8c">m_num_mem_committed</a>[<a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>]++;
<a name="l01215"></a>01215 
<a name="l01216"></a>01216   <span class="keywordflow">if</span>(<a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a316436ea9c077115168bdda018b68fa7">gpgpu_clock_gated_lanes</a>==<span class="keyword">false</span>)
<a name="l01217"></a>01217       <a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a4ea030a625b67f9f2149ad0c09f144d1">m_num_sim_insn</a>[<a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>] += <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>;
<a name="l01218"></a>01218   <span class="keywordflow">else</span>
<a name="l01219"></a>01219       <a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a4ea030a625b67f9f2149ad0c09f144d1">m_num_sim_insn</a>[<a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>] += inst.<a class="code" href="classwarp__inst__t.html#ae2478f41ed1d4ce60ceec0fa5a85623a">active_count</a>();
<a name="l01220"></a>01220 
<a name="l01221"></a>01221   <a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a104d929981b7f61a21a3f32728e6ac9c">m_num_sim_winsn</a>[<a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>]++;
<a name="l01222"></a>01222   <a class="code" href="classcore__t.html#a8c9d8ee79e128de6729806cdfa2c5301">m_gpu</a>-&gt;<a class="code" href="classgpgpu__sim.html#aae128ab46a57f0e5f322761135523e92">gpu_sim_insn</a> += inst.<a class="code" href="classwarp__inst__t.html#ae2478f41ed1d4ce60ceec0fa5a85623a">active_count</a>();
<a name="l01223"></a>01223   inst.<a class="code" href="classwarp__inst__t.html#aaa621aa519306da09ccaa82dbfeb7c37">completed</a>(<a class="code" href="gpu-sim_8cc.html#acef6bbfd6ec09fe29e2641cace785058">gpu_tot_sim_cycle</a> + gpu_sim_cycle);
<a name="l01224"></a>01224 }
<a name="l01225"></a>01225 
<a name="l01226"></a><a class="code" href="classshader__core__ctx.html#a3aac655e71bf63ca2d0369b553976e32">01226</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#a3aac655e71bf63ca2d0369b553976e32">shader_core_ctx::writeback</a>()
<a name="l01227"></a>01227 {
<a name="l01228"></a>01228 
<a name="l01229"></a>01229     <span class="keywordtype">unsigned</span> max_committed_thread_instructions=<a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a> * (<a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#ad2693743383b428410fee8a5259e2551">pipe_widths</a>[<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21a410f62d642cfe93d252e8faf55b89ea3">EX_WB</a>]); <span class="comment">//from the functional units</span>
<a name="l01230"></a>01230     <a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#ad4288ea2d7b6e4c824717759943861a4">m_pipeline_duty_cycle</a>[<a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>]=((float)(<a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a4ea030a625b67f9f2149ad0c09f144d1">m_num_sim_insn</a>[<a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>]-<a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a5da3c59b6dae1030544bd029f15f4ffb">m_last_num_sim_insn</a>[<a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>]))/max_committed_thread_instructions;
<a name="l01231"></a>01231 
<a name="l01232"></a>01232     <a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a5da3c59b6dae1030544bd029f15f4ffb">m_last_num_sim_insn</a>[<a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>]=<a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a4ea030a625b67f9f2149ad0c09f144d1">m_num_sim_insn</a>[<a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>];
<a name="l01233"></a>01233     <a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a5965d7c0db0c1e5300b19a2883c94cb0">m_last_num_sim_winsn</a>[<a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>]=<a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a104d929981b7f61a21a3f32728e6ac9c">m_num_sim_winsn</a>[<a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>];
<a name="l01234"></a>01234 
<a name="l01235"></a>01235     <a class="code" href="classwarp__inst__t.html">warp_inst_t</a>** preg = <a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21a410f62d642cfe93d252e8faf55b89ea3">EX_WB</a>].get_ready();
<a name="l01236"></a>01236     <a class="code" href="classwarp__inst__t.html">warp_inst_t</a>* pipe_reg = (preg==NULL)? NULL:*preg;
<a name="l01237"></a>01237     <span class="keywordflow">while</span>( preg and !pipe_reg-&gt;<a class="code" href="classwarp__inst__t.html#a6d8dcd93a49b024688585d9e37a86a4e">empty</a>() ) {
<a name="l01238"></a>01238         <span class="comment">/*</span>
<a name="l01239"></a>01239 <span class="comment">         * Right now, the writeback stage drains all waiting instructions</span>
<a name="l01240"></a>01240 <span class="comment">         * assuming there are enough ports in the register file or the</span>
<a name="l01241"></a>01241 <span class="comment">         * conflicts are resolved at issue.</span>
<a name="l01242"></a>01242 <span class="comment">         */</span>
<a name="l01243"></a>01243         <span class="comment">/*</span>
<a name="l01244"></a>01244 <span class="comment">         * The operand collector writeback can generally generate a stall</span>
<a name="l01245"></a>01245 <span class="comment">         * However, here, the pipelines should be un-stallable. This is</span>
<a name="l01246"></a>01246 <span class="comment">         * guaranteed because this is the first time the writeback function</span>
<a name="l01247"></a>01247 <span class="comment">         * is called after the operand collector&apos;s step function, which</span>
<a name="l01248"></a>01248 <span class="comment">         * resets the allocations. There is one case which could result in</span>
<a name="l01249"></a>01249 <span class="comment">         * the writeback function returning false (stall), which is when</span>
<a name="l01250"></a>01250 <span class="comment">         * an instruction tries to modify two registers (GPR and predicate)</span>
<a name="l01251"></a>01251 <span class="comment">         * To handle this case, we ignore the return value (thus allowing</span>
<a name="l01252"></a>01252 <span class="comment">         * no stalling).</span>
<a name="l01253"></a>01253 <span class="comment">         */</span>
<a name="l01254"></a>01254         <a class="code" href="classshader__core__ctx.html#aa8578f91af32b531ca48ccc31b440973">m_operand_collector</a>.<a class="code" href="classopndcoll__rfu__t.html#a28c5383a06f97b62df0a047a252661df">writeback</a>(*pipe_reg);
<a name="l01255"></a>01255         <span class="keywordtype">unsigned</span> warp_id = pipe_reg-&gt;<a class="code" href="classwarp__inst__t.html#ab1dd215e5b3d4083cdb473d4f8bf8bf2">warp_id</a>();
<a name="l01256"></a>01256         <a class="code" href="classshader__core__ctx.html#aeeef0a2c13838c8d65a9614c2c7610f4">m_scoreboard</a>-&gt;<a class="code" href="classScoreboard.html#a822dfe286637cded7828420921f48c91">releaseRegisters</a>( pipe_reg );
<a name="l01257"></a>01257         <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[warp_id].dec_inst_in_pipeline();
<a name="l01258"></a>01258         <a class="code" href="classshader__core__ctx.html#a95c27fe36f8f1384340e671c964fce56">warp_inst_complete</a>(*pipe_reg);
<a name="l01259"></a>01259         <a class="code" href="classcore__t.html#a8c9d8ee79e128de6729806cdfa2c5301">m_gpu</a>-&gt;<a class="code" href="classgpgpu__sim.html#a507872e9eb52f87ed7ef5ab742925f08">gpu_sim_insn_last_update_sid</a> = <a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>;
<a name="l01260"></a>01260         <a class="code" href="classcore__t.html#a8c9d8ee79e128de6729806cdfa2c5301">m_gpu</a>-&gt;<a class="code" href="classgpgpu__sim.html#a4f54fede239c2915bc08accc9478faee">gpu_sim_insn_last_update</a> = <a class="code" href="gpu-sim_8cc.html#a659fec271553d05e676c52314c8fcfe1">gpu_sim_cycle</a>;
<a name="l01261"></a>01261         <a class="code" href="classshader__core__ctx.html#ab4becab0479eefe9e3bb7c97e63f9b27">m_last_inst_gpu_sim_cycle</a> = <a class="code" href="gpu-sim_8cc.html#a659fec271553d05e676c52314c8fcfe1">gpu_sim_cycle</a>;
<a name="l01262"></a>01262         <a class="code" href="classshader__core__ctx.html#a663a5f525e11a9e5dce120d7976aa24c">m_last_inst_gpu_tot_sim_cycle</a> = <a class="code" href="gpu-sim_8cc.html#acef6bbfd6ec09fe29e2641cace785058">gpu_tot_sim_cycle</a>;
<a name="l01263"></a>01263         pipe_reg-&gt;<a class="code" href="classwarp__inst__t.html#a4ec50b2b803104315d11fb6eb8ad926f">clear</a>();
<a name="l01264"></a>01264         preg = <a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21a410f62d642cfe93d252e8faf55b89ea3">EX_WB</a>].get_ready();
<a name="l01265"></a>01265         pipe_reg = (preg==NULL)? NULL:*preg;
<a name="l01266"></a>01266     }
<a name="l01267"></a>01267 }
<a name="l01268"></a>01268 
<a name="l01269"></a><a class="code" href="classldst__unit.html#a7e0763b5571f5044b519ffaea5c29cec">01269</a> <span class="keywordtype">bool</span> <a class="code" href="classldst__unit.html#a7e0763b5571f5044b519ffaea5c29cec">ldst_unit::shared_cycle</a>( <a class="code" href="classwarp__inst__t.html">warp_inst_t</a> &amp;inst, <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7">mem_stage_stall_type</a> &amp;rc_fail, <a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6b">mem_stage_access_type</a> &amp;fail_type)
<a name="l01270"></a>01270 {
<a name="l01271"></a>01271    <span class="keywordflow">if</span>( inst.<a class="code" href="classinst__t.html#a7830eb1cfe5a305e426d8530563c11da">space</a>.<a class="code" href="classmemory__space__t.html#a9aa8b2fabc2c16d1bfda090f27ab479c">get_type</a>() != <a class="code" href="abstract__hardware__model_8h.html#a1ad2169aaa8924fcc552447f38a5b58cae27eca92c2d1dbb9adb9010e3fb7991c">shared_space</a> )
<a name="l01272"></a>01272        <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01273"></a>01273 
<a name="l01274"></a>01274    <span class="keywordflow">if</span>(inst.<a class="code" href="classwarp__inst__t.html#a5baecd0a27402f0399ccecdded196852">has_dispatch_delay</a>()){
<a name="l01275"></a>01275        <a class="code" href="classldst__unit.html#aaf741f3f1b4ccc7b9fb071d674b7d6c4">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a982a5cdda34e6bd6f676228739aae7a2">gpgpu_n_shmem_bank_access</a>[<a class="code" href="classldst__unit.html#a46546c99e7f6c92e9777bc5fd6aa995e">m_sid</a>]++;
<a name="l01276"></a>01276    }
<a name="l01277"></a>01277 
<a name="l01278"></a>01278    <span class="keywordtype">bool</span> stall = inst.<a class="code" href="classwarp__inst__t.html#a4d806fbdf1218ecee367cb44d3b5b6ca">dispatch_delay</a>();
<a name="l01279"></a>01279    <span class="keywordflow">if</span>( stall ) {
<a name="l01280"></a>01280        fail_type = <a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6baafaab45103061ad97e27ac06b8eea121">S_MEM</a>;
<a name="l01281"></a>01281        rc_fail = <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7aeff5b672a5cc1e217a576cf635b173f4">BK_CONF</a>;
<a name="l01282"></a>01282    } <span class="keywordflow">else</span> 
<a name="l01283"></a>01283        rc_fail = <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7a038f41ff0d19fa8e4741dde172051053">NO_RC_FAIL</a>;
<a name="l01284"></a>01284    <span class="keywordflow">return</span> !stall; 
<a name="l01285"></a>01285 }
<a name="l01286"></a>01286 
<a name="l01287"></a>01287 <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7">mem_stage_stall_type</a>
<a name="l01288"></a><a class="code" href="classldst__unit.html#af545da0b2cfddda42528985ce829473b">01288</a> <a class="code" href="classldst__unit.html#af545da0b2cfddda42528985ce829473b">ldst_unit::process_cache_access</a>( <a class="code" href="classcache__t.html">cache_t</a>* cache,
<a name="l01289"></a>01289                                  <a class="code" href="abstract__hardware__model_8h.html#adcde2e548bc855c5cb446e23e38bd12d">new_addr_type</a> address,
<a name="l01290"></a>01290                                  <a class="code" href="classwarp__inst__t.html">warp_inst_t</a> &amp;inst,
<a name="l01291"></a>01291                                  std::list&lt;cache_event&gt;&amp; events,
<a name="l01292"></a>01292                                  <a class="code" href="classmem__fetch.html">mem_fetch</a> *mf,
<a name="l01293"></a>01293                                  <span class="keyword">enum</span> <a class="code" href="gpu-cache_8h.html#a6ca15cb60df1ccf2f7d8e677d11a1bbe">cache_request_status</a> status )
<a name="l01294"></a>01294 {
<a name="l01295"></a>01295     <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7">mem_stage_stall_type</a> result = <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7a038f41ff0d19fa8e4741dde172051053">NO_RC_FAIL</a>;
<a name="l01296"></a>01296     <span class="keywordtype">bool</span> write_sent = <a class="code" href="gpu-cache_8cc.html#aa34baf5c7076a8fee416099590acd38d">was_write_sent</a>(events);
<a name="l01297"></a>01297     <span class="keywordtype">bool</span> read_sent = <a class="code" href="gpu-cache_8cc.html#af9debd40908ecef2127f815eba3864fe">was_read_sent</a>(events);
<a name="l01298"></a>01298     <span class="keywordflow">if</span>( write_sent ) 
<a name="l01299"></a>01299         <a class="code" href="classldst__unit.html#abedcc8e0b874a44d980819880c5b436c">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#ae66f91fd8494fe823335c04de4c4a2fa">inc_store_req</a>( inst.<a class="code" href="classwarp__inst__t.html#ab1dd215e5b3d4083cdb473d4f8bf8bf2">warp_id</a>() );
<a name="l01300"></a>01300     <span class="keywordflow">if</span> ( status == <a class="code" href="gpu-cache_8h.html#a6ca15cb60df1ccf2f7d8e677d11a1bbead4cf8619fedf804702c72835be555da0">HIT</a> ) {
<a name="l01301"></a>01301         assert( !read_sent );
<a name="l01302"></a>01302         inst.<a class="code" href="classwarp__inst__t.html#ac53a68215e0d799173661067694346ae">accessq_pop_back</a>();
<a name="l01303"></a>01303         <span class="keywordflow">if</span> ( inst.<a class="code" href="classinst__t.html#a2a7f0ff5bdc4a059f744487d2cf255bd">is_load</a>() ) {
<a name="l01304"></a>01304             <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> r=0; r &lt; 4; r++)
<a name="l01305"></a>01305                 <span class="keywordflow">if</span> (inst.<a class="code" href="classinst__t.html#a3c2c79e427a4d22fbf44264857a02c51">out</a>[r] &gt; 0)
<a name="l01306"></a>01306                     <a class="code" href="classldst__unit.html#a1e13765c48144194fc28c0c218094ff2">m_pending_writes</a>[inst.<a class="code" href="classwarp__inst__t.html#ab1dd215e5b3d4083cdb473d4f8bf8bf2">warp_id</a>()][inst.<a class="code" href="classinst__t.html#a3c2c79e427a4d22fbf44264857a02c51">out</a>[r]]--; 
<a name="l01307"></a>01307         }
<a name="l01308"></a>01308         <span class="keywordflow">if</span>( !write_sent ) 
<a name="l01309"></a>01309             <span class="keyword">delete</span> mf;
<a name="l01310"></a>01310     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( status == <a class="code" href="gpu-cache_8h.html#a6ca15cb60df1ccf2f7d8e677d11a1bbead6cd0ba3ddc29343844c2c23345a2460">RESERVATION_FAIL</a> ) {
<a name="l01311"></a>01311         result = <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7a69e7a22f4b547c6292b30a5c5f1ad161">COAL_STALL</a>;
<a name="l01312"></a>01312         assert( !read_sent );
<a name="l01313"></a>01313         assert( !write_sent );
<a name="l01314"></a>01314         <span class="keyword">delete</span> mf;
<a name="l01315"></a>01315     } <span class="keywordflow">else</span> {
<a name="l01316"></a>01316         assert( status == <a class="code" href="gpu-cache_8h.html#a6ca15cb60df1ccf2f7d8e677d11a1bbeaf15e118f26fd4e7acd598ef7e4291b2a">MISS</a> || status == <a class="code" href="gpu-cache_8h.html#a6ca15cb60df1ccf2f7d8e677d11a1bbea14a7b666002c9619623e3ee1cf874f79">HIT_RESERVED</a> );
<a name="l01317"></a>01317         <span class="comment">//inst.clear_active( access.get_warp_mask() ); // threads in mf writeback when mf returns</span>
<a name="l01318"></a>01318         inst.<a class="code" href="classwarp__inst__t.html#ac53a68215e0d799173661067694346ae">accessq_pop_back</a>();
<a name="l01319"></a>01319     }
<a name="l01320"></a>01320     <span class="keywordflow">if</span>( !inst.<a class="code" href="classwarp__inst__t.html#add080e50183d3231cb1d22fb7f6eb43e">accessq_empty</a>() )
<a name="l01321"></a>01321         result = <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7aeff5b672a5cc1e217a576cf635b173f4">BK_CONF</a>;
<a name="l01322"></a>01322     <span class="keywordflow">return</span> result;
<a name="l01323"></a>01323 }
<a name="l01324"></a>01324 
<a name="l01325"></a><a class="code" href="classldst__unit.html#a604e2345767b7721beb1c28142a6ad3c">01325</a> <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7">mem_stage_stall_type</a> <a class="code" href="classldst__unit.html#a604e2345767b7721beb1c28142a6ad3c">ldst_unit::process_memory_access_queue</a>( <a class="code" href="classcache__t.html">cache_t</a> *cache, <a class="code" href="classwarp__inst__t.html">warp_inst_t</a> &amp;inst )
<a name="l01326"></a>01326 {
<a name="l01327"></a>01327     <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7">mem_stage_stall_type</a> result = <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7a038f41ff0d19fa8e4741dde172051053">NO_RC_FAIL</a>;
<a name="l01328"></a>01328     <span class="keywordflow">if</span>( inst.<a class="code" href="classwarp__inst__t.html#add080e50183d3231cb1d22fb7f6eb43e">accessq_empty</a>() )
<a name="l01329"></a>01329         <span class="keywordflow">return</span> result;
<a name="l01330"></a>01330 
<a name="l01331"></a>01331     <span class="keywordflow">if</span>( !cache-&gt;<a class="code" href="classcache__t.html#ae5f328f26564c3dfff8349708e712377">data_port_free</a>() ) 
<a name="l01332"></a>01332         <span class="keywordflow">return</span> <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7aeecc08cc96a1660a2f6aac0e0748f0a0">DATA_PORT_STALL</a>; 
<a name="l01333"></a>01333 
<a name="l01334"></a>01334     <span class="comment">//const mem_access_t &amp;access = inst.accessq_back();</span>
<a name="l01335"></a>01335     <a class="code" href="classmem__fetch.html">mem_fetch</a> *mf = <a class="code" href="classldst__unit.html#ae19c5ece19e805f0a6d6cd59e92272dc">m_mf_allocator</a>-&gt;<a class="code" href="classshader__core__mem__fetch__allocator.html#a38afc4ec939ffec8fdd405f19deaf266">alloc</a>(inst,inst.<a class="code" href="classwarp__inst__t.html#a840f7c8bbd444ba2feaaa4d8dbe92994">accessq_back</a>());
<a name="l01336"></a>01336     std::list&lt;cache_event&gt; events;
<a name="l01337"></a>01337     <span class="keyword">enum</span> <a class="code" href="gpu-cache_8h.html#a6ca15cb60df1ccf2f7d8e677d11a1bbe">cache_request_status</a> status = cache-&gt;<a class="code" href="classcache__t.html#a2f58217d5dfda5ce0e37da8de5641976">access</a>(mf-&gt;<a class="code" href="classmem__fetch.html#a06fa448b09acf9a40fd294aa5877895b">get_addr</a>(),mf,<a class="code" href="gpu-sim_8cc.html#a659fec271553d05e676c52314c8fcfe1">gpu_sim_cycle</a>+<a class="code" href="gpu-sim_8cc.html#acef6bbfd6ec09fe29e2641cace785058">gpu_tot_sim_cycle</a>,events);
<a name="l01338"></a>01338     <span class="keywordflow">return</span> <a class="code" href="classldst__unit.html#af545da0b2cfddda42528985ce829473b">process_cache_access</a>( cache, mf-&gt;<a class="code" href="classmem__fetch.html#a06fa448b09acf9a40fd294aa5877895b">get_addr</a>(), inst, events, mf, status );
<a name="l01339"></a>01339 }
<a name="l01340"></a>01340 
<a name="l01341"></a><a class="code" href="classldst__unit.html#ab8946433d44a095c4d2aa210df0d3478">01341</a> <span class="keywordtype">bool</span> <a class="code" href="classldst__unit.html#ab8946433d44a095c4d2aa210df0d3478">ldst_unit::constant_cycle</a>( <a class="code" href="classwarp__inst__t.html">warp_inst_t</a> &amp;inst, <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7">mem_stage_stall_type</a> &amp;rc_fail, <a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6b">mem_stage_access_type</a> &amp;fail_type)
<a name="l01342"></a>01342 {
<a name="l01343"></a>01343    <span class="keywordflow">if</span>( inst.<a class="code" href="classwarp__inst__t.html#a6d8dcd93a49b024688585d9e37a86a4e">empty</a>() || ((inst.<a class="code" href="classinst__t.html#a7830eb1cfe5a305e426d8530563c11da">space</a>.<a class="code" href="classmemory__space__t.html#a9aa8b2fabc2c16d1bfda090f27ab479c">get_type</a>() != <a class="code" href="abstract__hardware__model_8h.html#a1ad2169aaa8924fcc552447f38a5b58ca445236c52ac314c07392ad430f155071">const_space</a>) &amp;&amp; (inst.<a class="code" href="classinst__t.html#a7830eb1cfe5a305e426d8530563c11da">space</a>.<a class="code" href="classmemory__space__t.html#a9aa8b2fabc2c16d1bfda090f27ab479c">get_type</a>() != <a class="code" href="abstract__hardware__model_8h.html#a1ad2169aaa8924fcc552447f38a5b58ca5448bfae061180e01eb15ce5fec7bdcc">param_space_kernel</a>)) )
<a name="l01344"></a>01344        <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01345"></a>01345    <span class="keywordflow">if</span>( inst.<a class="code" href="classwarp__inst__t.html#ae2478f41ed1d4ce60ceec0fa5a85623a">active_count</a>() == 0 ) 
<a name="l01346"></a>01346        <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01347"></a>01347    <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7">mem_stage_stall_type</a> fail = <a class="code" href="classldst__unit.html#a604e2345767b7721beb1c28142a6ad3c">process_memory_access_queue</a>(<a class="code" href="classldst__unit.html#a22126652fa2f4b074e54065fc1bf0e73">m_L1C</a>,inst);
<a name="l01348"></a>01348    <span class="keywordflow">if</span> (fail != <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7a038f41ff0d19fa8e4741dde172051053">NO_RC_FAIL</a>){ 
<a name="l01349"></a>01349       rc_fail = fail; <span class="comment">//keep other fails if this didn&apos;t fail.</span>
<a name="l01350"></a>01350       fail_type = <a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba64e2520dc68772a0eb40cd5d374b2e6b">C_MEM</a>;
<a name="l01351"></a>01351       <span class="keywordflow">if</span> (rc_fail == <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7aeff5b672a5cc1e217a576cf635b173f4">BK_CONF</a> or rc_fail == <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7a69e7a22f4b547c6292b30a5c5f1ad161">COAL_STALL</a>) {
<a name="l01352"></a>01352          <a class="code" href="classldst__unit.html#aaf741f3f1b4ccc7b9fb071d674b7d6c4">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a127137bb46f65167a8359e1a8896780c">gpgpu_n_cmem_portconflict</a>++; <span class="comment">//coal stalls aren&apos;t really a bank conflict, but this maintains previous behavior.</span>
<a name="l01353"></a>01353       }
<a name="l01354"></a>01354    }
<a name="l01355"></a>01355    <span class="keywordflow">return</span> inst.<a class="code" href="classwarp__inst__t.html#add080e50183d3231cb1d22fb7f6eb43e">accessq_empty</a>(); <span class="comment">//done if empty.</span>
<a name="l01356"></a>01356 }
<a name="l01357"></a>01357 
<a name="l01358"></a><a class="code" href="classldst__unit.html#acfa393f589a4033ffd8b230676a01684">01358</a> <span class="keywordtype">bool</span> <a class="code" href="classldst__unit.html#acfa393f589a4033ffd8b230676a01684">ldst_unit::texture_cycle</a>( <a class="code" href="classwarp__inst__t.html">warp_inst_t</a> &amp;inst, <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7">mem_stage_stall_type</a> &amp;rc_fail, <a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6b">mem_stage_access_type</a> &amp;fail_type)
<a name="l01359"></a>01359 {
<a name="l01360"></a>01360    <span class="keywordflow">if</span>( inst.<a class="code" href="classwarp__inst__t.html#a6d8dcd93a49b024688585d9e37a86a4e">empty</a>() || inst.<a class="code" href="classinst__t.html#a7830eb1cfe5a305e426d8530563c11da">space</a>.<a class="code" href="classmemory__space__t.html#a9aa8b2fabc2c16d1bfda090f27ab479c">get_type</a>() != <a class="code" href="abstract__hardware__model_8h.html#a1ad2169aaa8924fcc552447f38a5b58cadc0c390c9425eb280596cbf66b5d4d4f">tex_space</a> )
<a name="l01361"></a>01361        <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01362"></a>01362    <span class="keywordflow">if</span>( inst.<a class="code" href="classwarp__inst__t.html#ae2478f41ed1d4ce60ceec0fa5a85623a">active_count</a>() == 0 ) 
<a name="l01363"></a>01363        <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01364"></a>01364    <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7">mem_stage_stall_type</a> fail = <a class="code" href="classldst__unit.html#a604e2345767b7721beb1c28142a6ad3c">process_memory_access_queue</a>(<a class="code" href="classldst__unit.html#aac01b4330f6596459192bbe09b7aba8f">m_L1T</a>,inst);
<a name="l01365"></a>01365    <span class="keywordflow">if</span> (fail != <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7a038f41ff0d19fa8e4741dde172051053">NO_RC_FAIL</a>){ 
<a name="l01366"></a>01366       rc_fail = fail; <span class="comment">//keep other fails if this didn&apos;t fail.</span>
<a name="l01367"></a>01367       fail_type = <a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba5705e3ad2281df35ebcedce51899ce5e">T_MEM</a>;
<a name="l01368"></a>01368    }
<a name="l01369"></a>01369    <span class="keywordflow">return</span> inst.<a class="code" href="classwarp__inst__t.html#add080e50183d3231cb1d22fb7f6eb43e">accessq_empty</a>(); <span class="comment">//done if empty.</span>
<a name="l01370"></a>01370 }
<a name="l01371"></a>01371 
<a name="l01372"></a><a class="code" href="classldst__unit.html#afdc184c09232a71eb2640d8257018713">01372</a> <span class="keywordtype">bool</span> <a class="code" href="classldst__unit.html#afdc184c09232a71eb2640d8257018713">ldst_unit::memory_cycle</a>( <a class="code" href="classwarp__inst__t.html">warp_inst_t</a> &amp;inst, <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7">mem_stage_stall_type</a> &amp;stall_reason, <a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6b">mem_stage_access_type</a> &amp;access_type )
<a name="l01373"></a>01373 {
<a name="l01374"></a>01374    <span class="keywordflow">if</span>( inst.<a class="code" href="classwarp__inst__t.html#a6d8dcd93a49b024688585d9e37a86a4e">empty</a>() || 
<a name="l01375"></a>01375        ((inst.<a class="code" href="classinst__t.html#a7830eb1cfe5a305e426d8530563c11da">space</a>.<a class="code" href="classmemory__space__t.html#a9aa8b2fabc2c16d1bfda090f27ab479c">get_type</a>() != <a class="code" href="abstract__hardware__model_8h.html#a1ad2169aaa8924fcc552447f38a5b58cade54d01d283e68c3e9c5b8d75b85e49e">global_space</a>) &amp;&amp;
<a name="l01376"></a>01376         (inst.<a class="code" href="classinst__t.html#a7830eb1cfe5a305e426d8530563c11da">space</a>.<a class="code" href="classmemory__space__t.html#a9aa8b2fabc2c16d1bfda090f27ab479c">get_type</a>() != <a class="code" href="abstract__hardware__model_8h.html#a1ad2169aaa8924fcc552447f38a5b58ca133ba819812b7d97221aed15cb830967">local_space</a>) &amp;&amp;
<a name="l01377"></a>01377         (inst.<a class="code" href="classinst__t.html#a7830eb1cfe5a305e426d8530563c11da">space</a>.<a class="code" href="classmemory__space__t.html#a9aa8b2fabc2c16d1bfda090f27ab479c">get_type</a>() != <a class="code" href="abstract__hardware__model_8h.html#a1ad2169aaa8924fcc552447f38a5b58ca2f594286872ffab4d06ed69f65f111ac">param_space_local</a>)) ) 
<a name="l01378"></a>01378        <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01379"></a>01379    <span class="keywordflow">if</span>( inst.<a class="code" href="classwarp__inst__t.html#ae2478f41ed1d4ce60ceec0fa5a85623a">active_count</a>() == 0 ) 
<a name="l01380"></a>01380        <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01381"></a>01381    assert( !inst.<a class="code" href="classwarp__inst__t.html#add080e50183d3231cb1d22fb7f6eb43e">accessq_empty</a>() );
<a name="l01382"></a>01382    <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7">mem_stage_stall_type</a> stall_cond = <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7a038f41ff0d19fa8e4741dde172051053">NO_RC_FAIL</a>;
<a name="l01383"></a>01383    <span class="keyword">const</span> <a class="code" href="classmem__access__t.html">mem_access_t</a> &amp;access = inst.<a class="code" href="classwarp__inst__t.html#a840f7c8bbd444ba2feaaa4d8dbe92994">accessq_back</a>();
<a name="l01384"></a>01384 
<a name="l01385"></a>01385    <span class="keywordtype">bool</span> bypassL1D = <span class="keyword">false</span>; 
<a name="l01386"></a>01386    <span class="keywordflow">if</span> ( <a class="code" href="abstract__hardware__model_8h.html#ab204345d04c216e6d47f2f19501d7072a652584484432dcd6c7a2a620a2ee44cf">CACHE_GLOBAL</a> == inst.<a class="code" href="classinst__t.html#a329da97dfe6b0972748e988793b1d684">cache_op</a> || (<a class="code" href="classldst__unit.html#ac96de3512e64b5526049ede4d3aef42c">m_L1D</a> == NULL) ) {
<a name="l01387"></a>01387        bypassL1D = <span class="keyword">true</span>; 
<a name="l01388"></a>01388    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (inst.<a class="code" href="classinst__t.html#a7830eb1cfe5a305e426d8530563c11da">space</a>.<a class="code" href="classmemory__space__t.html#ae3b156e97c9a1bb07df539952824db06">is_global</a>()) { <span class="comment">// global memory access </span>
<a name="l01389"></a>01389        <span class="comment">// skip L1 cache if the option is enabled</span>
<a name="l01390"></a>01390        <span class="keywordflow">if</span> (<a class="code" href="classldst__unit.html#abedcc8e0b874a44d980819880c5b436c">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#a0dfa04be25f749a0a690843a13db0881">get_config</a>()-&gt;<a class="code" href="structshader__core__config.html#a0807f53693e797a1195a3a4c70e02b8b">gmem_skip_L1D</a>) 
<a name="l01391"></a>01391            bypassL1D = <span class="keyword">true</span>; 
<a name="l01392"></a>01392    }
<a name="l01393"></a>01393 
<a name="l01394"></a>01394    <span class="keywordflow">if</span>( bypassL1D ) {
<a name="l01395"></a>01395        <span class="comment">// bypass L1 cache</span>
<a name="l01396"></a>01396        <span class="keywordtype">unsigned</span> control_size = inst.<a class="code" href="classinst__t.html#a4a4af03ae60d4f77f84d07c0264a5354">is_store</a>() ? WRITE_PACKET_SIZE : READ_PACKET_SIZE;
<a name="l01397"></a>01397        <span class="keywordtype">unsigned</span> size = access.<a class="code" href="classmem__access__t.html#a6937659d4da1a76093e97c8a2dd6662a">get_size</a>() + control_size;
<a name="l01398"></a>01398        <span class="keywordflow">if</span>( <a class="code" href="classldst__unit.html#ab5410deea4d8b019d2fff8027e7f8b36">m_icnt</a>-&gt;<a class="code" href="classmem__fetch__interface.html#aa658575deee8358107ff13b82599e84d">full</a>(size, inst.<a class="code" href="classinst__t.html#a4a4af03ae60d4f77f84d07c0264a5354">is_store</a>() || inst.<a class="code" href="classwarp__inst__t.html#ad5046e7f41d1188cf9428d160b3ead73">isatomic</a>()) ) {
<a name="l01399"></a>01399            stall_cond = <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7a7ffa00b440a82b64996be240be743ea2">ICNT_RC_FAIL</a>;
<a name="l01400"></a>01400        } <span class="keywordflow">else</span> {
<a name="l01401"></a>01401            <a class="code" href="classmem__fetch.html">mem_fetch</a> *mf = <a class="code" href="classldst__unit.html#ae19c5ece19e805f0a6d6cd59e92272dc">m_mf_allocator</a>-&gt;<a class="code" href="classshader__core__mem__fetch__allocator.html#a38afc4ec939ffec8fdd405f19deaf266">alloc</a>(inst,access);
<a name="l01402"></a>01402            <a class="code" href="classldst__unit.html#ab5410deea4d8b019d2fff8027e7f8b36">m_icnt</a>-&gt;<a class="code" href="classmem__fetch__interface.html#a0a1a7f338acd49ae5f864faaa3ead792">push</a>(mf);
<a name="l01403"></a>01403            inst.<a class="code" href="classwarp__inst__t.html#ac53a68215e0d799173661067694346ae">accessq_pop_back</a>();
<a name="l01404"></a>01404            <span class="comment">//inst.clear_active( access.get_warp_mask() );</span>
<a name="l01405"></a>01405            <span class="keywordflow">if</span>( inst.<a class="code" href="classinst__t.html#a2a7f0ff5bdc4a059f744487d2cf255bd">is_load</a>() ) { 
<a name="l01406"></a>01406               <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> r=0; r &lt; 4; r++) 
<a name="l01407"></a>01407                   <span class="keywordflow">if</span>(inst.<a class="code" href="classinst__t.html#a3c2c79e427a4d22fbf44264857a02c51">out</a>[r] &gt; 0) 
<a name="l01408"></a>01408                       assert( <a class="code" href="classldst__unit.html#a1e13765c48144194fc28c0c218094ff2">m_pending_writes</a>[inst.<a class="code" href="classwarp__inst__t.html#ab1dd215e5b3d4083cdb473d4f8bf8bf2">warp_id</a>()][inst.<a class="code" href="classinst__t.html#a3c2c79e427a4d22fbf44264857a02c51">out</a>[r]] &gt; 0 );
<a name="l01409"></a>01409            } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( inst.<a class="code" href="classinst__t.html#a4a4af03ae60d4f77f84d07c0264a5354">is_store</a>() ) 
<a name="l01410"></a>01410               <a class="code" href="classldst__unit.html#abedcc8e0b874a44d980819880c5b436c">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#ae66f91fd8494fe823335c04de4c4a2fa">inc_store_req</a>( inst.<a class="code" href="classwarp__inst__t.html#ab1dd215e5b3d4083cdb473d4f8bf8bf2">warp_id</a>() );
<a name="l01411"></a>01411        }
<a name="l01412"></a>01412    } <span class="keywordflow">else</span> {
<a name="l01413"></a>01413        assert( <a class="code" href="abstract__hardware__model_8h.html#ab204345d04c216e6d47f2f19501d7072a499eb549cbf6cae61c01a7dbfbfcd886">CACHE_UNDEFINED</a> != inst.<a class="code" href="classinst__t.html#a329da97dfe6b0972748e988793b1d684">cache_op</a> );
<a name="l01414"></a>01414        stall_cond = <a class="code" href="classldst__unit.html#a604e2345767b7721beb1c28142a6ad3c">process_memory_access_queue</a>(<a class="code" href="classldst__unit.html#ac96de3512e64b5526049ede4d3aef42c">m_L1D</a>,inst);
<a name="l01415"></a>01415    }
<a name="l01416"></a>01416    <span class="keywordflow">if</span>( !inst.<a class="code" href="classwarp__inst__t.html#add080e50183d3231cb1d22fb7f6eb43e">accessq_empty</a>() ) 
<a name="l01417"></a>01417        stall_cond = <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7a69e7a22f4b547c6292b30a5c5f1ad161">COAL_STALL</a>;
<a name="l01418"></a>01418    <span class="keywordflow">if</span> (stall_cond != <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7a038f41ff0d19fa8e4741dde172051053">NO_RC_FAIL</a>) {
<a name="l01419"></a>01419       stall_reason = stall_cond;
<a name="l01420"></a>01420       <span class="keywordtype">bool</span> iswrite = inst.<a class="code" href="classinst__t.html#a4a4af03ae60d4f77f84d07c0264a5354">is_store</a>();
<a name="l01421"></a>01421       <span class="keywordflow">if</span> (inst.<a class="code" href="classinst__t.html#a7830eb1cfe5a305e426d8530563c11da">space</a>.<a class="code" href="classmemory__space__t.html#a3923696fe191c32d4444d57295713783">is_local</a>()) 
<a name="l01422"></a>01422          access_type = (iswrite)?<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba787ee7762f9e00740f1ee06e037a61f1">L_MEM_ST</a>:<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba3e389b44611ee9099dd377891b9ea3e7">L_MEM_LD</a>;
<a name="l01423"></a>01423       <span class="keywordflow">else</span> 
<a name="l01424"></a>01424          access_type = (iswrite)?<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6bafeb5fc327919b9f67e00bda3110b1197">G_MEM_ST</a>:<a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6ba237d2f12f219a732c3d67526b2b4df34">G_MEM_LD</a>;
<a name="l01425"></a>01425    }
<a name="l01426"></a>01426    <span class="keywordflow">return</span> inst.<a class="code" href="classwarp__inst__t.html#add080e50183d3231cb1d22fb7f6eb43e">accessq_empty</a>(); 
<a name="l01427"></a>01427 }
<a name="l01428"></a>01428 
<a name="l01429"></a>01429 
<a name="l01430"></a><a class="code" href="classldst__unit.html#a3f9446852a78a8ad4995eaf1d1f6c291">01430</a> <span class="keywordtype">bool</span> <a class="code" href="classldst__unit.html#a3f9446852a78a8ad4995eaf1d1f6c291">ldst_unit::response_buffer_full</a>()<span class="keyword"> const</span>
<a name="l01431"></a>01431 <span class="keyword"></span>{
<a name="l01432"></a>01432     <span class="keywordflow">return</span> <a class="code" href="classldst__unit.html#a56ec0edb13afbb6454646012bbda37e2">m_response_fifo</a>.size() &gt;= <a class="code" href="classsimd__function__unit.html#a398a2a0d2e52ca4beb15ef5e9ccb4c61">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a843cef2da1d2994b18aeac6db9e612a6">ldst_unit_response_queue_size</a>;
<a name="l01433"></a>01433 }
<a name="l01434"></a>01434 
<a name="l01435"></a><a class="code" href="classldst__unit.html#a6893386745321f4fab709390fc56cba6">01435</a> <span class="keywordtype">void</span> <a class="code" href="classldst__unit.html#a6893386745321f4fab709390fc56cba6">ldst_unit::fill</a>( <a class="code" href="classmem__fetch.html">mem_fetch</a> *mf )
<a name="l01436"></a>01436 {
<a name="l01437"></a>01437     mf-&gt;<a class="code" href="classmem__fetch.html#acbda50764b3c8d6f79ffa279021253da">set_status</a>(IN_SHADER_LDST_RESPONSE_FIFO,<a class="code" href="gpu-sim_8cc.html#a659fec271553d05e676c52314c8fcfe1">gpu_sim_cycle</a>+<a class="code" href="gpu-sim_8cc.html#acef6bbfd6ec09fe29e2641cace785058">gpu_tot_sim_cycle</a>);
<a name="l01438"></a>01438     <a class="code" href="classldst__unit.html#a56ec0edb13afbb6454646012bbda37e2">m_response_fifo</a>.push_back(mf);
<a name="l01439"></a>01439 }
<a name="l01440"></a>01440 
<a name="l01441"></a><a class="code" href="classldst__unit.html#a76f91783e5b63f626a4240e0507e8792">01441</a> <span class="keywordtype">void</span> <a class="code" href="classldst__unit.html#a76f91783e5b63f626a4240e0507e8792">ldst_unit::flush</a>(){
<a name="l01442"></a>01442     <span class="comment">// Flush L1D cache</span>
<a name="l01443"></a>01443     <a class="code" href="classldst__unit.html#ac96de3512e64b5526049ede4d3aef42c">m_L1D</a>-&gt;<a class="code" href="classbaseline__cache.html#a994069b98eb1be5326e618cafb04bb79">flush</a>();
<a name="l01444"></a>01444 }
<a name="l01445"></a>01445 
<a name="l01446"></a><a class="code" href="classsimd__function__unit.html#ac469444b61426a7693a9587ae48a9bd4">01446</a> <a class="code" href="classsimd__function__unit.html#ac469444b61426a7693a9587ae48a9bd4">simd_function_unit::simd_function_unit</a>( <span class="keyword">const</span> <a class="code" href="structshader__core__config.html">shader_core_config</a> *config )
<a name="l01447"></a>01447 { 
<a name="l01448"></a>01448     <a class="code" href="classsimd__function__unit.html#a398a2a0d2e52ca4beb15ef5e9ccb4c61">m_config</a>=config;
<a name="l01449"></a>01449     <a class="code" href="classsimd__function__unit.html#ae55a510a8ce9e0ee2dc1d8a66578e5f2">m_dispatch_reg</a> = <span class="keyword">new</span> <a class="code" href="classwarp__inst__t.html">warp_inst_t</a>(config); 
<a name="l01450"></a>01450 }
<a name="l01451"></a>01451 
<a name="l01452"></a>01452 
<a name="l01453"></a><a class="code" href="classsfu.html#acc5ccf36881cf6381b3fcb0389966877">01453</a> <a class="code" href="classsfu.html#acc5ccf36881cf6381b3fcb0389966877">sfu:: sfu</a>(  <a class="code" href="classregister__set.html">register_set</a>* result_port, <span class="keyword">const</span> <a class="code" href="structshader__core__config.html">shader_core_config</a> *config,<a class="code" href="classshader__core__ctx.html">shader_core_ctx</a> *core  )
<a name="l01454"></a>01454     : <a class="code" href="classpipelined__simd__unit.html">pipelined_simd_unit</a>(result_port,config,config-&gt;max_sfu_latency,core)
<a name="l01455"></a>01455 { 
<a name="l01456"></a>01456     <a class="code" href="classsimd__function__unit.html#ab0ccdde2ab806f9e05cb44f23e1845be">m_name</a> = <span class="stringliteral">&quot;SFU&quot;</span>; 
<a name="l01457"></a>01457 }
<a name="l01458"></a>01458 
<a name="l01459"></a><a class="code" href="classsfu.html#a29721e37759871b1fa9cda679e9e53f2">01459</a> <span class="keywordtype">void</span> <a class="code" href="classsfu.html#a29721e37759871b1fa9cda679e9e53f2">sfu::issue</a>( <a class="code" href="classregister__set.html">register_set</a>&amp; source_reg )
<a name="l01460"></a>01460 {
<a name="l01461"></a>01461     <a class="code" href="classwarp__inst__t.html">warp_inst_t</a>** ready_reg = source_reg.<a class="code" href="classregister__set.html#a736ba5ce2956c0c6814177768f50f07b">get_ready</a>();
<a name="l01462"></a>01462     <span class="comment">//m_core-&gt;incexecstat((*ready_reg));</span>
<a name="l01463"></a>01463 
<a name="l01464"></a>01464     (*ready_reg)-&gt;<a class="code" href="classinst__t.html#aa8f66610c2913e2ce7a7db303c70ef74">op_pipe</a>=<a class="code" href="abstract__hardware__model_8h.html#a23365de714a3880b41addd50b5d4fcd0a9929303242a7117ef9dc3fbeb9d3a2b7">SFU__OP</a>;
<a name="l01465"></a>01465     <a class="code" href="classpipelined__simd__unit.html#a948677d84c5368ea30f3163e01ed7230">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#a22b7f22c25219126740803d2d54e1691">incsfu_stat</a>(<a class="code" href="classpipelined__simd__unit.html#a948677d84c5368ea30f3163e01ed7230">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#a0dfa04be25f749a0a690843a13db0881">get_config</a>()-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>,(*ready_reg)-&gt;latency);
<a name="l01466"></a>01466     <a class="code" href="classsfu.html#a29721e37759871b1fa9cda679e9e53f2">pipelined_simd_unit::issue</a>(source_reg);
<a name="l01467"></a>01467 }
<a name="l01468"></a>01468 
<a name="l01469"></a><a class="code" href="classldst__unit.html#ac0e81dd2ab52579a1bedb380e2ea73cd">01469</a> <span class="keywordtype">void</span> <a class="code" href="classldst__unit.html#ac0e81dd2ab52579a1bedb380e2ea73cd">ldst_unit::active_lanes_in_pipeline</a>(){
<a name="l01470"></a>01470     <span class="keywordtype">unsigned</span> active_count=<a class="code" href="classpipelined__simd__unit.html#aaf564a4b837845fedacd0d59e13a1775">pipelined_simd_unit::get_active_lanes_in_pipeline</a>();
<a name="l01471"></a>01471     assert(active_count&lt;=m_core-&gt;get_config()-&gt;warp_size);
<a name="l01472"></a>01472     <a class="code" href="classldst__unit.html#abedcc8e0b874a44d980819880c5b436c">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#aad2772578ccf787c14eeab09e1b24083">incfumemactivelanes_stat</a>(active_count);
<a name="l01473"></a>01473 }
<a name="l01474"></a><a class="code" href="classsp__unit.html#a9cb63c74a8dadf3e21bbf44fb8dd11b0">01474</a> <span class="keywordtype">void</span> <a class="code" href="classsp__unit.html#a9cb63c74a8dadf3e21bbf44fb8dd11b0">sp_unit::active_lanes_in_pipeline</a>(){
<a name="l01475"></a>01475     <span class="keywordtype">unsigned</span> active_count=<a class="code" href="classpipelined__simd__unit.html#aaf564a4b837845fedacd0d59e13a1775">pipelined_simd_unit::get_active_lanes_in_pipeline</a>();
<a name="l01476"></a>01476     assert(active_count&lt;=m_core-&gt;get_config()-&gt;warp_size);
<a name="l01477"></a>01477     <a class="code" href="classpipelined__simd__unit.html#a948677d84c5368ea30f3163e01ed7230">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#a319c8a0f39804114427cf3cc9e88f456">incspactivelanes_stat</a>(active_count);
<a name="l01478"></a>01478     <a class="code" href="classpipelined__simd__unit.html#a948677d84c5368ea30f3163e01ed7230">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#a09c65a6ed9b97c3dfdb80f60b3e1b898">incfuactivelanes_stat</a>(active_count);
<a name="l01479"></a>01479     <a class="code" href="classpipelined__simd__unit.html#a948677d84c5368ea30f3163e01ed7230">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#aad2772578ccf787c14eeab09e1b24083">incfumemactivelanes_stat</a>(active_count);
<a name="l01480"></a>01480 }
<a name="l01481"></a>01481 
<a name="l01482"></a><a class="code" href="classsfu.html#a6abe11ba7d0b76d468e3684b6665937e">01482</a> <span class="keywordtype">void</span> <a class="code" href="classsfu.html#a6abe11ba7d0b76d468e3684b6665937e">sfu::active_lanes_in_pipeline</a>(){
<a name="l01483"></a>01483     <span class="keywordtype">unsigned</span> active_count=<a class="code" href="classpipelined__simd__unit.html#aaf564a4b837845fedacd0d59e13a1775">pipelined_simd_unit::get_active_lanes_in_pipeline</a>();
<a name="l01484"></a>01484     assert(active_count&lt;=m_core-&gt;get_config()-&gt;warp_size);
<a name="l01485"></a>01485     <a class="code" href="classpipelined__simd__unit.html#a948677d84c5368ea30f3163e01ed7230">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#a658dfd3e42a4d98de914bb1c7304303b">incsfuactivelanes_stat</a>(active_count);
<a name="l01486"></a>01486     <a class="code" href="classpipelined__simd__unit.html#a948677d84c5368ea30f3163e01ed7230">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#a09c65a6ed9b97c3dfdb80f60b3e1b898">incfuactivelanes_stat</a>(active_count);
<a name="l01487"></a>01487     <a class="code" href="classpipelined__simd__unit.html#a948677d84c5368ea30f3163e01ed7230">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#aad2772578ccf787c14eeab09e1b24083">incfumemactivelanes_stat</a>(active_count);
<a name="l01488"></a>01488 }
<a name="l01489"></a>01489 
<a name="l01490"></a><a class="code" href="classsp__unit.html#a7c64927934be02abd7cabdf538a96b37">01490</a> <a class="code" href="classsp__unit.html#a7c64927934be02abd7cabdf538a96b37">sp_unit::sp_unit</a>( <a class="code" href="classregister__set.html">register_set</a>* result_port, <span class="keyword">const</span> <a class="code" href="structshader__core__config.html">shader_core_config</a> *config,<a class="code" href="classshader__core__ctx.html">shader_core_ctx</a> *core)
<a name="l01491"></a>01491     : <a class="code" href="classpipelined__simd__unit.html">pipelined_simd_unit</a>(result_port,config,config-&gt;max_sp_latency,core)
<a name="l01492"></a>01492 { 
<a name="l01493"></a>01493     <a class="code" href="classsimd__function__unit.html#ab0ccdde2ab806f9e05cb44f23e1845be">m_name</a> = <span class="stringliteral">&quot;SP &quot;</span>; 
<a name="l01494"></a>01494 }
<a name="l01495"></a>01495 
<a name="l01496"></a><a class="code" href="classsp__unit.html#a925d6a74e6a57edcc65ab24d6106a4a1">01496</a> <span class="keywordtype">void</span> <a class="code" href="classsp__unit.html#a925d6a74e6a57edcc65ab24d6106a4a1">sp_unit :: issue</a>(<a class="code" href="classregister__set.html">register_set</a>&amp; source_reg)
<a name="l01497"></a>01497 {
<a name="l01498"></a>01498     <a class="code" href="classwarp__inst__t.html">warp_inst_t</a>** ready_reg = source_reg.<a class="code" href="classregister__set.html#a736ba5ce2956c0c6814177768f50f07b">get_ready</a>();
<a name="l01499"></a>01499     <span class="comment">//m_core-&gt;incexecstat((*ready_reg));</span>
<a name="l01500"></a>01500     (*ready_reg)-&gt;<a class="code" href="classinst__t.html#aa8f66610c2913e2ce7a7db303c70ef74">op_pipe</a>=<a class="code" href="abstract__hardware__model_8h.html#a23365de714a3880b41addd50b5d4fcd0adeaf133c755d397f693da386cf6dd6dd">SP__OP</a>;
<a name="l01501"></a>01501     <a class="code" href="classpipelined__simd__unit.html#a948677d84c5368ea30f3163e01ed7230">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#a9e490466784d172a6e917a19478e21e8">incsp_stat</a>(<a class="code" href="classpipelined__simd__unit.html#a948677d84c5368ea30f3163e01ed7230">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#a0dfa04be25f749a0a690843a13db0881">get_config</a>()-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>,(*ready_reg)-&gt;latency);
<a name="l01502"></a>01502     <a class="code" href="classsp__unit.html#a925d6a74e6a57edcc65ab24d6106a4a1">pipelined_simd_unit::issue</a>(source_reg);
<a name="l01503"></a>01503 }
<a name="l01504"></a>01504 
<a name="l01505"></a>01505 
<a name="l01506"></a><a class="code" href="classpipelined__simd__unit.html#abad14b016779942a7052782d7dd1322f">01506</a> <a class="code" href="classpipelined__simd__unit.html#abad14b016779942a7052782d7dd1322f">pipelined_simd_unit::pipelined_simd_unit</a>( <a class="code" href="classregister__set.html">register_set</a>* result_port, <span class="keyword">const</span> <a class="code" href="structshader__core__config.html">shader_core_config</a> *config, <span class="keywordtype">unsigned</span> max_latency,<a class="code" href="classshader__core__ctx.html">shader_core_ctx</a> *core )
<a name="l01507"></a>01507     : <a class="code" href="classsimd__function__unit.html">simd_function_unit</a>(config) 
<a name="l01508"></a>01508 {
<a name="l01509"></a>01509     <a class="code" href="classpipelined__simd__unit.html#a2284a79d74986ec979d8cf6a116d4494">m_result_port</a> = result_port;
<a name="l01510"></a>01510     <a class="code" href="classpipelined__simd__unit.html#a369e75de3c10c9a710f96965450ef2eb">m_pipeline_depth</a> = max_latency;
<a name="l01511"></a>01511     <a class="code" href="classpipelined__simd__unit.html#afffbdc979fcae64032976300a7787a13">m_pipeline_reg</a> = <span class="keyword">new</span> <a class="code" href="classwarp__inst__t.html">warp_inst_t</a>*[<a class="code" href="classpipelined__simd__unit.html#a369e75de3c10c9a710f96965450ef2eb">m_pipeline_depth</a>];
<a name="l01512"></a>01512     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i &lt; <a class="code" href="classpipelined__simd__unit.html#a369e75de3c10c9a710f96965450ef2eb">m_pipeline_depth</a>; i++ ) 
<a name="l01513"></a>01513     <a class="code" href="classpipelined__simd__unit.html#afffbdc979fcae64032976300a7787a13">m_pipeline_reg</a>[i] = <span class="keyword">new</span> <a class="code" href="classwarp__inst__t.html">warp_inst_t</a>( config );
<a name="l01514"></a>01514     <a class="code" href="classpipelined__simd__unit.html#a948677d84c5368ea30f3163e01ed7230">m_core</a>=core;
<a name="l01515"></a>01515 }
<a name="l01516"></a>01516 
<a name="l01517"></a>01517 
<a name="l01518"></a><a class="code" href="classpipelined__simd__unit.html#adcf290292423add479416267ca7c175e">01518</a> <span class="keywordtype">void</span> <a class="code" href="classpipelined__simd__unit.html#adcf290292423add479416267ca7c175e">pipelined_simd_unit::issue</a>( <a class="code" href="classregister__set.html">register_set</a>&amp; source_reg )
<a name="l01519"></a>01519 {
<a name="l01520"></a>01520     <span class="comment">//move_warp(m_dispatch_reg,source_reg);</span>
<a name="l01521"></a>01521     <a class="code" href="classwarp__inst__t.html">warp_inst_t</a>** ready_reg = source_reg.<a class="code" href="classregister__set.html#a736ba5ce2956c0c6814177768f50f07b">get_ready</a>();
<a name="l01522"></a>01522     <a class="code" href="classpipelined__simd__unit.html#a948677d84c5368ea30f3163e01ed7230">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#afe3c3bd2faef867520995e7cab19484a">incexecstat</a>((*ready_reg));
<a name="l01523"></a>01523     <span class="comment">//source_reg.move_out_to(m_dispatch_reg);</span>
<a name="l01524"></a>01524     <a class="code" href="classpipelined__simd__unit.html#adcf290292423add479416267ca7c175e">simd_function_unit::issue</a>(source_reg);
<a name="l01525"></a>01525 }
<a name="l01526"></a>01526 
<a name="l01527"></a>01527 <span class="comment">/*</span>
<a name="l01528"></a>01528 <span class="comment">    virtual void issue( register_set&amp; source_reg )</span>
<a name="l01529"></a>01529 <span class="comment">    {</span>
<a name="l01530"></a>01530 <span class="comment">        //move_warp(m_dispatch_reg,source_reg);</span>
<a name="l01531"></a>01531 <span class="comment">        //source_reg.move_out_to(m_dispatch_reg);</span>
<a name="l01532"></a>01532 <span class="comment">        simd_function_unit::issue(source_reg);</span>
<a name="l01533"></a>01533 <span class="comment">    }</span>
<a name="l01534"></a>01534 <span class="comment">*/</span>
<a name="l01535"></a>01535 
<a name="l01536"></a><a class="code" href="classldst__unit.html#a328e191e9f12551855503dee55b41544">01536</a> <span class="keywordtype">void</span> <a class="code" href="classldst__unit.html#a328e191e9f12551855503dee55b41544">ldst_unit::init</a>( <a class="code" href="classmem__fetch__interface.html">mem_fetch_interface</a> *icnt,
<a name="l01537"></a>01537                       <a class="code" href="classshader__core__mem__fetch__allocator.html">shader_core_mem_fetch_allocator</a> *mf_allocator,
<a name="l01538"></a>01538                       <a class="code" href="classshader__core__ctx.html">shader_core_ctx</a> *core, 
<a name="l01539"></a>01539                       <a class="code" href="classopndcoll__rfu__t.html">opndcoll_rfu_t</a> *operand_collector,
<a name="l01540"></a>01540                       <a class="code" href="classScoreboard.html">Scoreboard</a> *scoreboard,
<a name="l01541"></a>01541                       <span class="keyword">const</span> <a class="code" href="structshader__core__config.html">shader_core_config</a> *config,
<a name="l01542"></a>01542                       <span class="keyword">const</span> <a class="code" href="structmemory__config.html">memory_config</a> *mem_config,  
<a name="l01543"></a>01543                       <a class="code" href="classshader__core__stats.html">shader_core_stats</a> *stats,
<a name="l01544"></a>01544                       <span class="keywordtype">unsigned</span> sid,
<a name="l01545"></a>01545                       <span class="keywordtype">unsigned</span> tpc )
<a name="l01546"></a>01546 {
<a name="l01547"></a>01547     <a class="code" href="classldst__unit.html#af1d1fc6ffb84f6e9cd14c705dba1b196">m_memory_config</a> = mem_config;
<a name="l01548"></a>01548     <a class="code" href="classldst__unit.html#ab5410deea4d8b019d2fff8027e7f8b36">m_icnt</a> = icnt;
<a name="l01549"></a>01549     <a class="code" href="classldst__unit.html#ae19c5ece19e805f0a6d6cd59e92272dc">m_mf_allocator</a>=mf_allocator;
<a name="l01550"></a>01550     <a class="code" href="classldst__unit.html#abedcc8e0b874a44d980819880c5b436c">m_core</a> = core;
<a name="l01551"></a>01551     <a class="code" href="classldst__unit.html#af1db452f68f75bd831ece8eaceb41641">m_operand_collector</a> = operand_collector;
<a name="l01552"></a>01552     <a class="code" href="classldst__unit.html#ad09290c55345d4406f8c6d67de3f9904">m_scoreboard</a> = scoreboard;
<a name="l01553"></a>01553     <a class="code" href="classldst__unit.html#aaf741f3f1b4ccc7b9fb071d674b7d6c4">m_stats</a> = stats;
<a name="l01554"></a>01554     <a class="code" href="classldst__unit.html#a46546c99e7f6c92e9777bc5fd6aa995e">m_sid</a> = sid;
<a name="l01555"></a>01555     <a class="code" href="classldst__unit.html#a1e56d52422cf219befe4e98dfad8f3a6">m_tpc</a> = tpc;
<a name="l01556"></a>01556 <span class="preprocessor">    #define STRSIZE 1024</span>
<a name="l01557"></a>01557 <span class="preprocessor"></span>    <span class="keywordtype">char</span> L1T_name[STRSIZE];
<a name="l01558"></a>01558     <span class="keywordtype">char</span> L1C_name[STRSIZE];
<a name="l01559"></a>01559     snprintf(L1T_name, STRSIZE, <span class="stringliteral">&quot;L1T_%03d&quot;</span>, <a class="code" href="classldst__unit.html#a46546c99e7f6c92e9777bc5fd6aa995e">m_sid</a>);
<a name="l01560"></a>01560     snprintf(L1C_name, STRSIZE, <span class="stringliteral">&quot;L1C_%03d&quot;</span>, <a class="code" href="classldst__unit.html#a46546c99e7f6c92e9777bc5fd6aa995e">m_sid</a>);
<a name="l01561"></a>01561     <a class="code" href="classldst__unit.html#aac01b4330f6596459192bbe09b7aba8f">m_L1T</a> = <span class="keyword">new</span> <a class="code" href="classtex__cache.html">tex_cache</a>(L1T_name,<a class="code" href="classsimd__function__unit.html#a398a2a0d2e52ca4beb15ef5e9ccb4c61">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a97e70c22ec0f090203fbd1831d59a968">m_L1T_config</a>,<a class="code" href="classldst__unit.html#a46546c99e7f6c92e9777bc5fd6aa995e">m_sid</a>,<a class="code" href="stat-tool_8cc.html#a5d37a6563e37999fa30f8a8057df80fc">get_shader_texture_cache_id</a>(),icnt,IN_L1T_MISS_QUEUE,IN_SHADER_L1T_ROB);
<a name="l01562"></a>01562     <a class="code" href="classldst__unit.html#a22126652fa2f4b074e54065fc1bf0e73">m_L1C</a> = <span class="keyword">new</span> <a class="code" href="classread__only__cache.html" title="Read only cache.">read_only_cache</a>(L1C_name,<a class="code" href="classsimd__function__unit.html#a398a2a0d2e52ca4beb15ef5e9ccb4c61">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a57349ee5d040d4b532798f0c68710d12">m_L1C_config</a>,<a class="code" href="classldst__unit.html#a46546c99e7f6c92e9777bc5fd6aa995e">m_sid</a>,<a class="code" href="stat-tool_8cc.html#ac2c837987fd9d8968739e672bc28bc09">get_shader_constant_cache_id</a>(),icnt,IN_L1C_MISS_QUEUE);
<a name="l01563"></a>01563     <a class="code" href="classldst__unit.html#ac96de3512e64b5526049ede4d3aef42c">m_L1D</a> = NULL;
<a name="l01564"></a>01564     <a class="code" href="classldst__unit.html#ae89492e94d8bba86f04558b35f5ba834">m_mem_rc</a> = <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7a038f41ff0d19fa8e4741dde172051053">NO_RC_FAIL</a>;
<a name="l01565"></a>01565     <a class="code" href="classldst__unit.html#aabc95be7da543dfbc686299e9e4ac05a">m_num_writeback_clients</a>=5; <span class="comment">// = shared memory, global/local (uncached), L1D, L1T, L1C</span>
<a name="l01566"></a>01566     <a class="code" href="classldst__unit.html#a19d49ed4f150a81c52a65828b1d457ac">m_writeback_arb</a> = 0;
<a name="l01567"></a>01567     <a class="code" href="classldst__unit.html#ac071341d8cadf33b9596437d22a40730">m_next_global</a>=NULL;
<a name="l01568"></a>01568     <a class="code" href="classldst__unit.html#aff0e2865331fd8bec6c96061958a0c20">m_last_inst_gpu_sim_cycle</a>=0;
<a name="l01569"></a>01569     <a class="code" href="classldst__unit.html#a358b1600ef78f0f9657e391afc19fa2b">m_last_inst_gpu_tot_sim_cycle</a>=0;
<a name="l01570"></a>01570 }
<a name="l01571"></a>01571 
<a name="l01572"></a>01572 
<a name="l01573"></a><a class="code" href="classldst__unit.html#a67268fb1da5800658bf5904d2ab75c39">01573</a> <a class="code" href="classldst__unit.html#a67268fb1da5800658bf5904d2ab75c39">ldst_unit::ldst_unit</a>( <a class="code" href="classmem__fetch__interface.html">mem_fetch_interface</a> *icnt,
<a name="l01574"></a>01574                       <a class="code" href="classshader__core__mem__fetch__allocator.html">shader_core_mem_fetch_allocator</a> *mf_allocator,
<a name="l01575"></a>01575                       <a class="code" href="classshader__core__ctx.html">shader_core_ctx</a> *core, 
<a name="l01576"></a>01576                       <a class="code" href="classopndcoll__rfu__t.html">opndcoll_rfu_t</a> *operand_collector,
<a name="l01577"></a>01577                       <a class="code" href="classScoreboard.html">Scoreboard</a> *scoreboard,
<a name="l01578"></a>01578                       <span class="keyword">const</span> <a class="code" href="structshader__core__config.html">shader_core_config</a> *config,
<a name="l01579"></a>01579                       <span class="keyword">const</span> <a class="code" href="structmemory__config.html">memory_config</a> *mem_config,  
<a name="l01580"></a>01580                       <a class="code" href="classshader__core__stats.html">shader_core_stats</a> *stats,
<a name="l01581"></a>01581                       <span class="keywordtype">unsigned</span> sid,
<a name="l01582"></a>01582                       <span class="keywordtype">unsigned</span> tpc ) : <a class="code" href="classpipelined__simd__unit.html">pipelined_simd_unit</a>(NULL,config,3,core), m_next_wb(config)
<a name="l01583"></a>01583 {
<a name="l01584"></a>01584     <a class="code" href="classldst__unit.html#a328e191e9f12551855503dee55b41544">init</a>( icnt,
<a name="l01585"></a>01585           mf_allocator,
<a name="l01586"></a>01586           core, 
<a name="l01587"></a>01587           operand_collector,
<a name="l01588"></a>01588           scoreboard,
<a name="l01589"></a>01589           config, 
<a name="l01590"></a>01590           mem_config,  
<a name="l01591"></a>01591           stats, 
<a name="l01592"></a>01592           sid,
<a name="l01593"></a>01593           tpc );
<a name="l01594"></a>01594     <span class="keywordflow">if</span>( !<a class="code" href="classsimd__function__unit.html#a398a2a0d2e52ca4beb15ef5e9ccb4c61">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a4068e626fdfc6e4b44a8fdd656a44b94">m_L1D_config</a>.<a class="code" href="classcache__config.html#a6e719909c6b7bea759a1d98bc49236b3">disabled</a>() ) {
<a name="l01595"></a>01595         <span class="keywordtype">char</span> L1D_name[STRSIZE];
<a name="l01596"></a>01596         snprintf(L1D_name, STRSIZE, <span class="stringliteral">&quot;L1D_%03d&quot;</span>, <a class="code" href="classldst__unit.html#a46546c99e7f6c92e9777bc5fd6aa995e">m_sid</a>);
<a name="l01597"></a>01597         <a class="code" href="classldst__unit.html#ac96de3512e64b5526049ede4d3aef42c">m_L1D</a> = <span class="keyword">new</span> <a class="code" href="classl1__cache.html">l1_cache</a>( L1D_name,
<a name="l01598"></a>01598                               <a class="code" href="classsimd__function__unit.html#a398a2a0d2e52ca4beb15ef5e9ccb4c61">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a4068e626fdfc6e4b44a8fdd656a44b94">m_L1D_config</a>,
<a name="l01599"></a>01599                               <a class="code" href="classldst__unit.html#a46546c99e7f6c92e9777bc5fd6aa995e">m_sid</a>,
<a name="l01600"></a>01600                               <a class="code" href="stat-tool_8cc.html#ac9543b74af4b29923888ed631e62686a">get_shader_normal_cache_id</a>(),
<a name="l01601"></a>01601                               <a class="code" href="classldst__unit.html#ab5410deea4d8b019d2fff8027e7f8b36">m_icnt</a>,
<a name="l01602"></a>01602                               <a class="code" href="classldst__unit.html#ae19c5ece19e805f0a6d6cd59e92272dc">m_mf_allocator</a>,
<a name="l01603"></a>01603                               IN_L1D_MISS_QUEUE );
<a name="l01604"></a>01604     }
<a name="l01605"></a>01605 }
<a name="l01606"></a>01606 
<a name="l01607"></a><a class="code" href="classldst__unit.html#aeb3aad75fd2256ddf2f6fe2eefc6584a">01607</a> <a class="code" href="classldst__unit.html#a67268fb1da5800658bf5904d2ab75c39">ldst_unit::ldst_unit</a>( <a class="code" href="classmem__fetch__interface.html">mem_fetch_interface</a> *icnt,
<a name="l01608"></a>01608                       <a class="code" href="classshader__core__mem__fetch__allocator.html">shader_core_mem_fetch_allocator</a> *mf_allocator,
<a name="l01609"></a>01609                       <a class="code" href="classshader__core__ctx.html">shader_core_ctx</a> *core, 
<a name="l01610"></a>01610                       <a class="code" href="classopndcoll__rfu__t.html">opndcoll_rfu_t</a> *operand_collector,
<a name="l01611"></a>01611                       <a class="code" href="classScoreboard.html">Scoreboard</a> *scoreboard,
<a name="l01612"></a>01612                       <span class="keyword">const</span> <a class="code" href="structshader__core__config.html">shader_core_config</a> *config,
<a name="l01613"></a>01613                       <span class="keyword">const</span> <a class="code" href="structmemory__config.html">memory_config</a> *mem_config,  
<a name="l01614"></a>01614                       <a class="code" href="classshader__core__stats.html">shader_core_stats</a> *stats,
<a name="l01615"></a>01615                       <span class="keywordtype">unsigned</span> sid,
<a name="l01616"></a>01616                       <span class="keywordtype">unsigned</span> tpc,
<a name="l01617"></a>01617                       <a class="code" href="classl1__cache.html">l1_cache</a>* new_l1d_cache )
<a name="l01618"></a>01618     : <a class="code" href="classpipelined__simd__unit.html">pipelined_simd_unit</a>(NULL,config,3,core), m_L1D(new_l1d_cache), m_next_wb(config)
<a name="l01619"></a>01619 {
<a name="l01620"></a>01620     <a class="code" href="classldst__unit.html#a328e191e9f12551855503dee55b41544">init</a>( icnt,
<a name="l01621"></a>01621           mf_allocator,
<a name="l01622"></a>01622           core, 
<a name="l01623"></a>01623           operand_collector,
<a name="l01624"></a>01624           scoreboard,
<a name="l01625"></a>01625           config, 
<a name="l01626"></a>01626           mem_config,  
<a name="l01627"></a>01627           stats, 
<a name="l01628"></a>01628           sid,
<a name="l01629"></a>01629           tpc );
<a name="l01630"></a>01630 }
<a name="l01631"></a>01631 
<a name="l01632"></a><a class="code" href="classldst__unit.html#a1987f8c98376a0b1c98d31ccc42b0a4b">01632</a> <span class="keywordtype">void</span> <a class="code" href="classldst__unit.html#a1987f8c98376a0b1c98d31ccc42b0a4b">ldst_unit:: issue</a>( <a class="code" href="classregister__set.html">register_set</a> &amp;reg_set )
<a name="l01633"></a>01633 {
<a name="l01634"></a>01634     <a class="code" href="classwarp__inst__t.html">warp_inst_t</a>* inst = *(reg_set.<a class="code" href="classregister__set.html#a736ba5ce2956c0c6814177768f50f07b">get_ready</a>());
<a name="l01635"></a>01635 
<a name="l01636"></a>01636    <span class="comment">// record how many pending register writes/memory accesses there are for this instruction</span>
<a name="l01637"></a>01637    assert(inst-&gt;<a class="code" href="classwarp__inst__t.html#a6d8dcd93a49b024688585d9e37a86a4e">empty</a>() == <span class="keyword">false</span>);
<a name="l01638"></a>01638    <span class="keywordflow">if</span> (inst-&gt;<a class="code" href="classinst__t.html#a2a7f0ff5bdc4a059f744487d2cf255bd">is_load</a>() and inst-&gt;<a class="code" href="classinst__t.html#a7830eb1cfe5a305e426d8530563c11da">space</a>.<a class="code" href="classmemory__space__t.html#a9aa8b2fabc2c16d1bfda090f27ab479c">get_type</a>() != <a class="code" href="abstract__hardware__model_8h.html#a1ad2169aaa8924fcc552447f38a5b58cae27eca92c2d1dbb9adb9010e3fb7991c">shared_space</a>) {
<a name="l01639"></a>01639       <span class="keywordtype">unsigned</span> warp_id = inst-&gt;<a class="code" href="classwarp__inst__t.html#ab1dd215e5b3d4083cdb473d4f8bf8bf2">warp_id</a>();
<a name="l01640"></a>01640       <span class="keywordtype">unsigned</span> n_accesses = inst-&gt;<a class="code" href="classwarp__inst__t.html#af7237cd02688a40a086556facb08fb44">accessq_count</a>();
<a name="l01641"></a>01641       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> r = 0; r &lt; 4; r++) {
<a name="l01642"></a>01642          <span class="keywordtype">unsigned</span> reg_id = inst-&gt;<a class="code" href="classinst__t.html#a3c2c79e427a4d22fbf44264857a02c51">out</a>[r];
<a name="l01643"></a>01643          <span class="keywordflow">if</span> (reg_id &gt; 0) {
<a name="l01644"></a>01644             <a class="code" href="classldst__unit.html#a1e13765c48144194fc28c0c218094ff2">m_pending_writes</a>[warp_id][reg_id] += n_accesses;
<a name="l01645"></a>01645          }
<a name="l01646"></a>01646       }
<a name="l01647"></a>01647    }
<a name="l01648"></a>01648 
<a name="l01649"></a>01649 
<a name="l01650"></a>01650     inst-&gt;<a class="code" href="classinst__t.html#aa8f66610c2913e2ce7a7db303c70ef74">op_pipe</a>=<a class="code" href="abstract__hardware__model_8h.html#a23365de714a3880b41addd50b5d4fcd0aca23354825aa411d91bf0b10724b9c42">MEM__OP</a>;
<a name="l01651"></a>01651     <span class="comment">// stat collection</span>
<a name="l01652"></a>01652     <a class="code" href="classldst__unit.html#abedcc8e0b874a44d980819880c5b436c">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#a0b606ff67f6f29976f4b99f6a284c08a">mem_instruction_stats</a>(*inst);
<a name="l01653"></a>01653     <a class="code" href="classldst__unit.html#abedcc8e0b874a44d980819880c5b436c">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#a18570525763774bc4f105def9b46d72a">incmem_stat</a>(<a class="code" href="classldst__unit.html#abedcc8e0b874a44d980819880c5b436c">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#a0dfa04be25f749a0a690843a13db0881">get_config</a>()-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>,1);
<a name="l01654"></a>01654     <a class="code" href="classldst__unit.html#a1987f8c98376a0b1c98d31ccc42b0a4b">pipelined_simd_unit::issue</a>(reg_set);
<a name="l01655"></a>01655 }
<a name="l01656"></a>01656 
<a name="l01657"></a><a class="code" href="classldst__unit.html#a8c51837eac2823aa53eda252f088e07e">01657</a> <span class="keywordtype">void</span> <a class="code" href="classldst__unit.html#a8c51837eac2823aa53eda252f088e07e">ldst_unit::writeback</a>()
<a name="l01658"></a>01658 {
<a name="l01659"></a>01659     <span class="comment">// process next instruction that is going to writeback</span>
<a name="l01660"></a>01660     <span class="keywordflow">if</span>( !<a class="code" href="classldst__unit.html#ac71d0e9348f6d668e796c97752516354">m_next_wb</a>.<a class="code" href="classwarp__inst__t.html#a6d8dcd93a49b024688585d9e37a86a4e">empty</a>() ) {
<a name="l01661"></a>01661         <span class="keywordflow">if</span>( <a class="code" href="classldst__unit.html#af1db452f68f75bd831ece8eaceb41641">m_operand_collector</a>-&gt;<a class="code" href="classopndcoll__rfu__t.html#a28c5383a06f97b62df0a047a252661df">writeback</a>(<a class="code" href="classldst__unit.html#ac71d0e9348f6d668e796c97752516354">m_next_wb</a>) ) {
<a name="l01662"></a>01662             <span class="keywordtype">bool</span> insn_completed = <span class="keyword">false</span>; 
<a name="l01663"></a>01663             <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> r=0; r &lt; 4; r++ ) {
<a name="l01664"></a>01664                 <span class="keywordflow">if</span>( <a class="code" href="classldst__unit.html#ac71d0e9348f6d668e796c97752516354">m_next_wb</a>.<a class="code" href="classinst__t.html#a3c2c79e427a4d22fbf44264857a02c51">out</a>[r] &gt; 0 ) {
<a name="l01665"></a>01665                     <span class="keywordflow">if</span>( <a class="code" href="classldst__unit.html#ac71d0e9348f6d668e796c97752516354">m_next_wb</a>.<a class="code" href="classinst__t.html#a7830eb1cfe5a305e426d8530563c11da">space</a>.<a class="code" href="classmemory__space__t.html#a9aa8b2fabc2c16d1bfda090f27ab479c">get_type</a>() != <a class="code" href="abstract__hardware__model_8h.html#a1ad2169aaa8924fcc552447f38a5b58cae27eca92c2d1dbb9adb9010e3fb7991c">shared_space</a> ) {
<a name="l01666"></a>01666                         assert( <a class="code" href="classldst__unit.html#a1e13765c48144194fc28c0c218094ff2">m_pending_writes</a>[<a class="code" href="classldst__unit.html#ac71d0e9348f6d668e796c97752516354">m_next_wb</a>.<a class="code" href="classwarp__inst__t.html#ab1dd215e5b3d4083cdb473d4f8bf8bf2">warp_id</a>()][<a class="code" href="classldst__unit.html#ac71d0e9348f6d668e796c97752516354">m_next_wb</a>.<a class="code" href="classinst__t.html#a3c2c79e427a4d22fbf44264857a02c51">out</a>[r]] &gt; 0 );
<a name="l01667"></a>01667                         <span class="keywordtype">unsigned</span> still_pending = --<a class="code" href="classldst__unit.html#a1e13765c48144194fc28c0c218094ff2">m_pending_writes</a>[<a class="code" href="classldst__unit.html#ac71d0e9348f6d668e796c97752516354">m_next_wb</a>.<a class="code" href="classwarp__inst__t.html#ab1dd215e5b3d4083cdb473d4f8bf8bf2">warp_id</a>()][<a class="code" href="classldst__unit.html#ac71d0e9348f6d668e796c97752516354">m_next_wb</a>.<a class="code" href="classinst__t.html#a3c2c79e427a4d22fbf44264857a02c51">out</a>[r]];
<a name="l01668"></a>01668                         <span class="keywordflow">if</span>( !still_pending ) {
<a name="l01669"></a>01669                             <a class="code" href="classldst__unit.html#a1e13765c48144194fc28c0c218094ff2">m_pending_writes</a>[<a class="code" href="classldst__unit.html#ac71d0e9348f6d668e796c97752516354">m_next_wb</a>.<a class="code" href="classwarp__inst__t.html#ab1dd215e5b3d4083cdb473d4f8bf8bf2">warp_id</a>()].erase(<a class="code" href="classldst__unit.html#ac71d0e9348f6d668e796c97752516354">m_next_wb</a>.<a class="code" href="classinst__t.html#a3c2c79e427a4d22fbf44264857a02c51">out</a>[r]);
<a name="l01670"></a>01670                             <a class="code" href="classldst__unit.html#ad09290c55345d4406f8c6d67de3f9904">m_scoreboard</a>-&gt;<a class="code" href="classScoreboard.html#a2712367eae9852d612b097885cfb4e5c">releaseRegister</a>( <a class="code" href="classldst__unit.html#ac71d0e9348f6d668e796c97752516354">m_next_wb</a>.<a class="code" href="classwarp__inst__t.html#ab1dd215e5b3d4083cdb473d4f8bf8bf2">warp_id</a>(), <a class="code" href="classldst__unit.html#ac71d0e9348f6d668e796c97752516354">m_next_wb</a>.<a class="code" href="classinst__t.html#a3c2c79e427a4d22fbf44264857a02c51">out</a>[r] );
<a name="l01671"></a>01671                             insn_completed = <span class="keyword">true</span>; 
<a name="l01672"></a>01672                         }
<a name="l01673"></a>01673                     } <span class="keywordflow">else</span> { <span class="comment">// shared </span>
<a name="l01674"></a>01674                         <a class="code" href="classldst__unit.html#ad09290c55345d4406f8c6d67de3f9904">m_scoreboard</a>-&gt;<a class="code" href="classScoreboard.html#a2712367eae9852d612b097885cfb4e5c">releaseRegister</a>( <a class="code" href="classldst__unit.html#ac71d0e9348f6d668e796c97752516354">m_next_wb</a>.<a class="code" href="classwarp__inst__t.html#ab1dd215e5b3d4083cdb473d4f8bf8bf2">warp_id</a>(), <a class="code" href="classldst__unit.html#ac71d0e9348f6d668e796c97752516354">m_next_wb</a>.<a class="code" href="classinst__t.html#a3c2c79e427a4d22fbf44264857a02c51">out</a>[r] );
<a name="l01675"></a>01675                         insn_completed = <span class="keyword">true</span>; 
<a name="l01676"></a>01676                     }
<a name="l01677"></a>01677                 }
<a name="l01678"></a>01678             }
<a name="l01679"></a>01679             <span class="keywordflow">if</span>( insn_completed ) {
<a name="l01680"></a>01680                 <a class="code" href="classldst__unit.html#abedcc8e0b874a44d980819880c5b436c">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#a95c27fe36f8f1384340e671c964fce56">warp_inst_complete</a>(<a class="code" href="classldst__unit.html#ac71d0e9348f6d668e796c97752516354">m_next_wb</a>);
<a name="l01681"></a>01681             }
<a name="l01682"></a>01682             <a class="code" href="classldst__unit.html#ac71d0e9348f6d668e796c97752516354">m_next_wb</a>.<a class="code" href="classwarp__inst__t.html#a4ec50b2b803104315d11fb6eb8ad926f">clear</a>();
<a name="l01683"></a>01683             <a class="code" href="classldst__unit.html#aff0e2865331fd8bec6c96061958a0c20">m_last_inst_gpu_sim_cycle</a> = <a class="code" href="gpu-sim_8cc.html#a659fec271553d05e676c52314c8fcfe1">gpu_sim_cycle</a>;
<a name="l01684"></a>01684             <a class="code" href="classldst__unit.html#a358b1600ef78f0f9657e391afc19fa2b">m_last_inst_gpu_tot_sim_cycle</a> = <a class="code" href="gpu-sim_8cc.html#acef6bbfd6ec09fe29e2641cace785058">gpu_tot_sim_cycle</a>;
<a name="l01685"></a>01685         }
<a name="l01686"></a>01686     }
<a name="l01687"></a>01687 
<a name="l01688"></a>01688     <span class="keywordtype">unsigned</span> serviced_client = -1; 
<a name="l01689"></a>01689     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> c = 0; <a class="code" href="classldst__unit.html#ac71d0e9348f6d668e796c97752516354">m_next_wb</a>.<a class="code" href="classwarp__inst__t.html#a6d8dcd93a49b024688585d9e37a86a4e">empty</a>() &amp;&amp; (c &lt; <a class="code" href="classldst__unit.html#aabc95be7da543dfbc686299e9e4ac05a">m_num_writeback_clients</a>); c++ ) {
<a name="l01690"></a>01690         <span class="keywordtype">unsigned</span> next_client = (c+<a class="code" href="classldst__unit.html#a19d49ed4f150a81c52a65828b1d457ac">m_writeback_arb</a>)%<a class="code" href="classldst__unit.html#aabc95be7da543dfbc686299e9e4ac05a">m_num_writeback_clients</a>;
<a name="l01691"></a>01691         <span class="keywordflow">switch</span>( next_client ) {
<a name="l01692"></a>01692         <span class="keywordflow">case</span> 0: <span class="comment">// shared memory </span>
<a name="l01693"></a>01693             <span class="keywordflow">if</span>( !<a class="code" href="classpipelined__simd__unit.html#afffbdc979fcae64032976300a7787a13">m_pipeline_reg</a>[0]-&gt;empty() ) {
<a name="l01694"></a>01694                 <a class="code" href="classldst__unit.html#ac71d0e9348f6d668e796c97752516354">m_next_wb</a> = *<a class="code" href="classpipelined__simd__unit.html#afffbdc979fcae64032976300a7787a13">m_pipeline_reg</a>[0];
<a name="l01695"></a>01695                 <span class="keywordflow">if</span>(<a class="code" href="classldst__unit.html#ac71d0e9348f6d668e796c97752516354">m_next_wb</a>.<a class="code" href="classwarp__inst__t.html#ad5046e7f41d1188cf9428d160b3ead73">isatomic</a>()) {
<a name="l01696"></a>01696                     <a class="code" href="classldst__unit.html#ac71d0e9348f6d668e796c97752516354">m_next_wb</a>.<a class="code" href="classwarp__inst__t.html#a4975bed2e5b0ce4805738b89497bc1fc">do_atomic</a>();
<a name="l01697"></a>01697                     <a class="code" href="classldst__unit.html#abedcc8e0b874a44d980819880c5b436c">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#a1c9b68750d113e22f23e52b80911b080">decrement_atomic_count</a>(<a class="code" href="classldst__unit.html#ac71d0e9348f6d668e796c97752516354">m_next_wb</a>.<a class="code" href="classwarp__inst__t.html#ab1dd215e5b3d4083cdb473d4f8bf8bf2">warp_id</a>(), <a class="code" href="classldst__unit.html#ac71d0e9348f6d668e796c97752516354">m_next_wb</a>.<a class="code" href="classwarp__inst__t.html#ae2478f41ed1d4ce60ceec0fa5a85623a">active_count</a>());
<a name="l01698"></a>01698                 }
<a name="l01699"></a>01699                 <a class="code" href="classldst__unit.html#abedcc8e0b874a44d980819880c5b436c">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#a6ca2cebde9703a40c0de6a74923ebb77">dec_inst_in_pipeline</a>(<a class="code" href="classpipelined__simd__unit.html#afffbdc979fcae64032976300a7787a13">m_pipeline_reg</a>[0]-&gt;warp_id());
<a name="l01700"></a>01700                 <a class="code" href="classpipelined__simd__unit.html#afffbdc979fcae64032976300a7787a13">m_pipeline_reg</a>[0]-&gt;<a class="code" href="classwarp__inst__t.html#a4ec50b2b803104315d11fb6eb8ad926f">clear</a>();
<a name="l01701"></a>01701                 serviced_client = next_client; 
<a name="l01702"></a>01702             }
<a name="l01703"></a>01703             <span class="keywordflow">break</span>;
<a name="l01704"></a>01704         <span class="keywordflow">case</span> 1: <span class="comment">// texture response</span>
<a name="l01705"></a>01705             <span class="keywordflow">if</span>( <a class="code" href="classldst__unit.html#aac01b4330f6596459192bbe09b7aba8f">m_L1T</a>-&gt;<a class="code" href="classtex__cache.html#a69c5cf911a631676132443e0455dd175" title="Are any (accepted) accesses that had to wait for memory now ready? (does not include...">access_ready</a>() ) {
<a name="l01706"></a>01706                 <a class="code" href="classmem__fetch.html">mem_fetch</a> *mf = <a class="code" href="classldst__unit.html#aac01b4330f6596459192bbe09b7aba8f">m_L1T</a>-&gt;<a class="code" href="classtex__cache.html#a6741db6992f6fa5ba547cb056ca1e054" title="Pop next ready access (includes both accesses that &amp;quot;HIT&amp;quot; and those that...">next_access</a>();
<a name="l01707"></a>01707                 <a class="code" href="classldst__unit.html#ac71d0e9348f6d668e796c97752516354">m_next_wb</a> = mf-&gt;<a class="code" href="classmem__fetch.html#aa7d5e3d25eaa0c32d960d7ededfddc4e">get_inst</a>();
<a name="l01708"></a>01708                 <span class="keyword">delete</span> mf;
<a name="l01709"></a>01709                 serviced_client = next_client; 
<a name="l01710"></a>01710             }
<a name="l01711"></a>01711             <span class="keywordflow">break</span>;
<a name="l01712"></a>01712         <span class="keywordflow">case</span> 2: <span class="comment">// const cache response</span>
<a name="l01713"></a>01713             <span class="keywordflow">if</span>( <a class="code" href="classldst__unit.html#a22126652fa2f4b074e54065fc1bf0e73">m_L1C</a>-&gt;<a class="code" href="classbaseline__cache.html#a35718e662874edff48a21967e79d5f4e" title="Are any (accepted) accesses that had to wait for memory now ready? (does not include...">access_ready</a>() ) {
<a name="l01714"></a>01714                 <a class="code" href="classmem__fetch.html">mem_fetch</a> *mf = <a class="code" href="classldst__unit.html#a22126652fa2f4b074e54065fc1bf0e73">m_L1C</a>-&gt;<a class="code" href="classbaseline__cache.html#a2130cc5c06e1642d3a5ab1ec77e54446" title="Pop next ready access (does not include accesses that &amp;quot;HIT&amp;quot;).">next_access</a>();
<a name="l01715"></a>01715                 <a class="code" href="classldst__unit.html#ac71d0e9348f6d668e796c97752516354">m_next_wb</a> = mf-&gt;<a class="code" href="classmem__fetch.html#aa7d5e3d25eaa0c32d960d7ededfddc4e">get_inst</a>();
<a name="l01716"></a>01716                 <span class="keyword">delete</span> mf;
<a name="l01717"></a>01717                 serviced_client = next_client; 
<a name="l01718"></a>01718             }
<a name="l01719"></a>01719             <span class="keywordflow">break</span>;
<a name="l01720"></a>01720         <span class="keywordflow">case</span> 3: <span class="comment">// global/local</span>
<a name="l01721"></a>01721             <span class="keywordflow">if</span>( <a class="code" href="classldst__unit.html#ac071341d8cadf33b9596437d22a40730">m_next_global</a> ) {
<a name="l01722"></a>01722                 <a class="code" href="classldst__unit.html#ac71d0e9348f6d668e796c97752516354">m_next_wb</a> = <a class="code" href="classldst__unit.html#ac071341d8cadf33b9596437d22a40730">m_next_global</a>-&gt;<a class="code" href="classmem__fetch.html#aa7d5e3d25eaa0c32d960d7ededfddc4e">get_inst</a>();
<a name="l01723"></a>01723                 <span class="keywordflow">if</span>( <a class="code" href="classldst__unit.html#ac071341d8cadf33b9596437d22a40730">m_next_global</a>-&gt;<a class="code" href="classmem__fetch.html#aa5bcee879d65fa5954c35a05a50e7f5e">isatomic</a>() ) 
<a name="l01724"></a>01724                     <a class="code" href="classldst__unit.html#abedcc8e0b874a44d980819880c5b436c">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#a1c9b68750d113e22f23e52b80911b080">decrement_atomic_count</a>(<a class="code" href="classldst__unit.html#ac071341d8cadf33b9596437d22a40730">m_next_global</a>-&gt;<a class="code" href="classmem__fetch.html#aa9e3a06ff563324393980d3d78bdba11">get_wid</a>(),<a class="code" href="classldst__unit.html#ac071341d8cadf33b9596437d22a40730">m_next_global</a>-&gt;<a class="code" href="classmem__fetch.html#aa8d9c4169371f2b1c66301789b8b1cd8">get_access_warp_mask</a>().count());
<a name="l01725"></a>01725                 <span class="keyword">delete</span> <a class="code" href="classldst__unit.html#ac071341d8cadf33b9596437d22a40730">m_next_global</a>;
<a name="l01726"></a>01726                 <a class="code" href="classldst__unit.html#ac071341d8cadf33b9596437d22a40730">m_next_global</a> = NULL;
<a name="l01727"></a>01727                 serviced_client = next_client; 
<a name="l01728"></a>01728             }
<a name="l01729"></a>01729             <span class="keywordflow">break</span>;
<a name="l01730"></a>01730         <span class="keywordflow">case</span> 4: 
<a name="l01731"></a>01731             <span class="keywordflow">if</span>( <a class="code" href="classldst__unit.html#ac96de3512e64b5526049ede4d3aef42c">m_L1D</a> &amp;&amp; <a class="code" href="classldst__unit.html#ac96de3512e64b5526049ede4d3aef42c">m_L1D</a>-&gt;<a class="code" href="classbaseline__cache.html#a35718e662874edff48a21967e79d5f4e" title="Are any (accepted) accesses that had to wait for memory now ready? (does not include...">access_ready</a>() ) {
<a name="l01732"></a>01732                 <a class="code" href="classmem__fetch.html">mem_fetch</a> *mf = <a class="code" href="classldst__unit.html#ac96de3512e64b5526049ede4d3aef42c">m_L1D</a>-&gt;<a class="code" href="classbaseline__cache.html#a2130cc5c06e1642d3a5ab1ec77e54446" title="Pop next ready access (does not include accesses that &amp;quot;HIT&amp;quot;).">next_access</a>();
<a name="l01733"></a>01733                 <a class="code" href="classldst__unit.html#ac71d0e9348f6d668e796c97752516354">m_next_wb</a> = mf-&gt;<a class="code" href="classmem__fetch.html#aa7d5e3d25eaa0c32d960d7ededfddc4e">get_inst</a>();
<a name="l01734"></a>01734                 <span class="keyword">delete</span> mf;
<a name="l01735"></a>01735                 serviced_client = next_client; 
<a name="l01736"></a>01736             }
<a name="l01737"></a>01737             <span class="keywordflow">break</span>;
<a name="l01738"></a>01738         <span class="keywordflow">default</span>: abort();
<a name="l01739"></a>01739         }
<a name="l01740"></a>01740     }
<a name="l01741"></a>01741     <span class="comment">// update arbitration priority only if: </span>
<a name="l01742"></a>01742     <span class="comment">// 1. the writeback buffer was available </span>
<a name="l01743"></a>01743     <span class="comment">// 2. a client was serviced </span>
<a name="l01744"></a>01744     <span class="keywordflow">if</span> (serviced_client != (<span class="keywordtype">unsigned</span>)-1) {
<a name="l01745"></a>01745         <a class="code" href="classldst__unit.html#a19d49ed4f150a81c52a65828b1d457ac">m_writeback_arb</a> = (serviced_client + 1) % <a class="code" href="classldst__unit.html#aabc95be7da543dfbc686299e9e4ac05a">m_num_writeback_clients</a>; 
<a name="l01746"></a>01746     }
<a name="l01747"></a>01747 }
<a name="l01748"></a>01748 
<a name="l01749"></a><a class="code" href="classldst__unit.html#a816b8cb28f9801faca76ae50dc02ce67">01749</a> <span class="keywordtype">unsigned</span> <a class="code" href="classldst__unit.html#a816b8cb28f9801faca76ae50dc02ce67">ldst_unit::clock_multiplier</a>()<span class="keyword"> const</span>
<a name="l01750"></a>01750 <span class="keyword"></span>{ 
<a name="l01751"></a>01751     <span class="keywordflow">return</span> <a class="code" href="classsimd__function__unit.html#a398a2a0d2e52ca4beb15ef5e9ccb4c61">m_config</a>-&gt;<a class="code" href="structcore__config.html#a51c9f7f1e6339b28812ea86f46be189e">mem_warp_parts</a>; 
<a name="l01752"></a>01752 }
<a name="l01753"></a>01753 <span class="comment">/*</span>
<a name="l01754"></a>01754 <span class="comment">void ldst_unit::issue( register_set &amp;reg_set )</span>
<a name="l01755"></a>01755 <span class="comment">{</span>
<a name="l01756"></a>01756 <span class="comment">    warp_inst_t* inst = *(reg_set.get_ready());</span>
<a name="l01757"></a>01757 <span class="comment">   // stat collection</span>
<a name="l01758"></a>01758 <span class="comment">   m_core-&gt;mem_instruction_stats(*inst); </span>
<a name="l01759"></a>01759 <span class="comment"></span>
<a name="l01760"></a>01760 <span class="comment">   // record how many pending register writes/memory accesses there are for this instruction </span>
<a name="l01761"></a>01761 <span class="comment">   assert(inst-&gt;empty() == false); </span>
<a name="l01762"></a>01762 <span class="comment">   if (inst-&gt;is_load() and inst-&gt;space.get_type() != shared_space) {</span>
<a name="l01763"></a>01763 <span class="comment">      unsigned warp_id = inst-&gt;warp_id(); </span>
<a name="l01764"></a>01764 <span class="comment">      unsigned n_accesses = inst-&gt;accessq_count(); </span>
<a name="l01765"></a>01765 <span class="comment">      for (unsigned r = 0; r &lt; 4; r++) {</span>
<a name="l01766"></a>01766 <span class="comment">         unsigned reg_id = inst-&gt;out[r]; </span>
<a name="l01767"></a>01767 <span class="comment">         if (reg_id &gt; 0) {</span>
<a name="l01768"></a>01768 <span class="comment">            m_pending_writes[warp_id][reg_id] += n_accesses; </span>
<a name="l01769"></a>01769 <span class="comment">         }</span>
<a name="l01770"></a>01770 <span class="comment">      }</span>
<a name="l01771"></a>01771 <span class="comment">   }</span>
<a name="l01772"></a>01772 <span class="comment"></span>
<a name="l01773"></a>01773 <span class="comment">   pipelined_simd_unit::issue(reg_set);</span>
<a name="l01774"></a>01774 <span class="comment">}</span>
<a name="l01775"></a>01775 <span class="comment">*/</span>
<a name="l01776"></a><a class="code" href="classldst__unit.html#a2dba217d5edf6c9c4eb0b5d40dba666f">01776</a> <span class="keywordtype">void</span> <a class="code" href="classldst__unit.html#a2dba217d5edf6c9c4eb0b5d40dba666f">ldst_unit::cycle</a>()
<a name="l01777"></a>01777 {
<a name="l01778"></a>01778    <a class="code" href="classldst__unit.html#a8c51837eac2823aa53eda252f088e07e">writeback</a>();
<a name="l01779"></a>01779    <a class="code" href="classldst__unit.html#af1db452f68f75bd831ece8eaceb41641">m_operand_collector</a>-&gt;<a class="code" href="classopndcoll__rfu__t.html#a531f0d6210b8c1f3ede39c5120b2d4ec">step</a>();
<a name="l01780"></a>01780    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> stage=0; (stage+1)&lt;<a class="code" href="classpipelined__simd__unit.html#a369e75de3c10c9a710f96965450ef2eb">m_pipeline_depth</a>; stage++ ) 
<a name="l01781"></a>01781        <span class="keywordflow">if</span>( <a class="code" href="classpipelined__simd__unit.html#afffbdc979fcae64032976300a7787a13">m_pipeline_reg</a>[stage]-&gt;empty() &amp;&amp; !<a class="code" href="classpipelined__simd__unit.html#afffbdc979fcae64032976300a7787a13">m_pipeline_reg</a>[stage+1]-&gt;<a class="code" href="classwarp__inst__t.html#a6d8dcd93a49b024688585d9e37a86a4e">empty</a>() )
<a name="l01782"></a>01782             <a class="code" href="abstract__hardware__model_8cc.html#abf4893100752eaa8370602c0a6373c82">move_warp</a>(<a class="code" href="classpipelined__simd__unit.html#afffbdc979fcae64032976300a7787a13">m_pipeline_reg</a>[stage], <a class="code" href="classpipelined__simd__unit.html#afffbdc979fcae64032976300a7787a13">m_pipeline_reg</a>[stage+1]);
<a name="l01783"></a>01783 
<a name="l01784"></a>01784    <span class="keywordflow">if</span>( !<a class="code" href="classldst__unit.html#a56ec0edb13afbb6454646012bbda37e2">m_response_fifo</a>.empty() ) {
<a name="l01785"></a>01785        <a class="code" href="classmem__fetch.html">mem_fetch</a> *mf = <a class="code" href="classldst__unit.html#a56ec0edb13afbb6454646012bbda37e2">m_response_fifo</a>.front();
<a name="l01786"></a>01786        <span class="keywordflow">if</span> (mf-&gt;<a class="code" href="classmem__fetch.html#a361e4e41a80bff3acac726d8693a9fee">istexture</a>()) {
<a name="l01787"></a>01787            <span class="keywordflow">if</span> (<a class="code" href="classldst__unit.html#aac01b4330f6596459192bbe09b7aba8f">m_L1T</a>-&gt;<a class="code" href="classtex__cache.html#a6c229b7e01e89900b5d91447c0c513b8">fill_port_free</a>()) {
<a name="l01788"></a>01788                <a class="code" href="classldst__unit.html#aac01b4330f6596459192bbe09b7aba8f">m_L1T</a>-&gt;<a class="code" href="classtex__cache.html#aac962ff18844f87d519c3a29a600dde9" title="Place returning cache block into reorder buffer.">fill</a>(mf,<a class="code" href="gpu-sim_8cc.html#a659fec271553d05e676c52314c8fcfe1">gpu_sim_cycle</a>+<a class="code" href="gpu-sim_8cc.html#acef6bbfd6ec09fe29e2641cace785058">gpu_tot_sim_cycle</a>);
<a name="l01789"></a>01789                <a class="code" href="classldst__unit.html#a56ec0edb13afbb6454646012bbda37e2">m_response_fifo</a>.pop_front(); 
<a name="l01790"></a>01790            }
<a name="l01791"></a>01791        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mf-&gt;<a class="code" href="classmem__fetch.html#a48aa68a8765af566566d0a95d91ceccf">isconst</a>())  {
<a name="l01792"></a>01792            <span class="keywordflow">if</span> (<a class="code" href="classldst__unit.html#a22126652fa2f4b074e54065fc1bf0e73">m_L1C</a>-&gt;<a class="code" href="classbaseline__cache.html#a88390b0ee869380c1d1aab31a7f1c93e">fill_port_free</a>()) {
<a name="l01793"></a>01793                mf-&gt;<a class="code" href="classmem__fetch.html#acbda50764b3c8d6f79ffa279021253da">set_status</a>(IN_SHADER_FETCHED,<a class="code" href="gpu-sim_8cc.html#a659fec271553d05e676c52314c8fcfe1">gpu_sim_cycle</a>+<a class="code" href="gpu-sim_8cc.html#acef6bbfd6ec09fe29e2641cace785058">gpu_tot_sim_cycle</a>);
<a name="l01794"></a>01794                <a class="code" href="classldst__unit.html#a22126652fa2f4b074e54065fc1bf0e73">m_L1C</a>-&gt;<a class="code" href="classbaseline__cache.html#aa797b46275001da9451a5ce16f815569" title="Interface for response from lower memory level (model bandwidth restictions in caller)...">fill</a>(mf,<a class="code" href="gpu-sim_8cc.html#a659fec271553d05e676c52314c8fcfe1">gpu_sim_cycle</a>+<a class="code" href="gpu-sim_8cc.html#acef6bbfd6ec09fe29e2641cace785058">gpu_tot_sim_cycle</a>);
<a name="l01795"></a>01795                <a class="code" href="classldst__unit.html#a56ec0edb13afbb6454646012bbda37e2">m_response_fifo</a>.pop_front(); 
<a name="l01796"></a>01796            }
<a name="l01797"></a>01797        } <span class="keywordflow">else</span> {
<a name="l01798"></a>01798            <span class="keywordflow">if</span>( mf-&gt;<a class="code" href="classmem__fetch.html#a1b66843ccce20aaf75b53c91f2d7ad61">get_type</a>() == <a class="code" href="mem__fetch_8h.html#a5830ce559c805683000f5d82d6f0a234a84df0ac61ee4b6f007ec6373ed8b3223">WRITE_ACK</a> || ( <a class="code" href="classsimd__function__unit.html#a398a2a0d2e52ca4beb15ef5e9ccb4c61">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#abe1f48d1bf3b8b7ec3531f957e15bbe1">gpgpu_perfect_mem</a> &amp;&amp; mf-&gt;<a class="code" href="classmem__fetch.html#a0e449bde79c7162ec62c433338ac0293">get_is_write</a>() )) {
<a name="l01799"></a>01799                <a class="code" href="classldst__unit.html#abedcc8e0b874a44d980819880c5b436c">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#a6ec3f76dc2811675296ad24bf6d77667">store_ack</a>(mf);
<a name="l01800"></a>01800                <a class="code" href="classldst__unit.html#a56ec0edb13afbb6454646012bbda37e2">m_response_fifo</a>.pop_front();
<a name="l01801"></a>01801                <span class="keyword">delete</span> mf;
<a name="l01802"></a>01802            } <span class="keywordflow">else</span> {
<a name="l01803"></a>01803                assert( !mf-&gt;<a class="code" href="classmem__fetch.html#a0e449bde79c7162ec62c433338ac0293">get_is_write</a>() ); <span class="comment">// L1 cache is write evict, allocate line on load miss only</span>
<a name="l01804"></a>01804 
<a name="l01805"></a>01805                <span class="keywordtype">bool</span> bypassL1D = <span class="keyword">false</span>; 
<a name="l01806"></a>01806                <span class="keywordflow">if</span> ( <a class="code" href="abstract__hardware__model_8h.html#ab204345d04c216e6d47f2f19501d7072a652584484432dcd6c7a2a620a2ee44cf">CACHE_GLOBAL</a> == mf-&gt;<a class="code" href="classmem__fetch.html#aa7d5e3d25eaa0c32d960d7ededfddc4e">get_inst</a>().<a class="code" href="classinst__t.html#a329da97dfe6b0972748e988793b1d684">cache_op</a> || (<a class="code" href="classldst__unit.html#ac96de3512e64b5526049ede4d3aef42c">m_L1D</a> == NULL) ) {
<a name="l01807"></a>01807                    bypassL1D = <span class="keyword">true</span>; 
<a name="l01808"></a>01808                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mf-&gt;<a class="code" href="classmem__fetch.html#ad6d11b27562271b7e6a99c76005021b1">get_access_type</a>() == GLOBAL_ACC_R || mf-&gt;<a class="code" href="classmem__fetch.html#ad6d11b27562271b7e6a99c76005021b1">get_access_type</a>() == GLOBAL_ACC_W) { <span class="comment">// global memory access </span>
<a name="l01809"></a>01809                    <span class="keywordflow">if</span> (<a class="code" href="classldst__unit.html#abedcc8e0b874a44d980819880c5b436c">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#a0dfa04be25f749a0a690843a13db0881">get_config</a>()-&gt;<a class="code" href="structshader__core__config.html#a0807f53693e797a1195a3a4c70e02b8b">gmem_skip_L1D</a>)
<a name="l01810"></a>01810                        bypassL1D = <span class="keyword">true</span>; 
<a name="l01811"></a>01811                }
<a name="l01812"></a>01812                <span class="keywordflow">if</span>( bypassL1D ) {
<a name="l01813"></a>01813                    <span class="keywordflow">if</span> ( <a class="code" href="classldst__unit.html#ac071341d8cadf33b9596437d22a40730">m_next_global</a> == NULL ) {
<a name="l01814"></a>01814                        mf-&gt;<a class="code" href="classmem__fetch.html#acbda50764b3c8d6f79ffa279021253da">set_status</a>(IN_SHADER_FETCHED,<a class="code" href="gpu-sim_8cc.html#a659fec271553d05e676c52314c8fcfe1">gpu_sim_cycle</a>+<a class="code" href="gpu-sim_8cc.html#acef6bbfd6ec09fe29e2641cace785058">gpu_tot_sim_cycle</a>);
<a name="l01815"></a>01815                        <a class="code" href="classldst__unit.html#a56ec0edb13afbb6454646012bbda37e2">m_response_fifo</a>.pop_front();
<a name="l01816"></a>01816                        <a class="code" href="classldst__unit.html#ac071341d8cadf33b9596437d22a40730">m_next_global</a> = mf;
<a name="l01817"></a>01817                    }
<a name="l01818"></a>01818                } <span class="keywordflow">else</span> {
<a name="l01819"></a>01819                    <span class="keywordflow">if</span> (<a class="code" href="classldst__unit.html#ac96de3512e64b5526049ede4d3aef42c">m_L1D</a>-&gt;<a class="code" href="classbaseline__cache.html#a88390b0ee869380c1d1aab31a7f1c93e">fill_port_free</a>()) {
<a name="l01820"></a>01820                        <a class="code" href="classldst__unit.html#ac96de3512e64b5526049ede4d3aef42c">m_L1D</a>-&gt;<a class="code" href="classbaseline__cache.html#aa797b46275001da9451a5ce16f815569" title="Interface for response from lower memory level (model bandwidth restictions in caller)...">fill</a>(mf,<a class="code" href="gpu-sim_8cc.html#a659fec271553d05e676c52314c8fcfe1">gpu_sim_cycle</a>+<a class="code" href="gpu-sim_8cc.html#acef6bbfd6ec09fe29e2641cace785058">gpu_tot_sim_cycle</a>);
<a name="l01821"></a>01821                        <a class="code" href="classldst__unit.html#a56ec0edb13afbb6454646012bbda37e2">m_response_fifo</a>.pop_front();
<a name="l01822"></a>01822                    }
<a name="l01823"></a>01823                }
<a name="l01824"></a>01824            }
<a name="l01825"></a>01825        }
<a name="l01826"></a>01826    }
<a name="l01827"></a>01827 
<a name="l01828"></a>01828    <a class="code" href="classldst__unit.html#aac01b4330f6596459192bbe09b7aba8f">m_L1T</a>-&gt;<a class="code" href="classtex__cache.html#a1aefd101ea71dc38a053d80087b93e13">cycle</a>();
<a name="l01829"></a>01829    <a class="code" href="classldst__unit.html#a22126652fa2f4b074e54065fc1bf0e73">m_L1C</a>-&gt;<a class="code" href="classbaseline__cache.html#a0622c3b477d40f97b694dd5d76de23cd" title="Sends next request to lower level of memory.">cycle</a>();
<a name="l01830"></a>01830    <span class="keywordflow">if</span>( <a class="code" href="classldst__unit.html#ac96de3512e64b5526049ede4d3aef42c">m_L1D</a> ) <a class="code" href="classldst__unit.html#ac96de3512e64b5526049ede4d3aef42c">m_L1D</a>-&gt;<a class="code" href="classbaseline__cache.html#a0622c3b477d40f97b694dd5d76de23cd" title="Sends next request to lower level of memory.">cycle</a>();
<a name="l01831"></a>01831 
<a name="l01832"></a>01832    <a class="code" href="classwarp__inst__t.html">warp_inst_t</a> &amp;pipe_reg = *<a class="code" href="classsimd__function__unit.html#ae55a510a8ce9e0ee2dc1d8a66578e5f2">m_dispatch_reg</a>;
<a name="l01833"></a>01833    <span class="keyword">enum</span> <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7">mem_stage_stall_type</a> rc_fail = <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7a038f41ff0d19fa8e4741dde172051053">NO_RC_FAIL</a>;
<a name="l01834"></a>01834    <a class="code" href="stats_8h.html#abaa2b40c00669d11d761bdce71d15d6b">mem_stage_access_type</a> type;
<a name="l01835"></a>01835    <span class="keywordtype">bool</span> done = <span class="keyword">true</span>;
<a name="l01836"></a>01836    done &amp;= <a class="code" href="classldst__unit.html#a7e0763b5571f5044b519ffaea5c29cec">shared_cycle</a>(pipe_reg, rc_fail, type);
<a name="l01837"></a>01837    done &amp;= <a class="code" href="classldst__unit.html#ab8946433d44a095c4d2aa210df0d3478">constant_cycle</a>(pipe_reg, rc_fail, type);
<a name="l01838"></a>01838    done &amp;= <a class="code" href="classldst__unit.html#acfa393f589a4033ffd8b230676a01684">texture_cycle</a>(pipe_reg, rc_fail, type);
<a name="l01839"></a>01839    done &amp;= <a class="code" href="classldst__unit.html#afdc184c09232a71eb2640d8257018713">memory_cycle</a>(pipe_reg, rc_fail, type);
<a name="l01840"></a>01840    <a class="code" href="classldst__unit.html#ae89492e94d8bba86f04558b35f5ba834">m_mem_rc</a> = rc_fail;
<a name="l01841"></a>01841 
<a name="l01842"></a>01842    <span class="keywordflow">if</span> (!done) { <span class="comment">// log stall types and return</span>
<a name="l01843"></a>01843       assert(rc_fail != <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7a038f41ff0d19fa8e4741dde172051053">NO_RC_FAIL</a>);
<a name="l01844"></a>01844       <a class="code" href="classldst__unit.html#aaf741f3f1b4ccc7b9fb071d674b7d6c4">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a932af1c7f7b0e3c8dc49f89fab80bc80">gpgpu_n_stall_shd_mem</a>++;
<a name="l01845"></a>01845       <a class="code" href="classldst__unit.html#aaf741f3f1b4ccc7b9fb071d674b7d6c4">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a0b4183d757f5101324e27f6e2699519d">gpu_stall_shd_mem_breakdown</a>[type][rc_fail]++;
<a name="l01846"></a>01846       <span class="keywordflow">return</span>;
<a name="l01847"></a>01847    }
<a name="l01848"></a>01848 
<a name="l01849"></a>01849    <span class="keywordflow">if</span>( !pipe_reg.<a class="code" href="classwarp__inst__t.html#a6d8dcd93a49b024688585d9e37a86a4e">empty</a>() ) {
<a name="l01850"></a>01850        <span class="keywordtype">unsigned</span> warp_id = pipe_reg.<a class="code" href="classwarp__inst__t.html#ab1dd215e5b3d4083cdb473d4f8bf8bf2">warp_id</a>();
<a name="l01851"></a>01851        <span class="keywordflow">if</span>( pipe_reg.<a class="code" href="classinst__t.html#a2a7f0ff5bdc4a059f744487d2cf255bd">is_load</a>() ) {
<a name="l01852"></a>01852            <span class="keywordflow">if</span>( pipe_reg.<a class="code" href="classinst__t.html#a7830eb1cfe5a305e426d8530563c11da">space</a>.<a class="code" href="classmemory__space__t.html#a9aa8b2fabc2c16d1bfda090f27ab479c">get_type</a>() == <a class="code" href="abstract__hardware__model_8h.html#a1ad2169aaa8924fcc552447f38a5b58cae27eca92c2d1dbb9adb9010e3fb7991c">shared_space</a> ) {
<a name="l01853"></a>01853                <span class="keywordflow">if</span>( <a class="code" href="classpipelined__simd__unit.html#afffbdc979fcae64032976300a7787a13">m_pipeline_reg</a>[2]-&gt;empty() ) {
<a name="l01854"></a>01854                    <span class="comment">// new shared memory request</span>
<a name="l01855"></a>01855                    <a class="code" href="abstract__hardware__model_8cc.html#abf4893100752eaa8370602c0a6373c82">move_warp</a>(<a class="code" href="classpipelined__simd__unit.html#afffbdc979fcae64032976300a7787a13">m_pipeline_reg</a>[2],<a class="code" href="classsimd__function__unit.html#ae55a510a8ce9e0ee2dc1d8a66578e5f2">m_dispatch_reg</a>);
<a name="l01856"></a>01856                    <a class="code" href="classsimd__function__unit.html#ae55a510a8ce9e0ee2dc1d8a66578e5f2">m_dispatch_reg</a>-&gt;<a class="code" href="classwarp__inst__t.html#a4ec50b2b803104315d11fb6eb8ad926f">clear</a>();
<a name="l01857"></a>01857                }
<a name="l01858"></a>01858            } <span class="keywordflow">else</span> {
<a name="l01859"></a>01859                <span class="comment">//if( pipe_reg.active_count() &gt; 0 ) {</span>
<a name="l01860"></a>01860                <span class="comment">//    if( !m_operand_collector-&gt;writeback(pipe_reg) ) </span>
<a name="l01861"></a>01861                <span class="comment">//        return;</span>
<a name="l01862"></a>01862                <span class="comment">//} </span>
<a name="l01863"></a>01863 
<a name="l01864"></a>01864                <span class="keywordtype">bool</span> pending_requests=<span class="keyword">false</span>;
<a name="l01865"></a>01865                <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> r=0; r&lt;4; r++ ) {
<a name="l01866"></a>01866                    <span class="keywordtype">unsigned</span> reg_id = pipe_reg.<a class="code" href="classinst__t.html#a3c2c79e427a4d22fbf44264857a02c51">out</a>[r];
<a name="l01867"></a>01867                    <span class="keywordflow">if</span>( reg_id &gt; 0 ) {
<a name="l01868"></a>01868                        <span class="keywordflow">if</span>( <a class="code" href="classldst__unit.html#a1e13765c48144194fc28c0c218094ff2">m_pending_writes</a>[warp_id].find(reg_id) != <a class="code" href="classldst__unit.html#a1e13765c48144194fc28c0c218094ff2">m_pending_writes</a>[warp_id].end() ) {
<a name="l01869"></a>01869                            <span class="keywordflow">if</span> ( <a class="code" href="classldst__unit.html#a1e13765c48144194fc28c0c218094ff2">m_pending_writes</a>[warp_id][reg_id] &gt; 0 ) {
<a name="l01870"></a>01870                                pending_requests=<span class="keyword">true</span>;
<a name="l01871"></a>01871                                <span class="keywordflow">break</span>;
<a name="l01872"></a>01872                            } <span class="keywordflow">else</span> {
<a name="l01873"></a>01873                                <span class="comment">// this instruction is done already</span>
<a name="l01874"></a>01874                                <a class="code" href="classldst__unit.html#a1e13765c48144194fc28c0c218094ff2">m_pending_writes</a>[warp_id].erase(reg_id); 
<a name="l01875"></a>01875                            }
<a name="l01876"></a>01876                        }
<a name="l01877"></a>01877                    }
<a name="l01878"></a>01878                }
<a name="l01879"></a>01879                <span class="keywordflow">if</span>( !pending_requests ) {
<a name="l01880"></a>01880                    <a class="code" href="classldst__unit.html#abedcc8e0b874a44d980819880c5b436c">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#a95c27fe36f8f1384340e671c964fce56">warp_inst_complete</a>(*<a class="code" href="classsimd__function__unit.html#ae55a510a8ce9e0ee2dc1d8a66578e5f2">m_dispatch_reg</a>);
<a name="l01881"></a>01881                    <a class="code" href="classldst__unit.html#ad09290c55345d4406f8c6d67de3f9904">m_scoreboard</a>-&gt;<a class="code" href="classScoreboard.html#a822dfe286637cded7828420921f48c91">releaseRegisters</a>(<a class="code" href="classsimd__function__unit.html#ae55a510a8ce9e0ee2dc1d8a66578e5f2">m_dispatch_reg</a>);
<a name="l01882"></a>01882                }
<a name="l01883"></a>01883                <a class="code" href="classldst__unit.html#abedcc8e0b874a44d980819880c5b436c">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#a6ca2cebde9703a40c0de6a74923ebb77">dec_inst_in_pipeline</a>(warp_id);
<a name="l01884"></a>01884                <a class="code" href="classsimd__function__unit.html#ae55a510a8ce9e0ee2dc1d8a66578e5f2">m_dispatch_reg</a>-&gt;<a class="code" href="classwarp__inst__t.html#a4ec50b2b803104315d11fb6eb8ad926f">clear</a>();
<a name="l01885"></a>01885            }
<a name="l01886"></a>01886        } <span class="keywordflow">else</span> {
<a name="l01887"></a>01887            <span class="comment">// stores exit pipeline here</span>
<a name="l01888"></a>01888            <a class="code" href="classldst__unit.html#abedcc8e0b874a44d980819880c5b436c">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#a6ca2cebde9703a40c0de6a74923ebb77">dec_inst_in_pipeline</a>(warp_id);
<a name="l01889"></a>01889            <a class="code" href="classldst__unit.html#abedcc8e0b874a44d980819880c5b436c">m_core</a>-&gt;<a class="code" href="classshader__core__ctx.html#a95c27fe36f8f1384340e671c964fce56">warp_inst_complete</a>(*<a class="code" href="classsimd__function__unit.html#ae55a510a8ce9e0ee2dc1d8a66578e5f2">m_dispatch_reg</a>);
<a name="l01890"></a>01890            <a class="code" href="classsimd__function__unit.html#ae55a510a8ce9e0ee2dc1d8a66578e5f2">m_dispatch_reg</a>-&gt;<a class="code" href="classwarp__inst__t.html#a4ec50b2b803104315d11fb6eb8ad926f">clear</a>();
<a name="l01891"></a>01891        }
<a name="l01892"></a>01892    }
<a name="l01893"></a>01893 }
<a name="l01894"></a>01894 
<a name="l01895"></a><a class="code" href="classshader__core__ctx.html#af12dcb274a9cd1001ef20f417c11e598">01895</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#af12dcb274a9cd1001ef20f417c11e598">shader_core_ctx::register_cta_thread_exit</a>( <span class="keywordtype">unsigned</span> cta_num )
<a name="l01896"></a>01896 {
<a name="l01897"></a>01897    assert( <a class="code" href="classshader__core__ctx.html#a0e6fc50e22a7c340b34556009f23de13">m_cta_status</a>[cta_num] &gt; 0 );
<a name="l01898"></a>01898    <a class="code" href="classshader__core__ctx.html#a0e6fc50e22a7c340b34556009f23de13">m_cta_status</a>[cta_num]--;
<a name="l01899"></a>01899    <span class="keywordflow">if</span> (!<a class="code" href="classshader__core__ctx.html#a0e6fc50e22a7c340b34556009f23de13">m_cta_status</a>[cta_num]) {
<a name="l01900"></a>01900       <a class="code" href="classshader__core__ctx.html#ababdc62e6b237cf2e3b2750138aef598">m_n_active_cta</a>--;
<a name="l01901"></a>01901       <a class="code" href="classshader__core__ctx.html#ad1128668e0cb4889bcb9d257710e6f42">m_barriers</a>.<a class="code" href="classbarrier__set__t.html#abb04291e7936dc009b0b885b1467951e">deallocate_barrier</a>(cta_num);
<a name="l01902"></a>01902       <a class="code" href="stat-tool_8cc.html#a82e00728825f6891dcaf8a43a4aceaf6">shader_CTA_count_unlog</a>(<a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>, 1);
<a name="l01903"></a>01903       printf(<span class="stringliteral">&quot;GPGPU-Sim uArch: Shader %d finished CTA #%d (%lld,%lld), %u CTAs running\n&quot;</span>, <a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>, cta_num, <a class="code" href="gpu-sim_8cc.html#a659fec271553d05e676c52314c8fcfe1">gpu_sim_cycle</a>, <a class="code" href="gpu-sim_8cc.html#acef6bbfd6ec09fe29e2641cace785058">gpu_tot_sim_cycle</a>,
<a name="l01904"></a>01904              <a class="code" href="classshader__core__ctx.html#ababdc62e6b237cf2e3b2750138aef598">m_n_active_cta</a> );
<a name="l01905"></a>01905       <span class="keywordflow">if</span>( <a class="code" href="classshader__core__ctx.html#ababdc62e6b237cf2e3b2750138aef598">m_n_active_cta</a> == 0 ) {
<a name="l01906"></a>01906           assert( <a class="code" href="classcore__t.html#a598c5ea555cb4d6f4b3c1253bf87425b">m_kernel</a> != NULL );
<a name="l01907"></a>01907           <a class="code" href="classcore__t.html#a598c5ea555cb4d6f4b3c1253bf87425b">m_kernel</a>-&gt;<a class="code" href="classkernel__info__t.html#a51e3396f433565269e7e63d2e8dfb379">dec_running</a>();
<a name="l01908"></a>01908           printf(<span class="stringliteral">&quot;GPGPU-Sim uArch: Shader %u empty (release kernel %u \&apos;%s\&apos;).\n&quot;</span>, <a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>, <a class="code" href="classcore__t.html#a598c5ea555cb4d6f4b3c1253bf87425b">m_kernel</a>-&gt;<a class="code" href="classkernel__info__t.html#a3ad6a7212d90fa5650eae466002b5607">get_uid</a>(),
<a name="l01909"></a>01909                  <a class="code" href="classcore__t.html#a598c5ea555cb4d6f4b3c1253bf87425b">m_kernel</a>-&gt;<a class="code" href="classkernel__info__t.html#aab01e70021fb02628523d80da58e37c6">name</a>().c_str() );
<a name="l01910"></a>01910           <span class="keywordflow">if</span>( <a class="code" href="classcore__t.html#a598c5ea555cb4d6f4b3c1253bf87425b">m_kernel</a>-&gt;<a class="code" href="classkernel__info__t.html#a245a21ded3eebcf3b400a875f2eced46">no_more_ctas_to_run</a>() ) {
<a name="l01911"></a>01911               <span class="keywordflow">if</span>( !<a class="code" href="classcore__t.html#a598c5ea555cb4d6f4b3c1253bf87425b">m_kernel</a>-&gt;<a class="code" href="classkernel__info__t.html#a507824a8e1e511fce48aa5d5bdf0094b">running</a>() ) {
<a name="l01912"></a>01912                   printf(<span class="stringliteral">&quot;GPGPU-Sim uArch: GPU detected kernel \&apos;%s\&apos; finished on shader %u.\n&quot;</span>, <a class="code" href="classcore__t.html#a598c5ea555cb4d6f4b3c1253bf87425b">m_kernel</a>-&gt;<a class="code" href="classkernel__info__t.html#aab01e70021fb02628523d80da58e37c6">name</a>().c_str(), <a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a> );
<a name="l01913"></a>01913                   <a class="code" href="classcore__t.html#a8c9d8ee79e128de6729806cdfa2c5301">m_gpu</a>-&gt;<a class="code" href="classgpgpu__sim.html#a6b6204e113964723b581bde478966358">set_kernel_done</a>( <a class="code" href="classcore__t.html#a598c5ea555cb4d6f4b3c1253bf87425b">m_kernel</a> );
<a name="l01914"></a>01914               }
<a name="l01915"></a>01915           }
<a name="l01916"></a>01916           <a class="code" href="classcore__t.html#a598c5ea555cb4d6f4b3c1253bf87425b">m_kernel</a>=NULL;
<a name="l01917"></a>01917           fflush(stdout);
<a name="l01918"></a>01918       }
<a name="l01919"></a>01919    }
<a name="l01920"></a>01920 }
<a name="l01921"></a>01921 
<a name="l01922"></a><a class="code" href="classgpgpu__sim.html#a0497a5e57600668cc187aeed3d6d08a9">01922</a> <span class="keywordtype">void</span> <a class="code" href="classgpgpu__sim.html#a0497a5e57600668cc187aeed3d6d08a9">gpgpu_sim::shader_print_runtime_stat</a>( FILE *fout ) 
<a name="l01923"></a>01923 {
<a name="l01924"></a>01924     <span class="comment">/*</span>
<a name="l01925"></a>01925 <span class="comment">   fprintf(fout, &quot;SHD_INSN: &quot;);</span>
<a name="l01926"></a>01926 <span class="comment">   for (unsigned i=0;i&lt;m_n_shader;i++) </span>
<a name="l01927"></a>01927 <span class="comment">      fprintf(fout, &quot;%u &quot;,m_sc[i]-&gt;get_num_sim_insn());</span>
<a name="l01928"></a>01928 <span class="comment">   fprintf(fout, &quot;\n&quot;);</span>
<a name="l01929"></a>01929 <span class="comment">   fprintf(fout, &quot;SHD_THDS: &quot;);</span>
<a name="l01930"></a>01930 <span class="comment">   for (unsigned i=0;i&lt;m_n_shader;i++) </span>
<a name="l01931"></a>01931 <span class="comment">      fprintf(fout, &quot;%u &quot;,m_sc[i]-&gt;get_not_completed());</span>
<a name="l01932"></a>01932 <span class="comment">   fprintf(fout, &quot;\n&quot;);</span>
<a name="l01933"></a>01933 <span class="comment">   fprintf(fout, &quot;SHD_DIVG: &quot;);</span>
<a name="l01934"></a>01934 <span class="comment">   for (unsigned i=0;i&lt;m_n_shader;i++) </span>
<a name="l01935"></a>01935 <span class="comment">      fprintf(fout, &quot;%u &quot;,m_sc[i]-&gt;get_n_diverge());</span>
<a name="l01936"></a>01936 <span class="comment">   fprintf(fout, &quot;\n&quot;);</span>
<a name="l01937"></a>01937 <span class="comment"></span>
<a name="l01938"></a>01938 <span class="comment">   fprintf(fout, &quot;THD_INSN: &quot;);</span>
<a name="l01939"></a>01939 <span class="comment">   for (unsigned i=0; i&lt;m_shader_config-&gt;n_thread_per_shader; i++) </span>
<a name="l01940"></a>01940 <span class="comment">      fprintf(fout, &quot;%d &quot;, m_sc[0]-&gt;get_thread_n_insn(i) );</span>
<a name="l01941"></a>01941 <span class="comment">   fprintf(fout, &quot;\n&quot;);</span>
<a name="l01942"></a>01942 <span class="comment">   */</span>
<a name="l01943"></a>01943 }
<a name="l01944"></a>01944 
<a name="l01945"></a>01945 
<a name="l01946"></a><a class="code" href="classgpgpu__sim.html#a0e7a7bb137fc02ff10f351b9238c7ea2">01946</a> <span class="keywordtype">void</span> <a class="code" href="classgpgpu__sim.html#a0e7a7bb137fc02ff10f351b9238c7ea2">gpgpu_sim::shader_print_scheduler_stat</a>( FILE* fout, <span class="keywordtype">bool</span> print_dynamic_info )<span class="keyword"> const</span>
<a name="l01947"></a>01947 <span class="keyword"></span>{
<a name="l01948"></a>01948     <span class="comment">// Print out the stats from the sampling shader core</span>
<a name="l01949"></a>01949     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> scheduler_sampling_core = <a class="code" href="classgpgpu__sim.html#a88a4e19b94bf5c3cfb7b05504527db9f">m_shader_config</a>-&gt;<a class="code" href="structshader__core__config.html#ad129f33cb35aea68b2f9b3b846aaee6d">gpgpu_warp_issue_shader</a>;
<a name="l01950"></a>01950 <span class="preprocessor">    #define STR_SIZE 55</span>
<a name="l01951"></a>01951 <span class="preprocessor"></span>    <span class="keywordtype">char</span> name_buff[ STR_SIZE ];
<a name="l01952"></a>01952     name_buff[ STR_SIZE - 1 ] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l01953"></a>01953     <span class="keyword">const</span> std::vector&lt; unsigned &gt;&amp; distro
<a name="l01954"></a>01954         = print_dynamic_info ?
<a name="l01955"></a>01955           <a class="code" href="classgpgpu__sim.html#abd087c9f98c28de4892944c61679b7c9">m_shader_stats</a>-&gt;<a class="code" href="classshader__core__stats.html#abb53447814e02afa214526c58b7c5bb7">get_dynamic_warp_issue</a>()[ scheduler_sampling_core ] :
<a name="l01956"></a>01956           <a class="code" href="classgpgpu__sim.html#abd087c9f98c28de4892944c61679b7c9">m_shader_stats</a>-&gt;<a class="code" href="classshader__core__stats.html#a95ee163725859b1b3ced5b267c13df1a">get_warp_slot_issue</a>()[ scheduler_sampling_core ];
<a name="l01957"></a>01957     <span class="keywordflow">if</span> ( print_dynamic_info ) {
<a name="l01958"></a>01958         snprintf( name_buff, STR_SIZE - 1, <span class="stringliteral">&quot;dynamic_warp_id&quot;</span> );
<a name="l01959"></a>01959     } <span class="keywordflow">else</span> {
<a name="l01960"></a>01960         snprintf( name_buff, STR_SIZE - 1, <span class="stringliteral">&quot;warp_id&quot;</span> );
<a name="l01961"></a>01961     }
<a name="l01962"></a>01962     fprintf( fout,
<a name="l01963"></a>01963              <span class="stringliteral">&quot;Shader %d %s issue ditsribution:\n&quot;</span>,
<a name="l01964"></a>01964              scheduler_sampling_core,
<a name="l01965"></a>01965              name_buff );
<a name="l01966"></a>01966     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> num_warp_ids = distro.size();
<a name="l01967"></a>01967     <span class="comment">// First print out the warp ids</span>
<a name="l01968"></a>01968     fprintf( fout, <span class="stringliteral">&quot;%s:\n&quot;</span>, name_buff );
<a name="l01969"></a>01969     <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> warp_id = 0;
<a name="l01970"></a>01970           warp_id &lt; num_warp_ids;
<a name="l01971"></a>01971           ++warp_id  ) {
<a name="l01972"></a>01972         fprintf( fout, <span class="stringliteral">&quot;%d, &quot;</span>, warp_id );
<a name="l01973"></a>01973     }
<a name="l01974"></a>01974 
<a name="l01975"></a>01975     fprintf( fout, <span class="stringliteral">&quot;\ndistro:\n&quot;</span> );
<a name="l01976"></a>01976     <span class="comment">// Then print out the distribution of instuctions issued</span>
<a name="l01977"></a>01977     <span class="keywordflow">for</span> ( std::vector&lt; unsigned &gt;::const_iterator iter = distro.begin();
<a name="l01978"></a>01978           iter != distro.end();
<a name="l01979"></a>01979           iter++ ) {
<a name="l01980"></a>01980         fprintf( fout, <span class="stringliteral">&quot;%d, &quot;</span>, *iter );
<a name="l01981"></a>01981     }
<a name="l01982"></a>01982     fprintf( fout, <span class="stringliteral">&quot;\n&quot;</span> );
<a name="l01983"></a>01983 }
<a name="l01984"></a>01984 
<a name="l01985"></a><a class="code" href="classgpgpu__sim.html#a103e607feb049cf1c598910f56b4e858">01985</a> <span class="keywordtype">void</span> <a class="code" href="classgpgpu__sim.html#a103e607feb049cf1c598910f56b4e858">gpgpu_sim::shader_print_cache_stats</a>( FILE *fout )<span class="keyword"> const</span>{
<a name="l01986"></a>01986 
<a name="l01987"></a>01987     <span class="comment">// L1I</span>
<a name="l01988"></a>01988     <span class="keyword">struct </span><a class="code" href="structcache__sub__stats.html">cache_sub_stats</a> total_css;
<a name="l01989"></a>01989     <span class="keyword">struct </span><a class="code" href="structcache__sub__stats.html">cache_sub_stats</a> css;
<a name="l01990"></a>01990 
<a name="l01991"></a>01991     <span class="keywordflow">if</span>(!<a class="code" href="classgpgpu__sim.html#a88a4e19b94bf5c3cfb7b05504527db9f">m_shader_config</a>-&gt;<a class="code" href="structshader__core__config.html#ae5bc9b8f23f27a0cf437dd3f4bf1a497">m_L1I_config</a>.<a class="code" href="classcache__config.html#a6e719909c6b7bea759a1d98bc49236b3">disabled</a>()){
<a name="l01992"></a>01992         total_css.<a class="code" href="structcache__sub__stats.html#a4d2c836830777dc9daa30e14609d1e06">clear</a>();
<a name="l01993"></a>01993         css.<a class="code" href="structcache__sub__stats.html#a4d2c836830777dc9daa30e14609d1e06">clear</a>();
<a name="l01994"></a>01994         fprintf(fout, <span class="stringliteral">&quot;\n========= Core cache stats =========\n&quot;</span>);
<a name="l01995"></a>01995         fprintf(fout, <span class="stringliteral">&quot;L1I_cache:\n&quot;</span>);
<a name="l01996"></a>01996         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> i = 0; i &lt; <a class="code" href="classgpgpu__sim.html#a88a4e19b94bf5c3cfb7b05504527db9f">m_shader_config</a>-&gt;<a class="code" href="structshader__core__config.html#a21b867d06fc4757d3a9b63404eb16692">n_simt_clusters</a>; ++i ) {
<a name="l01997"></a>01997             <a class="code" href="classgpgpu__sim.html#ae879377df64789d8591b6786afe6421c">m_cluster</a>[i]-&gt;<a class="code" href="classsimt__core__cluster.html#aa84c052767266e1ea61c7dc4b5281f61">get_L1I_sub_stats</a>(css);
<a name="l01998"></a>01998             total_css += css;
<a name="l01999"></a>01999         }
<a name="l02000"></a>02000         fprintf(fout, <span class="stringliteral">&quot;\tL1I_total_cache_accesses = %u\n&quot;</span>, total_css.<a class="code" href="structcache__sub__stats.html#ace6f26f297d2d5f01b0090c4395bf5a2">accesses</a>);
<a name="l02001"></a>02001         fprintf(fout, <span class="stringliteral">&quot;\tL1I_total_cache_misses = %u\n&quot;</span>, total_css.<a class="code" href="structcache__sub__stats.html#a0e3d75bc3ebd39ce854e11ec0f12e3e5">misses</a>);
<a name="l02002"></a>02002         <span class="keywordflow">if</span>(total_css.<a class="code" href="structcache__sub__stats.html#ace6f26f297d2d5f01b0090c4395bf5a2">accesses</a> &gt; 0){
<a name="l02003"></a>02003             fprintf(fout, <span class="stringliteral">&quot;\tL1I_total_cache_miss_rate = %.4lf\n&quot;</span>, (<span class="keywordtype">double</span>)total_css.<a class="code" href="structcache__sub__stats.html#a0e3d75bc3ebd39ce854e11ec0f12e3e5">misses</a> / (<span class="keywordtype">double</span>)total_css.<a class="code" href="structcache__sub__stats.html#ace6f26f297d2d5f01b0090c4395bf5a2">accesses</a>);
<a name="l02004"></a>02004         }
<a name="l02005"></a>02005         fprintf(fout, <span class="stringliteral">&quot;\tL1I_total_cache_pending_hits = %u\n&quot;</span>, total_css.<a class="code" href="structcache__sub__stats.html#acddbd29456bd4da96317d1dc6188cfd4">pending_hits</a>);
<a name="l02006"></a>02006         fprintf(fout, <span class="stringliteral">&quot;\tL1I_total_cache_reservation_fails = %u\n&quot;</span>, total_css.<a class="code" href="structcache__sub__stats.html#a2999db3914fe7f07500d257776bbd115">res_fails</a>);
<a name="l02007"></a>02007     }
<a name="l02008"></a>02008 
<a name="l02009"></a>02009     <span class="comment">// L1D</span>
<a name="l02010"></a>02010     <span class="keywordflow">if</span>(!<a class="code" href="classgpgpu__sim.html#a88a4e19b94bf5c3cfb7b05504527db9f">m_shader_config</a>-&gt;<a class="code" href="structshader__core__config.html#a4068e626fdfc6e4b44a8fdd656a44b94">m_L1D_config</a>.<a class="code" href="classcache__config.html#a6e719909c6b7bea759a1d98bc49236b3">disabled</a>()){
<a name="l02011"></a>02011         total_css.<a class="code" href="structcache__sub__stats.html#a4d2c836830777dc9daa30e14609d1e06">clear</a>();
<a name="l02012"></a>02012         css.<a class="code" href="structcache__sub__stats.html#a4d2c836830777dc9daa30e14609d1e06">clear</a>();
<a name="l02013"></a>02013         fprintf(fout, <span class="stringliteral">&quot;L1D_cache:\n&quot;</span>);
<a name="l02014"></a>02014         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0;i&lt;<a class="code" href="classgpgpu__sim.html#a88a4e19b94bf5c3cfb7b05504527db9f">m_shader_config</a>-&gt;<a class="code" href="structshader__core__config.html#a21b867d06fc4757d3a9b63404eb16692">n_simt_clusters</a>;i++){
<a name="l02015"></a>02015             <a class="code" href="classgpgpu__sim.html#ae879377df64789d8591b6786afe6421c">m_cluster</a>[i]-&gt;<a class="code" href="classsimt__core__cluster.html#afded1adf25fe48b5c4e5a6a628f361de">get_L1D_sub_stats</a>(css);
<a name="l02016"></a>02016 
<a name="l02017"></a>02017             fprintf( stdout, <span class="stringliteral">&quot;\tL1D_cache_core[%d]: Access = %d, Miss = %d, Miss_rate = %.3lf, Pending_hits = %u, Reservation_fails = %u\n&quot;</span>,
<a name="l02018"></a>02018                      i, css.<a class="code" href="structcache__sub__stats.html#ace6f26f297d2d5f01b0090c4395bf5a2">accesses</a>, css.<a class="code" href="structcache__sub__stats.html#a0e3d75bc3ebd39ce854e11ec0f12e3e5">misses</a>, (<span class="keywordtype">double</span>)css.<a class="code" href="structcache__sub__stats.html#a0e3d75bc3ebd39ce854e11ec0f12e3e5">misses</a> / (<span class="keywordtype">double</span>)css.<a class="code" href="structcache__sub__stats.html#ace6f26f297d2d5f01b0090c4395bf5a2">accesses</a>, css.<a class="code" href="structcache__sub__stats.html#acddbd29456bd4da96317d1dc6188cfd4">pending_hits</a>, css.<a class="code" href="structcache__sub__stats.html#a2999db3914fe7f07500d257776bbd115">res_fails</a>);
<a name="l02019"></a>02019 
<a name="l02020"></a>02020             total_css += css;
<a name="l02021"></a>02021         }
<a name="l02022"></a>02022         fprintf(fout, <span class="stringliteral">&quot;\tL1D_total_cache_accesses = %u\n&quot;</span>, total_css.<a class="code" href="structcache__sub__stats.html#ace6f26f297d2d5f01b0090c4395bf5a2">accesses</a>);
<a name="l02023"></a>02023         fprintf(fout, <span class="stringliteral">&quot;\tL1D_total_cache_misses = %u\n&quot;</span>, total_css.<a class="code" href="structcache__sub__stats.html#a0e3d75bc3ebd39ce854e11ec0f12e3e5">misses</a>);
<a name="l02024"></a>02024         <span class="keywordflow">if</span>(total_css.<a class="code" href="structcache__sub__stats.html#ace6f26f297d2d5f01b0090c4395bf5a2">accesses</a> &gt; 0){
<a name="l02025"></a>02025             fprintf(fout, <span class="stringliteral">&quot;\tL1D_total_cache_miss_rate = %.4lf\n&quot;</span>, (<span class="keywordtype">double</span>)total_css.<a class="code" href="structcache__sub__stats.html#a0e3d75bc3ebd39ce854e11ec0f12e3e5">misses</a> / (<span class="keywordtype">double</span>)total_css.<a class="code" href="structcache__sub__stats.html#ace6f26f297d2d5f01b0090c4395bf5a2">accesses</a>);
<a name="l02026"></a>02026         }
<a name="l02027"></a>02027         fprintf(fout, <span class="stringliteral">&quot;\tL1D_total_cache_pending_hits = %u\n&quot;</span>, total_css.<a class="code" href="structcache__sub__stats.html#acddbd29456bd4da96317d1dc6188cfd4">pending_hits</a>);
<a name="l02028"></a>02028         fprintf(fout, <span class="stringliteral">&quot;\tL1D_total_cache_reservation_fails = %u\n&quot;</span>, total_css.<a class="code" href="structcache__sub__stats.html#a2999db3914fe7f07500d257776bbd115">res_fails</a>);
<a name="l02029"></a>02029         total_css.<a class="code" href="structcache__sub__stats.html#a8a095a920a63375814e014fd0ff63890">print_port_stats</a>(fout, <span class="stringliteral">&quot;\tL1D_cache&quot;</span>); 
<a name="l02030"></a>02030     }
<a name="l02031"></a>02031 
<a name="l02032"></a>02032     <span class="comment">// L1C</span>
<a name="l02033"></a>02033     <span class="keywordflow">if</span>(!<a class="code" href="classgpgpu__sim.html#a88a4e19b94bf5c3cfb7b05504527db9f">m_shader_config</a>-&gt;<a class="code" href="structshader__core__config.html#a57349ee5d040d4b532798f0c68710d12">m_L1C_config</a>.<a class="code" href="classcache__config.html#a6e719909c6b7bea759a1d98bc49236b3">disabled</a>()){
<a name="l02034"></a>02034         total_css.<a class="code" href="structcache__sub__stats.html#a4d2c836830777dc9daa30e14609d1e06">clear</a>();
<a name="l02035"></a>02035         css.<a class="code" href="structcache__sub__stats.html#a4d2c836830777dc9daa30e14609d1e06">clear</a>();
<a name="l02036"></a>02036         fprintf(fout, <span class="stringliteral">&quot;L1C_cache:\n&quot;</span>);
<a name="l02037"></a>02037         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> i = 0; i &lt; <a class="code" href="classgpgpu__sim.html#a88a4e19b94bf5c3cfb7b05504527db9f">m_shader_config</a>-&gt;<a class="code" href="structshader__core__config.html#a21b867d06fc4757d3a9b63404eb16692">n_simt_clusters</a>; ++i ) {
<a name="l02038"></a>02038             <a class="code" href="classgpgpu__sim.html#ae879377df64789d8591b6786afe6421c">m_cluster</a>[i]-&gt;<a class="code" href="classsimt__core__cluster.html#abca528f41482b5b1a165cc31b6c7c66d">get_L1C_sub_stats</a>(css);
<a name="l02039"></a>02039             total_css += css;
<a name="l02040"></a>02040         }
<a name="l02041"></a>02041         fprintf(fout, <span class="stringliteral">&quot;\tL1C_total_cache_accesses = %u\n&quot;</span>, total_css.<a class="code" href="structcache__sub__stats.html#ace6f26f297d2d5f01b0090c4395bf5a2">accesses</a>);
<a name="l02042"></a>02042         fprintf(fout, <span class="stringliteral">&quot;\tL1C_total_cache_misses = %u\n&quot;</span>, total_css.<a class="code" href="structcache__sub__stats.html#a0e3d75bc3ebd39ce854e11ec0f12e3e5">misses</a>);
<a name="l02043"></a>02043         <span class="keywordflow">if</span>(total_css.<a class="code" href="structcache__sub__stats.html#ace6f26f297d2d5f01b0090c4395bf5a2">accesses</a> &gt; 0){
<a name="l02044"></a>02044             fprintf(fout, <span class="stringliteral">&quot;\tL1C_total_cache_miss_rate = %.4lf\n&quot;</span>, (<span class="keywordtype">double</span>)total_css.<a class="code" href="structcache__sub__stats.html#a0e3d75bc3ebd39ce854e11ec0f12e3e5">misses</a> / (<span class="keywordtype">double</span>)total_css.<a class="code" href="structcache__sub__stats.html#ace6f26f297d2d5f01b0090c4395bf5a2">accesses</a>);
<a name="l02045"></a>02045         }
<a name="l02046"></a>02046         fprintf(fout, <span class="stringliteral">&quot;\tL1C_total_cache_pending_hits = %u\n&quot;</span>, total_css.<a class="code" href="structcache__sub__stats.html#acddbd29456bd4da96317d1dc6188cfd4">pending_hits</a>);
<a name="l02047"></a>02047         fprintf(fout, <span class="stringliteral">&quot;\tL1C_total_cache_reservation_fails = %u\n&quot;</span>, total_css.<a class="code" href="structcache__sub__stats.html#a2999db3914fe7f07500d257776bbd115">res_fails</a>);
<a name="l02048"></a>02048     }
<a name="l02049"></a>02049 
<a name="l02050"></a>02050     <span class="comment">// L1T</span>
<a name="l02051"></a>02051     <span class="keywordflow">if</span>(!<a class="code" href="classgpgpu__sim.html#a88a4e19b94bf5c3cfb7b05504527db9f">m_shader_config</a>-&gt;<a class="code" href="structshader__core__config.html#a97e70c22ec0f090203fbd1831d59a968">m_L1T_config</a>.<a class="code" href="classcache__config.html#a6e719909c6b7bea759a1d98bc49236b3">disabled</a>()){
<a name="l02052"></a>02052         total_css.<a class="code" href="structcache__sub__stats.html#a4d2c836830777dc9daa30e14609d1e06">clear</a>();
<a name="l02053"></a>02053         css.<a class="code" href="structcache__sub__stats.html#a4d2c836830777dc9daa30e14609d1e06">clear</a>();
<a name="l02054"></a>02054         fprintf(fout, <span class="stringliteral">&quot;L1T_cache:\n&quot;</span>);
<a name="l02055"></a>02055         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> i = 0; i &lt; <a class="code" href="classgpgpu__sim.html#a88a4e19b94bf5c3cfb7b05504527db9f">m_shader_config</a>-&gt;<a class="code" href="structshader__core__config.html#a21b867d06fc4757d3a9b63404eb16692">n_simt_clusters</a>; ++i ) {
<a name="l02056"></a>02056             <a class="code" href="classgpgpu__sim.html#ae879377df64789d8591b6786afe6421c">m_cluster</a>[i]-&gt;<a class="code" href="classsimt__core__cluster.html#a4b793aa21296aff9469c36b37197fbb8">get_L1T_sub_stats</a>(css);
<a name="l02057"></a>02057             total_css += css;
<a name="l02058"></a>02058         }
<a name="l02059"></a>02059         fprintf(fout, <span class="stringliteral">&quot;\tL1T_total_cache_accesses = %u\n&quot;</span>, total_css.<a class="code" href="structcache__sub__stats.html#ace6f26f297d2d5f01b0090c4395bf5a2">accesses</a>);
<a name="l02060"></a>02060         fprintf(fout, <span class="stringliteral">&quot;\tL1T_total_cache_misses = %u\n&quot;</span>, total_css.<a class="code" href="structcache__sub__stats.html#a0e3d75bc3ebd39ce854e11ec0f12e3e5">misses</a>);
<a name="l02061"></a>02061         <span class="keywordflow">if</span>(total_css.<a class="code" href="structcache__sub__stats.html#ace6f26f297d2d5f01b0090c4395bf5a2">accesses</a> &gt; 0){
<a name="l02062"></a>02062             fprintf(fout, <span class="stringliteral">&quot;\tL1T_total_cache_miss_rate = %.4lf\n&quot;</span>, (<span class="keywordtype">double</span>)total_css.<a class="code" href="structcache__sub__stats.html#a0e3d75bc3ebd39ce854e11ec0f12e3e5">misses</a> / (<span class="keywordtype">double</span>)total_css.<a class="code" href="structcache__sub__stats.html#ace6f26f297d2d5f01b0090c4395bf5a2">accesses</a>);
<a name="l02063"></a>02063         }
<a name="l02064"></a>02064         fprintf(fout, <span class="stringliteral">&quot;\tL1T_total_cache_pending_hits = %u\n&quot;</span>, total_css.<a class="code" href="structcache__sub__stats.html#acddbd29456bd4da96317d1dc6188cfd4">pending_hits</a>);
<a name="l02065"></a>02065         fprintf(fout, <span class="stringliteral">&quot;\tL1T_total_cache_reservation_fails = %u\n&quot;</span>, total_css.<a class="code" href="structcache__sub__stats.html#a2999db3914fe7f07500d257776bbd115">res_fails</a>);
<a name="l02066"></a>02066     }
<a name="l02067"></a>02067 }
<a name="l02068"></a>02068 
<a name="l02069"></a><a class="code" href="classgpgpu__sim.html#a5dbd4a0cd5c6bdb4d5995c5c0ecea592">02069</a> <span class="keywordtype">void</span> <a class="code" href="classgpgpu__sim.html#a5dbd4a0cd5c6bdb4d5995c5c0ecea592">gpgpu_sim::shader_print_l1_miss_stat</a>( FILE *fout )<span class="keyword"> const</span>
<a name="l02070"></a>02070 <span class="keyword"></span>{
<a name="l02071"></a>02071    <span class="keywordtype">unsigned</span> total_d1_misses = 0, total_d1_accesses = 0;
<a name="l02072"></a>02072    <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> i = 0; i &lt; <a class="code" href="classgpgpu__sim.html#a88a4e19b94bf5c3cfb7b05504527db9f">m_shader_config</a>-&gt;<a class="code" href="structshader__core__config.html#a21b867d06fc4757d3a9b63404eb16692">n_simt_clusters</a>; ++i ) {
<a name="l02073"></a>02073          <span class="keywordtype">unsigned</span> custer_d1_misses = 0, cluster_d1_accesses = 0;
<a name="l02074"></a>02074          <a class="code" href="classgpgpu__sim.html#ae879377df64789d8591b6786afe6421c">m_cluster</a>[ i ]-&gt;<a class="code" href="classsimt__core__cluster.html#a813e8560d307d9110b6c84cb21cb3893">print_cache_stats</a>( fout, cluster_d1_accesses, custer_d1_misses );
<a name="l02075"></a>02075          total_d1_misses += custer_d1_misses;
<a name="l02076"></a>02076          total_d1_accesses += cluster_d1_accesses;
<a name="l02077"></a>02077    }
<a name="l02078"></a>02078    fprintf( fout, <span class="stringliteral">&quot;total_dl1_misses=%d\n&quot;</span>, total_d1_misses );
<a name="l02079"></a>02079    fprintf( fout, <span class="stringliteral">&quot;total_dl1_accesses=%d\n&quot;</span>, total_d1_accesses );
<a name="l02080"></a>02080    fprintf( fout, <span class="stringliteral">&quot;total_dl1_miss_rate= %f\n&quot;</span>, (<span class="keywordtype">float</span>)total_d1_misses / (<span class="keywordtype">float</span>)total_d1_accesses );
<a name="l02081"></a>02081    <span class="comment">/*</span>
<a name="l02082"></a>02082 <span class="comment">   fprintf(fout, &quot;THD_INSN_AC: &quot;);</span>
<a name="l02083"></a>02083 <span class="comment">   for (unsigned i=0; i&lt;m_shader_config-&gt;n_thread_per_shader; i++) </span>
<a name="l02084"></a>02084 <span class="comment">      fprintf(fout, &quot;%d &quot;, m_sc[0]-&gt;get_thread_n_insn_ac(i));</span>
<a name="l02085"></a>02085 <span class="comment">   fprintf(fout, &quot;\n&quot;);</span>
<a name="l02086"></a>02086 <span class="comment">   fprintf(fout, &quot;T_L1_Mss: &quot;); //l1 miss rate per thread</span>
<a name="l02087"></a>02087 <span class="comment">   for (unsigned i=0; i&lt;m_shader_config-&gt;n_thread_per_shader; i++) </span>
<a name="l02088"></a>02088 <span class="comment">      fprintf(fout, &quot;%d &quot;, m_sc[0]-&gt;get_thread_n_l1_mis_ac(i));</span>
<a name="l02089"></a>02089 <span class="comment">   fprintf(fout, &quot;\n&quot;);</span>
<a name="l02090"></a>02090 <span class="comment">   fprintf(fout, &quot;T_L1_Mgs: &quot;); //l1 merged miss rate per thread</span>
<a name="l02091"></a>02091 <span class="comment">   for (unsigned i=0; i&lt;m_shader_config-&gt;n_thread_per_shader; i++) </span>
<a name="l02092"></a>02092 <span class="comment">      fprintf(fout, &quot;%d &quot;, m_sc[0]-&gt;get_thread_n_l1_mis_ac(i) - m_sc[0]-&gt;get_thread_n_l1_mrghit_ac(i));</span>
<a name="l02093"></a>02093 <span class="comment">   fprintf(fout, &quot;\n&quot;);</span>
<a name="l02094"></a>02094 <span class="comment">   fprintf(fout, &quot;T_L1_Acc: &quot;); //l1 access per thread</span>
<a name="l02095"></a>02095 <span class="comment">   for (unsigned i=0; i&lt;m_shader_config-&gt;n_thread_per_shader; i++) </span>
<a name="l02096"></a>02096 <span class="comment">      fprintf(fout, &quot;%d &quot;, m_sc[0]-&gt;get_thread_n_l1_access_ac(i));</span>
<a name="l02097"></a>02097 <span class="comment">   fprintf(fout, &quot;\n&quot;);</span>
<a name="l02098"></a>02098 <span class="comment"></span>
<a name="l02099"></a>02099 <span class="comment">   //per warp</span>
<a name="l02100"></a>02100 <span class="comment">   int temp =0; </span>
<a name="l02101"></a>02101 <span class="comment">   fprintf(fout, &quot;W_L1_Mss: &quot;); //l1 miss rate per warp</span>
<a name="l02102"></a>02102 <span class="comment">   for (unsigned i=0; i&lt;m_shader_config-&gt;n_thread_per_shader; i++) {</span>
<a name="l02103"></a>02103 <span class="comment">      temp += m_sc[0]-&gt;get_thread_n_l1_mis_ac(i);</span>
<a name="l02104"></a>02104 <span class="comment">      if (i%m_shader_config-&gt;warp_size == (unsigned)(m_shader_config-&gt;warp_size-1)) {</span>
<a name="l02105"></a>02105 <span class="comment">         fprintf(fout, &quot;%d &quot;, temp);</span>
<a name="l02106"></a>02106 <span class="comment">         temp = 0;</span>
<a name="l02107"></a>02107 <span class="comment">      }</span>
<a name="l02108"></a>02108 <span class="comment">   }</span>
<a name="l02109"></a>02109 <span class="comment">   fprintf(fout, &quot;\n&quot;);</span>
<a name="l02110"></a>02110 <span class="comment">   temp=0;</span>
<a name="l02111"></a>02111 <span class="comment">   fprintf(fout, &quot;W_L1_Mgs: &quot;); //l1 merged miss rate per warp</span>
<a name="l02112"></a>02112 <span class="comment">   for (unsigned i=0; i&lt;m_shader_config-&gt;n_thread_per_shader; i++) {</span>
<a name="l02113"></a>02113 <span class="comment">      temp += (m_sc[0]-&gt;get_thread_n_l1_mis_ac(i) - m_sc[0]-&gt;get_thread_n_l1_mrghit_ac(i) );</span>
<a name="l02114"></a>02114 <span class="comment">      if (i%m_shader_config-&gt;warp_size == (unsigned)(m_shader_config-&gt;warp_size-1)) {</span>
<a name="l02115"></a>02115 <span class="comment">         fprintf(fout, &quot;%d &quot;, temp);</span>
<a name="l02116"></a>02116 <span class="comment">         temp = 0;</span>
<a name="l02117"></a>02117 <span class="comment">      }</span>
<a name="l02118"></a>02118 <span class="comment">   }</span>
<a name="l02119"></a>02119 <span class="comment">   fprintf(fout, &quot;\n&quot;);</span>
<a name="l02120"></a>02120 <span class="comment">   temp =0;</span>
<a name="l02121"></a>02121 <span class="comment">   fprintf(fout, &quot;W_L1_Acc: &quot;); //l1 access per warp</span>
<a name="l02122"></a>02122 <span class="comment">   for (unsigned i=0; i&lt;m_shader_config-&gt;n_thread_per_shader; i++) {</span>
<a name="l02123"></a>02123 <span class="comment">      temp += m_sc[0]-&gt;get_thread_n_l1_access_ac(i);</span>
<a name="l02124"></a>02124 <span class="comment">      if (i%m_shader_config-&gt;warp_size == (unsigned)(m_shader_config-&gt;warp_size-1)) {</span>
<a name="l02125"></a>02125 <span class="comment">         fprintf(fout, &quot;%d &quot;, temp);</span>
<a name="l02126"></a>02126 <span class="comment">         temp = 0;</span>
<a name="l02127"></a>02127 <span class="comment">      }</span>
<a name="l02128"></a>02128 <span class="comment">   }</span>
<a name="l02129"></a>02129 <span class="comment">   fprintf(fout, &quot;\n&quot;);</span>
<a name="l02130"></a>02130 <span class="comment">   */</span>
<a name="l02131"></a>02131 }
<a name="l02132"></a>02132 
<a name="l02133"></a><a class="code" href="classwarp__inst__t.html#a55adcc62951f84d8b005c0a8a1a056e2">02133</a> <span class="keywordtype">void</span> <a class="code" href="classwarp__inst__t.html#a55adcc62951f84d8b005c0a8a1a056e2">warp_inst_t::print</a>( FILE *fout )<span class="keyword"> const</span>
<a name="l02134"></a>02134 <span class="keyword"></span>{
<a name="l02135"></a>02135     <span class="keywordflow">if</span> (<a class="code" href="classwarp__inst__t.html#a6d8dcd93a49b024688585d9e37a86a4e">empty</a>() ) {
<a name="l02136"></a>02136         fprintf(fout,<span class="stringliteral">&quot;bubble\n&quot;</span> );
<a name="l02137"></a>02137         <span class="keywordflow">return</span>;
<a name="l02138"></a>02138     } <span class="keywordflow">else</span> 
<a name="l02139"></a>02139         fprintf(fout,<span class="stringliteral">&quot;0x%04x &quot;</span>, <a class="code" href="classinst__t.html#a76aea27709c3a0256c2615451c7daa56">pc</a> );
<a name="l02140"></a>02140     fprintf(fout, <span class="stringliteral">&quot;w%02d[&quot;</span>, <a class="code" href="classwarp__inst__t.html#acf0e9df5aafb913eb8b961c47d4b4300">m_warp_id</a>);
<a name="l02141"></a>02141     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;<a class="code" href="classwarp__inst__t.html#a72bafff96f66a0d3bb4954401ff85da1">m_config</a>-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>; j++)
<a name="l02142"></a>02142         fprintf(fout, <span class="stringliteral">&quot;%c&quot;</span>, (<a class="code" href="classwarp__inst__t.html#ae44d8d3d283dc0ecf16db55f57f3c03d">active</a>(j)?<span class="charliteral">&apos;1&apos;</span>:<span class="charliteral">&apos;0&apos;</span>) );
<a name="l02143"></a>02143     fprintf(fout, <span class="stringliteral">&quot;]: &quot;</span>);
<a name="l02144"></a>02144     <a class="code" href="cuda-sim_8cc.html#a828660ddae007d7730f4340f644962a3">ptx_print_insn</a>( <a class="code" href="classinst__t.html#a76aea27709c3a0256c2615451c7daa56">pc</a>, fout );
<a name="l02145"></a>02145     fprintf(fout, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02146"></a>02146 }
<a name="l02147"></a><a class="code" href="classshader__core__ctx.html#afe3c3bd2faef867520995e7cab19484a">02147</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#afe3c3bd2faef867520995e7cab19484a">shader_core_ctx::incexecstat</a>(<a class="code" href="classwarp__inst__t.html">warp_inst_t</a> *&amp;inst)
<a name="l02148"></a>02148 {
<a name="l02149"></a>02149     <span class="keywordflow">if</span>(inst-&gt;<a class="code" href="classinst__t.html#a740113d4aeb9d9c593e88211ec560390">mem_op</a>==<a class="code" href="abstract__hardware__model_8h.html#a36b1ea75630fc91b4b9b711513cdf016a24e799bd38fe08efb4756c63d8f78df9">TEX</a>)
<a name="l02150"></a>02150         <a class="code" href="classshader__core__ctx.html#a17e854fea22f91dcf85cfc9685074e3a">inctex_stat</a>(inst-&gt;<a class="code" href="classwarp__inst__t.html#ae2478f41ed1d4ce60ceec0fa5a85623a">active_count</a>(),1);
<a name="l02151"></a>02151 
<a name="l02152"></a>02152     <span class="comment">// Latency numbers for next operations are used to scale the power values</span>
<a name="l02153"></a>02153     <span class="comment">// for special operations, according observations from microbenchmarking</span>
<a name="l02154"></a>02154     <span class="comment">// TODO: put these numbers in the xml configuration</span>
<a name="l02155"></a>02155 
<a name="l02156"></a>02156     <span class="keywordflow">switch</span>(inst-&gt;<a class="code" href="classinst__t.html#aa01cff1aa0581463b17d5fe0e58d0196">sp_op</a>){
<a name="l02157"></a>02157     <span class="keywordflow">case</span> <a class="code" href="abstract__hardware__model_8h.html#a4bca82f78a8b186b2f789b829b836312abfd5ed25cbbfae72852f6b1069bde7c2">INT__OP</a>:
<a name="l02158"></a>02158         <a class="code" href="classshader__core__ctx.html#abc2959430c28b8141ad73bccf7ae4856">incialu_stat</a>(inst-&gt;<a class="code" href="classwarp__inst__t.html#ae2478f41ed1d4ce60ceec0fa5a85623a">active_count</a>(),25);
<a name="l02159"></a>02159         <span class="keywordflow">break</span>;
<a name="l02160"></a>02160     <span class="keywordflow">case</span> <a class="code" href="abstract__hardware__model_8h.html#a4bca82f78a8b186b2f789b829b836312ac3bb505c851133428bc4821d20413b70">INT_MUL_OP</a>:
<a name="l02161"></a>02161         <a class="code" href="classshader__core__ctx.html#ad9c028f57ba130eec2c15c1590570832">incimul_stat</a>(inst-&gt;<a class="code" href="classwarp__inst__t.html#ae2478f41ed1d4ce60ceec0fa5a85623a">active_count</a>(),7.2);
<a name="l02162"></a>02162         <span class="keywordflow">break</span>;
<a name="l02163"></a>02163     <span class="keywordflow">case</span> <a class="code" href="abstract__hardware__model_8h.html#a4bca82f78a8b186b2f789b829b836312a743916393402a1d168b9fe36f25399dd">INT_MUL24_OP</a>:
<a name="l02164"></a>02164         <a class="code" href="classshader__core__ctx.html#ab06869dbdaf2b1ce8410299c7d236d8b">incimul24_stat</a>(inst-&gt;<a class="code" href="classwarp__inst__t.html#ae2478f41ed1d4ce60ceec0fa5a85623a">active_count</a>(),4.2);
<a name="l02165"></a>02165         <span class="keywordflow">break</span>;
<a name="l02166"></a>02166     <span class="keywordflow">case</span> <a class="code" href="abstract__hardware__model_8h.html#a4bca82f78a8b186b2f789b829b836312a911de02c13639d8d99a20873bac3219f">INT_MUL32_OP</a>:
<a name="l02167"></a>02167         <a class="code" href="classshader__core__ctx.html#ac9905dc7e12df15fe1befdf0ad367c97">incimul32_stat</a>(inst-&gt;<a class="code" href="classwarp__inst__t.html#ae2478f41ed1d4ce60ceec0fa5a85623a">active_count</a>(),4);
<a name="l02168"></a>02168         <span class="keywordflow">break</span>;
<a name="l02169"></a>02169     <span class="keywordflow">case</span> <a class="code" href="abstract__hardware__model_8h.html#a4bca82f78a8b186b2f789b829b836312a568bca6163b949ab40eab99b4bea4752">INT_DIV_OP</a>:
<a name="l02170"></a>02170         <a class="code" href="classshader__core__ctx.html#ad80996f8fb5a4ce5634f919f826e8e22">incidiv_stat</a>(inst-&gt;<a class="code" href="classwarp__inst__t.html#ae2478f41ed1d4ce60ceec0fa5a85623a">active_count</a>(),40);
<a name="l02171"></a>02171         <span class="keywordflow">break</span>;
<a name="l02172"></a>02172     <span class="keywordflow">case</span> <a class="code" href="abstract__hardware__model_8h.html#a4bca82f78a8b186b2f789b829b836312a47ebef5e23340accdb84e22c66bbbeba">FP__OP</a>:
<a name="l02173"></a>02173         <a class="code" href="classshader__core__ctx.html#a53a67533b5f47f02bca0b6dfc47127ef">incfpalu_stat</a>(inst-&gt;<a class="code" href="classwarp__inst__t.html#ae2478f41ed1d4ce60ceec0fa5a85623a">active_count</a>(),1);
<a name="l02174"></a>02174         <span class="keywordflow">break</span>;
<a name="l02175"></a>02175     <span class="keywordflow">case</span> <a class="code" href="abstract__hardware__model_8h.html#a4bca82f78a8b186b2f789b829b836312a505e663b361288c1a8b45d22c4f0b43b">FP_MUL_OP</a>:
<a name="l02176"></a>02176         <a class="code" href="classshader__core__ctx.html#aa6f430cbcb2ef9b3e6fd1b641ae0ea6b">incfpmul_stat</a>(inst-&gt;<a class="code" href="classwarp__inst__t.html#ae2478f41ed1d4ce60ceec0fa5a85623a">active_count</a>(),1.8);
<a name="l02177"></a>02177         <span class="keywordflow">break</span>;
<a name="l02178"></a>02178     <span class="keywordflow">case</span> <a class="code" href="abstract__hardware__model_8h.html#a4bca82f78a8b186b2f789b829b836312ab1418341c8cfff3134b88b5348a5539e">FP_DIV_OP</a>:
<a name="l02179"></a>02179         <a class="code" href="classshader__core__ctx.html#a16e0e85686ff4cab3072d893755490e6">incfpdiv_stat</a>(inst-&gt;<a class="code" href="classwarp__inst__t.html#ae2478f41ed1d4ce60ceec0fa5a85623a">active_count</a>(),48);
<a name="l02180"></a>02180         <span class="keywordflow">break</span>;
<a name="l02181"></a>02181     <span class="keywordflow">case</span> <a class="code" href="abstract__hardware__model_8h.html#a4bca82f78a8b186b2f789b829b836312a530c6307fe420a921bc8c7718dd017c5">FP_SQRT_OP</a>:
<a name="l02182"></a>02182         <a class="code" href="classshader__core__ctx.html#aa62fc9b256c6cf020d3826c2b891730d">inctrans_stat</a>(inst-&gt;<a class="code" href="classwarp__inst__t.html#ae2478f41ed1d4ce60ceec0fa5a85623a">active_count</a>(),25);
<a name="l02183"></a>02183         <span class="keywordflow">break</span>;
<a name="l02184"></a>02184     <span class="keywordflow">case</span> <a class="code" href="abstract__hardware__model_8h.html#a4bca82f78a8b186b2f789b829b836312af1c8fdd317d63755facd75f71564ca6a">FP_LG_OP</a>:
<a name="l02185"></a>02185         <a class="code" href="classshader__core__ctx.html#aa62fc9b256c6cf020d3826c2b891730d">inctrans_stat</a>(inst-&gt;<a class="code" href="classwarp__inst__t.html#ae2478f41ed1d4ce60ceec0fa5a85623a">active_count</a>(),35);
<a name="l02186"></a>02186         <span class="keywordflow">break</span>;
<a name="l02187"></a>02187     <span class="keywordflow">case</span> <a class="code" href="abstract__hardware__model_8h.html#a4bca82f78a8b186b2f789b829b836312a16ae7f68efebd0715be7fd2f6389b052">FP_SIN_OP</a>:
<a name="l02188"></a>02188         <a class="code" href="classshader__core__ctx.html#aa62fc9b256c6cf020d3826c2b891730d">inctrans_stat</a>(inst-&gt;<a class="code" href="classwarp__inst__t.html#ae2478f41ed1d4ce60ceec0fa5a85623a">active_count</a>(),12);
<a name="l02189"></a>02189         <span class="keywordflow">break</span>;
<a name="l02190"></a>02190     <span class="keywordflow">case</span> <a class="code" href="abstract__hardware__model_8h.html#a4bca82f78a8b186b2f789b829b836312a33006a20188b1857b0675ad0fb4d8094">FP_EXP_OP</a>:
<a name="l02191"></a>02191         <a class="code" href="classshader__core__ctx.html#aa62fc9b256c6cf020d3826c2b891730d">inctrans_stat</a>(inst-&gt;<a class="code" href="classwarp__inst__t.html#ae2478f41ed1d4ce60ceec0fa5a85623a">active_count</a>(),35);
<a name="l02192"></a>02192         <span class="keywordflow">break</span>;
<a name="l02193"></a>02193     <span class="keywordflow">default</span>:
<a name="l02194"></a>02194         <span class="keywordflow">break</span>;
<a name="l02195"></a>02195     }
<a name="l02196"></a>02196 }
<a name="l02197"></a><a class="code" href="classshader__core__ctx.html#ada80589e61c463198aaffa2efc8e7150">02197</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#ada80589e61c463198aaffa2efc8e7150">shader_core_ctx::print_stage</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stage, FILE *fout )<span class="keyword"> const</span>
<a name="l02198"></a>02198 <span class="keyword"></span>{
<a name="l02199"></a>02199    <a class="code" href="classshader__core__ctx.html#acdfd6977f3f9e34ad162c9f1262da833">m_pipeline_reg</a>[stage].print(fout);
<a name="l02200"></a>02200    <span class="comment">//m_pipeline_reg[stage].print(fout);</span>
<a name="l02201"></a>02201 }
<a name="l02202"></a>02202 
<a name="l02203"></a><a class="code" href="classshader__core__ctx.html#aa93b5f4f123a61ebce0f07a8d3c5fc1d">02203</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#aa93b5f4f123a61ebce0f07a8d3c5fc1d">shader_core_ctx::display_simt_state</a>(FILE *fout, <span class="keywordtype">int</span> mask )<span class="keyword"> const</span>
<a name="l02204"></a>02204 <span class="keyword"></span>{
<a name="l02205"></a>02205     <span class="keywordflow">if</span> ( (mask &amp; 4) &amp;&amp; <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#abd0a32b3d0fec341d656455aff2f66b7">model</a> == <a class="code" href="abstract__hardware__model_8h.html#a3c3e5c822956df0d19e61cbb11c5b12ba31993dfb97df7a2ea5aa5a9504b96c72">POST_DOMINATOR</a> ) {
<a name="l02206"></a>02206        fprintf(fout,<span class="stringliteral">&quot;per warp SIMT control-flow state:\n&quot;</span>);
<a name="l02207"></a>02207        <span class="keywordtype">unsigned</span> <a class="code" href="rng_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a> = <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a559092b8eaeffafe04a61f83cefe74d2">n_thread_per_shader</a> / <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>;
<a name="l02208"></a>02208        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i &lt; n; i++) {
<a name="l02209"></a>02209           <span class="keywordtype">unsigned</span> nactive = 0;
<a name="l02210"></a>02210           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j=0; j&lt;<a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>; j++ ) {
<a name="l02211"></a>02211              <span class="keywordtype">unsigned</span> tid = i*<a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a> + j;
<a name="l02212"></a>02212              <span class="keywordtype">int</span> done = <a class="code" href="classcore__t.html#aef36fb0d504e2357a78da821249f617a">ptx_thread_done</a>(tid);
<a name="l02213"></a>02213              nactive += (<a class="code" href="classcore__t.html#aef36fb0d504e2357a78da821249f617a">ptx_thread_done</a>(tid)?0:1);
<a name="l02214"></a>02214              <span class="keywordflow">if</span> ( done &amp;&amp; (mask &amp; 8) ) {
<a name="l02215"></a>02215                 <span class="keywordtype">unsigned</span> done_cycle = <a class="code" href="classcore__t.html#a74ac58fba7a6ecd53ba31705ba5c38cd">m_thread</a>[tid]-&gt;<a class="code" href="classptx__thread__info.html#a0e611a6cc11f8b71de9025a051f42e91">donecycle</a>();
<a name="l02216"></a>02216                 <span class="keywordflow">if</span> ( done_cycle ) {
<a name="l02217"></a>02217                    printf(<span class="stringliteral">&quot;\n w%02u:t%03u: done @ cycle %u&quot;</span>, i, tid, done_cycle );
<a name="l02218"></a>02218                 }
<a name="l02219"></a>02219              }
<a name="l02220"></a>02220           }
<a name="l02221"></a>02221           <span class="keywordflow">if</span> ( nactive == 0 ) {
<a name="l02222"></a>02222              <span class="keywordflow">continue</span>;
<a name="l02223"></a>02223           }
<a name="l02224"></a>02224           <a class="code" href="classcore__t.html#abc85a3fb05c778cd6c06c95863a47ed6">m_simt_stack</a>[i]-&gt;<a class="code" href="classsimt__stack.html#ab440907717ca0af046404d08c2e60fac">print</a>(fout);
<a name="l02225"></a>02225        }
<a name="l02226"></a>02226        fprintf(fout,<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02227"></a>02227     }
<a name="l02228"></a>02228 }
<a name="l02229"></a>02229 
<a name="l02230"></a><a class="code" href="classldst__unit.html#a54a353b5bb6128afe08d786e61ccb4bb">02230</a> <span class="keywordtype">void</span> <a class="code" href="classldst__unit.html#a54a353b5bb6128afe08d786e61ccb4bb">ldst_unit::print</a>(FILE *fout)<span class="keyword"> const</span>
<a name="l02231"></a>02231 <span class="keyword"></span>{
<a name="l02232"></a>02232     fprintf(fout,<span class="stringliteral">&quot;LD/ST unit  = &quot;</span>);
<a name="l02233"></a>02233     <a class="code" href="classsimd__function__unit.html#ae55a510a8ce9e0ee2dc1d8a66578e5f2">m_dispatch_reg</a>-&gt;<a class="code" href="classwarp__inst__t.html#a55adcc62951f84d8b005c0a8a1a056e2">print</a>(fout);
<a name="l02234"></a>02234     <span class="keywordflow">if</span> ( <a class="code" href="classldst__unit.html#ae89492e94d8bba86f04558b35f5ba834">m_mem_rc</a> != <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7a038f41ff0d19fa8e4741dde172051053">NO_RC_FAIL</a> ) {
<a name="l02235"></a>02235         fprintf(fout,<span class="stringliteral">&quot;              LD/ST stall condition: &quot;</span>);
<a name="l02236"></a>02236         <span class="keywordflow">switch</span> ( <a class="code" href="classldst__unit.html#ae89492e94d8bba86f04558b35f5ba834">m_mem_rc</a> ) {
<a name="l02237"></a>02237         <span class="keywordflow">case</span> <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7aeff5b672a5cc1e217a576cf635b173f4">BK_CONF</a>:        fprintf(fout,<span class="stringliteral">&quot;BK_CONF&quot;</span>); <span class="keywordflow">break</span>;
<a name="l02238"></a>02238         <span class="keywordflow">case</span> <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7af5a378ef16b96b5229f796e775b35187">MSHR_RC_FAIL</a>:   fprintf(fout,<span class="stringliteral">&quot;MSHR_RC_FAIL&quot;</span>); <span class="keywordflow">break</span>;
<a name="l02239"></a>02239         <span class="keywordflow">case</span> <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7a7ffa00b440a82b64996be240be743ea2">ICNT_RC_FAIL</a>:   fprintf(fout,<span class="stringliteral">&quot;ICNT_RC_FAIL&quot;</span>); <span class="keywordflow">break</span>;
<a name="l02240"></a>02240         <span class="keywordflow">case</span> <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7a69e7a22f4b547c6292b30a5c5f1ad161">COAL_STALL</a>:     fprintf(fout,<span class="stringliteral">&quot;COAL_STALL&quot;</span>); <span class="keywordflow">break</span>;
<a name="l02241"></a>02241         <span class="keywordflow">case</span> <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7ab9b0daa93da2bc3bcabdd5e9fbb3ee19">WB_ICNT_RC_FAIL</a>: fprintf(fout,<span class="stringliteral">&quot;WB_ICNT_RC_FAIL&quot;</span>); <span class="keywordflow">break</span>;
<a name="l02242"></a>02242         <span class="keywordflow">case</span> <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7a4cdcc4997460beba05f43267efad6ba8">WB_CACHE_RSRV_FAIL</a>: fprintf(fout,<span class="stringliteral">&quot;WB_CACHE_RSRV_FAIL&quot;</span>); <span class="keywordflow">break</span>;
<a name="l02243"></a>02243         <span class="keywordflow">case</span> <a class="code" href="stats_8h.html#a6171377cb4e82b196df4e0a4ea1a95f7a9648ab887e0ad149a312e17a9720672d">N_MEM_STAGE_STALL_TYPE</a>: fprintf(fout,<span class="stringliteral">&quot;N_MEM_STAGE_STALL_TYPE&quot;</span>); <span class="keywordflow">break</span>;
<a name="l02244"></a>02244         <span class="keywordflow">default</span>: abort();
<a name="l02245"></a>02245         }
<a name="l02246"></a>02246         fprintf(fout,<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02247"></a>02247     }
<a name="l02248"></a>02248     fprintf(fout,<span class="stringliteral">&quot;LD/ST wb    = &quot;</span>);
<a name="l02249"></a>02249     <a class="code" href="classldst__unit.html#ac71d0e9348f6d668e796c97752516354">m_next_wb</a>.<a class="code" href="classwarp__inst__t.html#a55adcc62951f84d8b005c0a8a1a056e2">print</a>(fout);
<a name="l02250"></a>02250     fprintf(fout, <span class="stringliteral">&quot;Last LD/ST writeback @ %llu + %llu (gpu_sim_cycle+gpu_tot_sim_cycle)\n&quot;</span>,
<a name="l02251"></a>02251                   <a class="code" href="classldst__unit.html#aff0e2865331fd8bec6c96061958a0c20">m_last_inst_gpu_sim_cycle</a>, <a class="code" href="classldst__unit.html#a358b1600ef78f0f9657e391afc19fa2b">m_last_inst_gpu_tot_sim_cycle</a> );
<a name="l02252"></a>02252     fprintf(fout,<span class="stringliteral">&quot;Pending register writes:\n&quot;</span>);
<a name="l02253"></a>02253     std::map&lt;<span class="keywordtype">unsigned</span><span class="comment">/*warp_id*/</span>, std::map&lt;<span class="keywordtype">unsigned</span><span class="comment">/*regnum*/</span>,<span class="keywordtype">unsigned</span><span class="comment">/*count*/</span>&gt; &gt;::const_iterator w;
<a name="l02254"></a>02254     <span class="keywordflow">for</span>( w=<a class="code" href="classldst__unit.html#a1e13765c48144194fc28c0c218094ff2">m_pending_writes</a>.begin(); w!=<a class="code" href="classldst__unit.html#a1e13765c48144194fc28c0c218094ff2">m_pending_writes</a>.end(); w++ ) {
<a name="l02255"></a>02255         <span class="keywordtype">unsigned</span> warp_id = w-&gt;first;
<a name="l02256"></a>02256         <span class="keyword">const</span> std::map&lt;<span class="keywordtype">unsigned</span><span class="comment">/*regnum*/</span>,<span class="keywordtype">unsigned</span><span class="comment">/*count*/</span>&gt; &amp;warp_info = w-&gt;second;
<a name="l02257"></a>02257         <span class="keywordflow">if</span>( warp_info.empty() ) 
<a name="l02258"></a>02258             <span class="keywordflow">continue</span>;
<a name="l02259"></a>02259         fprintf(fout,<span class="stringliteral">&quot;  w%2u : &quot;</span>, warp_id );
<a name="l02260"></a>02260         std::map&lt;<span class="keywordtype">unsigned</span><span class="comment">/*regnum*/</span>,<span class="keywordtype">unsigned</span><span class="comment">/*count*/</span>&gt;::const_iterator r;
<a name="l02261"></a>02261         <span class="keywordflow">for</span>( r=warp_info.begin(); r!=warp_info.end(); ++r ) {
<a name="l02262"></a>02262             fprintf(fout,<span class="stringliteral">&quot;  %u(%u)&quot;</span>, r-&gt;first, r-&gt;second );
<a name="l02263"></a>02263         }
<a name="l02264"></a>02264         fprintf(fout,<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02265"></a>02265     }
<a name="l02266"></a>02266     <a class="code" href="classldst__unit.html#a22126652fa2f4b074e54065fc1bf0e73">m_L1C</a>-&gt;<a class="code" href="classbaseline__cache.html#a09f1f92f49e7976978fbd0acc20e1948">display_state</a>(fout);
<a name="l02267"></a>02267     <a class="code" href="classldst__unit.html#aac01b4330f6596459192bbe09b7aba8f">m_L1T</a>-&gt;<a class="code" href="classtex__cache.html#afa1a85149329fa95b87db69ea8b2a4ff">display_state</a>(fout);
<a name="l02268"></a>02268     <span class="keywordflow">if</span>( !<a class="code" href="classsimd__function__unit.html#a398a2a0d2e52ca4beb15ef5e9ccb4c61">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a4068e626fdfc6e4b44a8fdd656a44b94">m_L1D_config</a>.<a class="code" href="classcache__config.html#a6e719909c6b7bea759a1d98bc49236b3">disabled</a>() )
<a name="l02269"></a>02269         <a class="code" href="classldst__unit.html#ac96de3512e64b5526049ede4d3aef42c">m_L1D</a>-&gt;<a class="code" href="classbaseline__cache.html#a09f1f92f49e7976978fbd0acc20e1948">display_state</a>(fout);
<a name="l02270"></a>02270     fprintf(fout,<span class="stringliteral">&quot;LD/ST response FIFO (occupancy = %zu):\n&quot;</span>, <a class="code" href="classldst__unit.html#a56ec0edb13afbb6454646012bbda37e2">m_response_fifo</a>.size() );
<a name="l02271"></a>02271     <span class="keywordflow">for</span>( std::list&lt;mem_fetch*&gt;::const_iterator i=<a class="code" href="classldst__unit.html#a56ec0edb13afbb6454646012bbda37e2">m_response_fifo</a>.begin(); i != <a class="code" href="classldst__unit.html#a56ec0edb13afbb6454646012bbda37e2">m_response_fifo</a>.end(); i++ ) {
<a name="l02272"></a>02272         <span class="keyword">const</span> <a class="code" href="classmem__fetch.html">mem_fetch</a> *mf = *i;
<a name="l02273"></a>02273         mf-&gt;<a class="code" href="classmem__fetch.html#a604c79db27d4ce4e6d83d76db53ce00e">print</a>(fout);
<a name="l02274"></a>02274     }
<a name="l02275"></a>02275 }
<a name="l02276"></a>02276 
<a name="l02277"></a><a class="code" href="classshader__core__ctx.html#a8e58be74671cfdc92a493fcdd84ab5e3">02277</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#a8e58be74671cfdc92a493fcdd84ab5e3">shader_core_ctx::display_pipeline</a>(FILE *fout, <span class="keywordtype">int</span> print_mem, <span class="keywordtype">int</span> mask )<span class="keyword"> const</span>
<a name="l02278"></a>02278 <span class="keyword"></span>{
<a name="l02279"></a>02279    fprintf(fout, <span class="stringliteral">&quot;=================================================\n&quot;</span>);
<a name="l02280"></a>02280    fprintf(fout, <span class="stringliteral">&quot;shader %u at cycle %Lu+%Lu (%u threads running)\n&quot;</span>, <a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>, 
<a name="l02281"></a>02281            <a class="code" href="gpu-sim_8cc.html#acef6bbfd6ec09fe29e2641cace785058">gpu_tot_sim_cycle</a>, <a class="code" href="gpu-sim_8cc.html#a659fec271553d05e676c52314c8fcfe1">gpu_sim_cycle</a>, <a class="code" href="classshader__core__ctx.html#a7e78acc4c95880eff06c9afcb65f62d0">m_not_completed</a>);
<a name="l02282"></a>02282    fprintf(fout, <span class="stringliteral">&quot;=================================================\n&quot;</span>);
<a name="l02283"></a>02283 
<a name="l02284"></a>02284    <a class="code" href="classshader__core__ctx.html#a71c39928f73c532b5c6e74f9a52263ba">dump_warp_state</a>(fout);
<a name="l02285"></a>02285    fprintf(fout,<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02286"></a>02286 
<a name="l02287"></a>02287    <a class="code" href="classshader__core__ctx.html#ab4e5da01591cc8c202069addf3afad1c">m_L1I</a>-&gt;<a class="code" href="classbaseline__cache.html#a09f1f92f49e7976978fbd0acc20e1948">display_state</a>(fout);
<a name="l02288"></a>02288 
<a name="l02289"></a>02289    fprintf(fout, <span class="stringliteral">&quot;IF/ID       = &quot;</span>);
<a name="l02290"></a>02290    <span class="keywordflow">if</span>( !<a class="code" href="classshader__core__ctx.html#ad8587963973cf67d7b495a057ddd698b">m_inst_fetch_buffer</a>.<a class="code" href="structifetch__buffer__t.html#a6b997d8b8afe0fbc2e24dc35dcd6c886">m_valid</a> )
<a name="l02291"></a>02291        fprintf(fout,<span class="stringliteral">&quot;bubble\n&quot;</span>);
<a name="l02292"></a>02292    <span class="keywordflow">else</span> {
<a name="l02293"></a>02293        fprintf(fout,<span class="stringliteral">&quot;w%2u : pc = 0x%x, nbytes = %u\n&quot;</span>, 
<a name="l02294"></a>02294                <a class="code" href="classshader__core__ctx.html#ad8587963973cf67d7b495a057ddd698b">m_inst_fetch_buffer</a>.<a class="code" href="structifetch__buffer__t.html#a9c3251c9b9be09045f330591f4ea09c1">m_warp_id</a>,
<a name="l02295"></a>02295                <a class="code" href="classshader__core__ctx.html#ad8587963973cf67d7b495a057ddd698b">m_inst_fetch_buffer</a>.<a class="code" href="structifetch__buffer__t.html#a10d5ec4a713ba62f1fa0b20aa1e6e8c8">m_pc</a>, 
<a name="l02296"></a>02296                <a class="code" href="classshader__core__ctx.html#ad8587963973cf67d7b495a057ddd698b">m_inst_fetch_buffer</a>.<a class="code" href="structifetch__buffer__t.html#a533927f0b0f398f2047cff8c8f259864">m_nbytes</a> );
<a name="l02297"></a>02297    }
<a name="l02298"></a>02298    fprintf(fout,<span class="stringliteral">&quot;\nibuffer status:\n&quot;</span>);
<a name="l02299"></a>02299    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i&lt;<a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a9cacf20235b1c230a4d99920fc4b577e">max_warps_per_shader</a>; i++) {
<a name="l02300"></a>02300        <span class="keywordflow">if</span>( !<a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[i].ibuffer_empty() ) 
<a name="l02301"></a>02301            <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[i].print_ibuffer(fout);
<a name="l02302"></a>02302    }
<a name="l02303"></a>02303    fprintf(fout,<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02304"></a>02304    <a class="code" href="classshader__core__ctx.html#aa93b5f4f123a61ebce0f07a8d3c5fc1d">display_simt_state</a>(fout,mask);
<a name="l02305"></a>02305    fprintf(fout, <span class="stringliteral">&quot;-------------------------- Scoreboard\n&quot;</span>);
<a name="l02306"></a>02306    <a class="code" href="classshader__core__ctx.html#aeeef0a2c13838c8d65a9614c2c7610f4">m_scoreboard</a>-&gt;<a class="code" href="classScoreboard.html#ae9eadc1b366713ab9590d7b1de6275db">printContents</a>();
<a name="l02307"></a>02307 <span class="comment">/*</span>
<a name="l02308"></a>02308 <span class="comment">   fprintf(fout,&quot;ID/OC (SP)  = &quot;);</span>
<a name="l02309"></a>02309 <span class="comment">   print_stage(ID_OC_SP, fout);</span>
<a name="l02310"></a>02310 <span class="comment">   fprintf(fout,&quot;ID/OC (SFU) = &quot;);</span>
<a name="l02311"></a>02311 <span class="comment">   print_stage(ID_OC_SFU, fout);</span>
<a name="l02312"></a>02312 <span class="comment">   fprintf(fout,&quot;ID/OC (MEM) = &quot;);</span>
<a name="l02313"></a>02313 <span class="comment">   print_stage(ID_OC_MEM, fout);</span>
<a name="l02314"></a>02314 <span class="comment">*/</span>
<a name="l02315"></a>02315    fprintf(fout, <span class="stringliteral">&quot;-------------------------- OP COL\n&quot;</span>);
<a name="l02316"></a>02316    <a class="code" href="classshader__core__ctx.html#aa8578f91af32b531ca48ccc31b440973">m_operand_collector</a>.<a class="code" href="classopndcoll__rfu__t.html#a644f00038d535e92da930beb68524ec1">dump</a>(fout);
<a name="l02317"></a>02317 <span class="comment">/* fprintf(fout, &quot;OC/EX (SP)  = &quot;);</span>
<a name="l02318"></a>02318 <span class="comment">   print_stage(OC_EX_SP, fout);</span>
<a name="l02319"></a>02319 <span class="comment">   fprintf(fout, &quot;OC/EX (SFU) = &quot;);</span>
<a name="l02320"></a>02320 <span class="comment">   print_stage(OC_EX_SFU, fout);</span>
<a name="l02321"></a>02321 <span class="comment">   fprintf(fout, &quot;OC/EX (MEM) = &quot;);</span>
<a name="l02322"></a>02322 <span class="comment">   print_stage(OC_EX_MEM, fout);</span>
<a name="l02323"></a>02323 <span class="comment">*/</span>
<a name="l02324"></a>02324    fprintf(fout, <span class="stringliteral">&quot;-------------------------- Pipe Regs\n&quot;</span>);
<a name="l02325"></a>02325 
<a name="l02326"></a>02326    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; <a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21af07130bf590c52f42ff38ade3eb03c28">N_PIPELINE_STAGES</a>; i++) {
<a name="l02327"></a>02327        fprintf(fout,<span class="stringliteral">&quot;--- %s ---\n&quot;</span>,<a class="code" href="shader_8h.html#ac28bf9e6cd1d215249a70a7a1fb5acc5">pipeline_stage_name_decode</a>[i]);
<a name="l02328"></a>02328        <a class="code" href="classshader__core__ctx.html#ada80589e61c463198aaffa2efc8e7150">print_stage</a>(i,fout);fprintf(fout,<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02329"></a>02329    }
<a name="l02330"></a>02330 
<a name="l02331"></a>02331    fprintf(fout, <span class="stringliteral">&quot;-------------------------- Fu\n&quot;</span>);
<a name="l02332"></a>02332    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <a class="code" href="rng_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>=0; <a class="code" href="rng_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a> &lt; <a class="code" href="classshader__core__ctx.html#aba08149bdd564b125968d3a754e2b000">m_num_function_units</a>; <a class="code" href="rng_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>++ ){
<a name="l02333"></a>02333        <a class="code" href="classshader__core__ctx.html#aac172c9e5d3c7dc27c45d09146fc8d0b">m_fu</a>[<a class="code" href="rng_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>]-&gt;print(fout);
<a name="l02334"></a>02334        fprintf(fout, <span class="stringliteral">&quot;---------------\n&quot;</span>);
<a name="l02335"></a>02335    }
<a name="l02336"></a>02336    fprintf(fout, <span class="stringliteral">&quot;-------------------------- other:\n&quot;</span>);
<a name="l02337"></a>02337 
<a name="l02338"></a>02338    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0; i&lt;<a class="code" href="classshader__core__ctx.html#af3d87025a8db5074483bd4d93e135e16">num_result_bus</a>; i++){
<a name="l02339"></a>02339        std::string bits = <a class="code" href="classshader__core__ctx.html#abe3ba763b1358db760c2dd1d55865763">m_result_bus</a>[i]-&gt;to_string();
<a name="l02340"></a>02340        fprintf(fout, <span class="stringliteral">&quot;EX/WB sched[%d]= %s\n&quot;</span>, i, bits.c_str() );
<a name="l02341"></a>02341    }
<a name="l02342"></a>02342    fprintf(fout, <span class="stringliteral">&quot;EX/WB      = &quot;</span>);
<a name="l02343"></a>02343    <a class="code" href="classshader__core__ctx.html#ada80589e61c463198aaffa2efc8e7150">print_stage</a>(<a class="code" href="shader_8h.html#a74caa8d53d99ca2bfd2f8765e5bcbe21a410f62d642cfe93d252e8faf55b89ea3">EX_WB</a>, fout);
<a name="l02344"></a>02344    fprintf(fout, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02345"></a>02345    fprintf(fout, <span class="stringliteral">&quot;Last EX/WB writeback @ %llu + %llu (gpu_sim_cycle+gpu_tot_sim_cycle)\n&quot;</span>,
<a name="l02346"></a>02346                  <a class="code" href="classshader__core__ctx.html#ab4becab0479eefe9e3bb7c97e63f9b27">m_last_inst_gpu_sim_cycle</a>, <a class="code" href="classshader__core__ctx.html#a663a5f525e11a9e5dce120d7976aa24c">m_last_inst_gpu_tot_sim_cycle</a> );
<a name="l02347"></a>02347 
<a name="l02348"></a>02348    <span class="keywordflow">if</span>( <a class="code" href="classshader__core__ctx.html#a75ddec0750ed9a01b1f429bf048b7e0e">m_active_threads</a>.count() &lt;= 2*<a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a> ) {
<a name="l02349"></a>02349        fprintf(fout,<span class="stringliteral">&quot;Active Threads : &quot;</span>);
<a name="l02350"></a>02350        <span class="keywordtype">unsigned</span> last_warp_id = -1;
<a name="l02351"></a>02351        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> tid=0; tid &lt; <a class="code" href="classshader__core__ctx.html#a75ddec0750ed9a01b1f429bf048b7e0e">m_active_threads</a>.size(); tid++ ) {
<a name="l02352"></a>02352            <span class="keywordtype">unsigned</span> warp_id = tid/<a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>;
<a name="l02353"></a>02353            <span class="keywordflow">if</span>( <a class="code" href="classshader__core__ctx.html#a75ddec0750ed9a01b1f429bf048b7e0e">m_active_threads</a>.test(tid) ) {
<a name="l02354"></a>02354                <span class="keywordflow">if</span>( warp_id != last_warp_id ) {
<a name="l02355"></a>02355                    fprintf(fout,<span class="stringliteral">&quot;\n  warp %u : &quot;</span>, warp_id );
<a name="l02356"></a>02356                    last_warp_id=warp_id;
<a name="l02357"></a>02357                }
<a name="l02358"></a>02358                fprintf(fout,<span class="stringliteral">&quot;%u &quot;</span>, tid );
<a name="l02359"></a>02359            }
<a name="l02360"></a>02360        }
<a name="l02361"></a>02361    }
<a name="l02362"></a>02362 
<a name="l02363"></a>02363 }
<a name="l02364"></a>02364 
<a name="l02365"></a><a class="code" href="structshader__core__config.html#af5142cb9479ef1fb1b429c88dc96254b">02365</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structshader__core__config.html#af5142cb9479ef1fb1b429c88dc96254b">shader_core_config::max_cta</a>( <span class="keyword">const</span> <a class="code" href="classkernel__info__t.html">kernel_info_t</a> &amp;k )<span class="keyword"> const</span>
<a name="l02366"></a>02366 <span class="keyword"></span>{
<a name="l02367"></a>02367    <span class="keywordtype">unsigned</span> threads_per_cta  = k.<a class="code" href="classkernel__info__t.html#a7764459a63b3dd279dfb07576a1dc718">threads_per_cta</a>();
<a name="l02368"></a>02368    <span class="keyword">const</span> <span class="keyword">class </span><a class="code" href="classfunction__info.html">function_info</a> *kernel = k.<a class="code" href="classkernel__info__t.html#aba475239cb9951ac6db8e03714e1f525">entry</a>();
<a name="l02369"></a>02369    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> padded_cta_size = threads_per_cta;
<a name="l02370"></a>02370    <span class="keywordflow">if</span> (padded_cta_size%<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>) 
<a name="l02371"></a>02371       padded_cta_size = ((padded_cta_size/warp_size)+1)*(warp_size);
<a name="l02372"></a>02372 
<a name="l02373"></a>02373    <span class="comment">//Limit by n_threads/shader</span>
<a name="l02374"></a>02374    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> result_thread = <a class="code" href="structshader__core__config.html#a559092b8eaeffafe04a61f83cefe74d2">n_thread_per_shader</a> / padded_cta_size;
<a name="l02375"></a>02375 
<a name="l02376"></a>02376    <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structgpgpu__ptx__sim__kernel__info.html">gpgpu_ptx_sim_kernel_info</a> *kernel_info = <a class="code" href="cuda-sim_8cc.html#adc38bc5eba0a6095f019d90d715fb1cc">ptx_sim_kernel_info</a>(kernel);
<a name="l02377"></a>02377 
<a name="l02378"></a>02378    <span class="comment">//Limit by shmem/shader</span>
<a name="l02379"></a>02379    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> result_shmem = (unsigned)-1;
<a name="l02380"></a>02380    <span class="keywordflow">if</span> (kernel_info-&gt;<a class="code" href="structgpgpu__ptx__sim__kernel__info.html#a50e63c7e0a55da4c388bc97a960b6887">smem</a> &gt; 0)
<a name="l02381"></a>02381       result_shmem = <a class="code" href="structcore__config.html#a09a8494f780facd68295a6a869c14bf7">gpgpu_shmem_size</a> / kernel_info-&gt;<a class="code" href="structgpgpu__ptx__sim__kernel__info.html#a50e63c7e0a55da4c388bc97a960b6887">smem</a>;
<a name="l02382"></a>02382 
<a name="l02383"></a>02383    <span class="comment">//Limit by register count, rounded up to multiple of 4.</span>
<a name="l02384"></a>02384    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> result_regs = (unsigned)-1;
<a name="l02385"></a>02385    <span class="keywordflow">if</span> (kernel_info-&gt;<a class="code" href="structgpgpu__ptx__sim__kernel__info.html#a631651e9205d73a33c6df4678a5c7453">regs</a> &gt; 0)
<a name="l02386"></a>02386       result_regs = <a class="code" href="structshader__core__config.html#ae0f353aa55143f981ac3251e374ba66d">gpgpu_shader_registers</a> / (padded_cta_size * ((kernel_info-&gt;<a class="code" href="structgpgpu__ptx__sim__kernel__info.html#a631651e9205d73a33c6df4678a5c7453">regs</a>+3)&amp;~3));
<a name="l02387"></a>02387 
<a name="l02388"></a>02388    <span class="comment">//Limit by CTA</span>
<a name="l02389"></a>02389    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> result_cta = <a class="code" href="structshader__core__config.html#a2479f7601343394209f403231c69378b">max_cta_per_core</a>;
<a name="l02390"></a>02390 
<a name="l02391"></a>02391    <span class="keywordtype">unsigned</span> result = result_thread;
<a name="l02392"></a>02392    result = gs_min2(result, result_shmem);
<a name="l02393"></a>02393    result = gs_min2(result, result_regs);
<a name="l02394"></a>02394    result = gs_min2(result, result_cta);
<a name="l02395"></a>02395 
<a name="l02396"></a>02396    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structgpgpu__ptx__sim__kernel__info.html">gpgpu_ptx_sim_kernel_info</a>* last_kinfo = NULL;
<a name="l02397"></a>02397    <span class="keywordflow">if</span> (last_kinfo != kernel_info) {   <span class="comment">//Only print out stats if kernel_info struct changes</span>
<a name="l02398"></a>02398       last_kinfo = kernel_info;
<a name="l02399"></a>02399       printf (<span class="stringliteral">&quot;GPGPU-Sim uArch: CTA/core = %u, limited by:&quot;</span>, result);
<a name="l02400"></a>02400       <span class="keywordflow">if</span> (result == result_thread) printf (<span class="stringliteral">&quot; threads&quot;</span>);
<a name="l02401"></a>02401       <span class="keywordflow">if</span> (result == result_shmem) printf (<span class="stringliteral">&quot; shmem&quot;</span>);
<a name="l02402"></a>02402       <span class="keywordflow">if</span> (result == result_regs) printf (<span class="stringliteral">&quot; regs&quot;</span>);
<a name="l02403"></a>02403       <span class="keywordflow">if</span> (result == result_cta) printf (<span class="stringliteral">&quot; cta_limit&quot;</span>);
<a name="l02404"></a>02404       printf (<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02405"></a>02405    }
<a name="l02406"></a>02406 
<a name="l02407"></a>02407     <span class="comment">//gpu_max_cta_per_shader is limited by number of CTAs if not enough to keep all cores busy    </span>
<a name="l02408"></a>02408     <span class="keywordflow">if</span>( k.<a class="code" href="classkernel__info__t.html#ae8bbbec46d872dfd1998934ef86ddbaa">num_blocks</a>() &lt; result*<a class="code" href="structshader__core__config.html#a30949c72f2ebab12287ca4e801dc0b49">num_shader</a>() ) { 
<a name="l02409"></a>02409        result = k.<a class="code" href="classkernel__info__t.html#ae8bbbec46d872dfd1998934ef86ddbaa">num_blocks</a>() / <a class="code" href="structshader__core__config.html#a30949c72f2ebab12287ca4e801dc0b49">num_shader</a>();
<a name="l02410"></a>02410        <span class="keywordflow">if</span> (k.<a class="code" href="classkernel__info__t.html#ae8bbbec46d872dfd1998934ef86ddbaa">num_blocks</a>() % <a class="code" href="structshader__core__config.html#a30949c72f2ebab12287ca4e801dc0b49">num_shader</a>())
<a name="l02411"></a>02411           result++;
<a name="l02412"></a>02412     }
<a name="l02413"></a>02413 
<a name="l02414"></a>02414     assert( result &lt;= MAX_CTA_PER_SHADER );
<a name="l02415"></a>02415     <span class="keywordflow">if</span> (result &lt; 1) {
<a name="l02416"></a>02416        printf (<span class="stringliteral">&quot;GPGPU-Sim uArch: ERROR ** Kernel requires more resources than shader has.\n&quot;</span>);
<a name="l02417"></a>02417        abort();
<a name="l02418"></a>02418     }
<a name="l02419"></a>02419 
<a name="l02420"></a>02420     <span class="keywordflow">return</span> result;
<a name="l02421"></a>02421 }
<a name="l02422"></a>02422 
<a name="l02423"></a><a class="code" href="classshader__core__ctx.html#aa890a6df3b96a815cb62448fd28409c6">02423</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#aa890a6df3b96a815cb62448fd28409c6">shader_core_ctx::cycle</a>()
<a name="l02424"></a>02424 {
<a name="l02425"></a>02425     <a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#ab037bfddbfccebd79a9ac5840b27576a">shader_cycles</a>[<a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>]++;
<a name="l02426"></a>02426     <a class="code" href="classshader__core__ctx.html#a3aac655e71bf63ca2d0369b553976e32">writeback</a>();
<a name="l02427"></a>02427     <a class="code" href="classshader__core__ctx.html#a523f6439287036297d49d1dcc847d2d9">execute</a>();
<a name="l02428"></a>02428     <a class="code" href="classshader__core__ctx.html#a50ad3c0923e18df0e704ef91da6eb9e1">read_operands</a>();
<a name="l02429"></a>02429     <a class="code" href="classshader__core__ctx.html#a70f3500c956d0ce2fc3fd122880aa662">issue</a>();
<a name="l02430"></a>02430     <a class="code" href="classshader__core__ctx.html#ac9e24aa89f4c2a7a7902d562ba102c99">decode</a>();
<a name="l02431"></a>02431     <a class="code" href="classshader__core__ctx.html#a441aca930d85ca6a169ea0e1ed60daa4">fetch</a>();
<a name="l02432"></a>02432 }
<a name="l02433"></a>02433 
<a name="l02434"></a>02434 <span class="comment">// Flushes all content of the cache to memory</span>
<a name="l02435"></a>02435 
<a name="l02436"></a><a class="code" href="classshader__core__ctx.html#ac071bf830f9a15b627c46d3e29ff13d6">02436</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#ac071bf830f9a15b627c46d3e29ff13d6">shader_core_ctx::cache_flush</a>()
<a name="l02437"></a>02437 {
<a name="l02438"></a>02438    <a class="code" href="classshader__core__ctx.html#a11facb48161a3079025f0602e276969b">m_ldst_unit</a>-&gt;<a class="code" href="classldst__unit.html#a76f91783e5b63f626a4240e0507e8792">flush</a>();
<a name="l02439"></a>02439 }
<a name="l02440"></a>02440 
<a name="l02441"></a>02441 <span class="comment">// modifiers</span>
<a name="l02442"></a><a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#ab3986ca2a1c2152b898bf804a8295962">02442</a> std::list&lt;opndcoll_rfu_t::op_t&gt; <a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#ab3986ca2a1c2152b898bf804a8295962">opndcoll_rfu_t::arbiter_t::allocate_reads</a>() 
<a name="l02443"></a>02443 {
<a name="l02444"></a>02444    std::list&lt;op_t&gt; result;  <span class="comment">// a list of registers that (a) are in different register banks, (b) do not go to the same operand collector</span>
<a name="l02445"></a>02445 
<a name="l02446"></a>02446    <span class="keywordtype">int</span> <a class="code" href="lex_8yy_8c.html#a171692544b8e065853e387755849a433">input</a>;
<a name="l02447"></a>02447    <span class="keywordtype">int</span> <a class="code" href="cuobjdump__to__ptxplus_8cc.html#a850af8cfb632548b213ce5b365fedd1a">output</a>;
<a name="l02448"></a>02448    <span class="keywordtype">int</span> _inputs = <a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#a6b9f9d69af47f4ed4d49a4b2e08937e6">m_num_banks</a>;
<a name="l02449"></a>02449    <span class="keywordtype">int</span> _outputs = <a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#a40f1871aa5695084d7b1959a2f437f4e">m_num_collectors</a>;
<a name="l02450"></a>02450    <span class="keywordtype">int</span> _square = ( _inputs &gt; _outputs ) ? _inputs : _outputs;
<a name="l02451"></a>02451    assert(_square &gt; 0);
<a name="l02452"></a>02452    <span class="keywordtype">int</span> _pri = (<a class="code" href="classint.html">int</a>)<a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#a831f63385781e34ac2a37cdd228700d0">m_last_cu</a>;
<a name="l02453"></a>02453 
<a name="l02454"></a>02454    <span class="comment">// Clear matching</span>
<a name="l02455"></a>02455    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; _inputs; ++i ) 
<a name="l02456"></a>02456       <a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#a35493df6f954385c274e67b28e6ee44e">_inmatch</a>[i] = -1;
<a name="l02457"></a>02457    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> j = 0; j &lt; _outputs; ++j ) 
<a name="l02458"></a>02458       <a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#a372f9e1c59fd6202e7b5d49fd36d39d5">_outmatch</a>[j] = -1;
<a name="l02459"></a>02459 
<a name="l02460"></a>02460    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i&lt;<a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#a6b9f9d69af47f4ed4d49a4b2e08937e6">m_num_banks</a>; i++) {
<a name="l02461"></a>02461       <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> j=0; j&lt;<a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#a40f1871aa5695084d7b1959a2f437f4e">m_num_collectors</a>; j++) {
<a name="l02462"></a>02462          assert( i &lt; (<span class="keywordtype">unsigned</span>)_inputs );
<a name="l02463"></a>02463          assert( j &lt; (<span class="keywordtype">unsigned</span>)_outputs );
<a name="l02464"></a>02464          <a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#ada3d37161a549463344b113a67d56434">_request</a>[i][j] = 0;
<a name="l02465"></a>02465       }
<a name="l02466"></a>02466       <span class="keywordflow">if</span>( !<a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#a50e6c01bb43b29d14bf4c020768fe634">m_queue</a>[i].empty() ) {
<a name="l02467"></a>02467          <span class="keyword">const</span> <a class="code" href="classopndcoll__rfu__t_1_1op__t.html">op_t</a> &amp;op = <a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#a50e6c01bb43b29d14bf4c020768fe634">m_queue</a>[i].front();
<a name="l02468"></a>02468          <span class="keywordtype">int</span> oc_id = op.<a class="code" href="classopndcoll__rfu__t_1_1op__t.html#abfcf6e681bd6e0aad650d215496a0a34">get_oc_id</a>();
<a name="l02469"></a>02469          assert( i &lt; (<span class="keywordtype">unsigned</span>)_inputs );
<a name="l02470"></a>02470          assert( oc_id &lt; _outputs );
<a name="l02471"></a>02471          <a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#ada3d37161a549463344b113a67d56434">_request</a>[i][oc_id] = 1;
<a name="l02472"></a>02472       }
<a name="l02473"></a>02473       <span class="keywordflow">if</span>( <a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#abf9e61cade94ef6285e5a4437a86f923">m_allocated_bank</a>[i].is_write() ) {
<a name="l02474"></a>02474          assert( i &lt; (<span class="keywordtype">unsigned</span>)_inputs );
<a name="l02475"></a>02475          <a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#a35493df6f954385c274e67b28e6ee44e">_inmatch</a>[i] = 0; <span class="comment">// write gets priority</span>
<a name="l02476"></a>02476       }
<a name="l02477"></a>02477    }
<a name="l02478"></a>02478 
<a name="l02480"></a>02480    
<a name="l02481"></a>02481    <span class="comment">// Loop through diagonals of request matrix</span>
<a name="l02482"></a>02482 
<a name="l02483"></a>02483    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> p = 0; p &lt; _square; ++p ) {
<a name="l02484"></a>02484       output = ( _pri + p ) % _square;
<a name="l02485"></a>02485 
<a name="l02486"></a>02486       <span class="comment">// Step through the current diagonal</span>
<a name="l02487"></a>02487       <span class="keywordflow">for</span> ( input = 0; input &lt; _inputs; ++input ) {
<a name="l02488"></a>02488           assert( input &lt; _inputs );
<a name="l02489"></a>02489           assert( output &lt; _outputs );
<a name="l02490"></a>02490          <span class="keywordflow">if</span> ( ( output &lt; _outputs ) &amp;&amp; 
<a name="l02491"></a>02491               ( <a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#a35493df6f954385c274e67b28e6ee44e">_inmatch</a>[input] == -1 ) &amp;&amp; 
<a name="l02492"></a>02492               ( <a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#a372f9e1c59fd6202e7b5d49fd36d39d5">_outmatch</a>[output] == -1 ) &amp;&amp;
<a name="l02493"></a>02493               ( <a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#ada3d37161a549463344b113a67d56434">_request</a>[input][output]<span class="comment">/*.label != -1*/</span> ) ) {
<a name="l02494"></a>02494             <span class="comment">// Grant!</span>
<a name="l02495"></a>02495             <a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#a35493df6f954385c274e67b28e6ee44e">_inmatch</a>[input] = output;
<a name="l02496"></a>02496             <a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#a372f9e1c59fd6202e7b5d49fd36d39d5">_outmatch</a>[output] = input;
<a name="l02497"></a>02497          }
<a name="l02498"></a>02498 
<a name="l02499"></a>02499          output = ( output + 1 ) % _square;
<a name="l02500"></a>02500       }
<a name="l02501"></a>02501    }
<a name="l02502"></a>02502 
<a name="l02503"></a>02503    <span class="comment">// Round-robin the priority diagonal</span>
<a name="l02504"></a>02504    _pri = ( _pri + 1 ) % _square;
<a name="l02505"></a>02505 
<a name="l02507"></a>02507 
<a name="l02508"></a>02508    <a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#a831f63385781e34ac2a37cdd228700d0">m_last_cu</a> = _pri;
<a name="l02509"></a>02509    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i &lt; m_num_banks; i++ ) {
<a name="l02510"></a>02510       <span class="keywordflow">if</span>( <a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#a35493df6f954385c274e67b28e6ee44e">_inmatch</a>[i] != -1 ) {
<a name="l02511"></a>02511          <span class="keywordflow">if</span>( !<a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#abf9e61cade94ef6285e5a4437a86f923">m_allocated_bank</a>[i].is_write() ) {
<a name="l02512"></a>02512             <span class="keywordtype">unsigned</span> bank = (unsigned)i;
<a name="l02513"></a>02513             <a class="code" href="classopndcoll__rfu__t_1_1op__t.html">op_t</a> &amp;op = <a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#a50e6c01bb43b29d14bf4c020768fe634">m_queue</a>[bank].front();
<a name="l02514"></a>02514             result.push_back(op);
<a name="l02515"></a>02515             <a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#a50e6c01bb43b29d14bf4c020768fe634">m_queue</a>[bank].pop_front();
<a name="l02516"></a>02516          }
<a name="l02517"></a>02517       }
<a name="l02518"></a>02518    }
<a name="l02519"></a>02519 
<a name="l02520"></a>02520    <span class="keywordflow">return</span> result;
<a name="l02521"></a>02521 }
<a name="l02522"></a>02522 
<a name="l02523"></a><a class="code" href="classbarrier__set__t.html#abc1679612e6a957f089324f96e52fa07">02523</a> <a class="code" href="classbarrier__set__t.html#abc1679612e6a957f089324f96e52fa07">barrier_set_t::barrier_set_t</a>( <span class="keywordtype">unsigned</span> max_warps_per_core, <span class="keywordtype">unsigned</span> max_cta_per_core )
<a name="l02524"></a>02524 {
<a name="l02525"></a>02525    <a class="code" href="classbarrier__set__t.html#a02805de6de7996a48e11917bb502c641">m_max_warps_per_core</a> = max_warps_per_core;
<a name="l02526"></a>02526    <a class="code" href="classbarrier__set__t.html#ac9e4712c691bdab7f78d3fd68406a369">m_max_cta_per_core</a> = max_cta_per_core;
<a name="l02527"></a>02527    <span class="keywordflow">if</span>( max_warps_per_core &gt; <a class="code" href="shader_8h.html#ab00d91514c28be69a06a14b543a550ad">WARP_PER_CTA_MAX</a> ) {
<a name="l02528"></a>02528       printf(<span class="stringliteral">&quot;ERROR ** increase WARP_PER_CTA_MAX in shader.h from %u to &gt;= %u or warps per cta in gpgpusim.config\n&quot;</span>,
<a name="l02529"></a>02529              <a class="code" href="shader_8h.html#ab00d91514c28be69a06a14b543a550ad">WARP_PER_CTA_MAX</a>, max_warps_per_core );
<a name="l02530"></a>02530       exit(1);
<a name="l02531"></a>02531    }
<a name="l02532"></a>02532    <a class="code" href="classbarrier__set__t.html#aefdd32d8df61c4b134689390e8854703">m_warp_active</a>.reset();
<a name="l02533"></a>02533    <a class="code" href="classbarrier__set__t.html#aa30825e2b0c54b64ce02b7f967252ef6">m_warp_at_barrier</a>.reset();
<a name="l02534"></a>02534 }
<a name="l02535"></a>02535 
<a name="l02536"></a>02536 <span class="comment">// during cta allocation</span>
<a name="l02537"></a><a class="code" href="classbarrier__set__t.html#a64b414a450f728db3c39f7f0ea9e203e">02537</a> <span class="keywordtype">void</span> <a class="code" href="classbarrier__set__t.html#a64b414a450f728db3c39f7f0ea9e203e">barrier_set_t::allocate_barrier</a>( <span class="keywordtype">unsigned</span> cta_id, <a class="code" href="shader_8h.html#af7aedb40da16c61f2a7600189ba7798a">warp_set_t</a> warps )
<a name="l02538"></a>02538 {
<a name="l02539"></a>02539    assert( cta_id &lt; <a class="code" href="classbarrier__set__t.html#ac9e4712c691bdab7f78d3fd68406a369">m_max_cta_per_core</a> );
<a name="l02540"></a>02540    cta_to_warp_t::iterator w=<a class="code" href="classbarrier__set__t.html#a9d4f49867b96d67eaad9e4943a627eac">m_cta_to_warps</a>.find(cta_id);
<a name="l02541"></a>02541    assert( w == <a class="code" href="classbarrier__set__t.html#a9d4f49867b96d67eaad9e4943a627eac">m_cta_to_warps</a>.end() ); <span class="comment">// cta should not already be active or allocated barrier resources</span>
<a name="l02542"></a>02542    <a class="code" href="classbarrier__set__t.html#a9d4f49867b96d67eaad9e4943a627eac">m_cta_to_warps</a>[cta_id] = warps;
<a name="l02543"></a>02543    assert( m_cta_to_warps.size() &lt;= <a class="code" href="classbarrier__set__t.html#ac9e4712c691bdab7f78d3fd68406a369">m_max_cta_per_core</a> ); <span class="comment">// catch cta&apos;s that were not properly deallocated</span>
<a name="l02544"></a>02544   
<a name="l02545"></a>02545    <a class="code" href="classbarrier__set__t.html#aefdd32d8df61c4b134689390e8854703">m_warp_active</a> |= warps;
<a name="l02546"></a>02546    <a class="code" href="classbarrier__set__t.html#aa30825e2b0c54b64ce02b7f967252ef6">m_warp_at_barrier</a> &amp;= ~warps;
<a name="l02547"></a>02547 }
<a name="l02548"></a>02548 
<a name="l02549"></a>02549 <span class="comment">// during cta deallocation</span>
<a name="l02550"></a><a class="code" href="classbarrier__set__t.html#abb04291e7936dc009b0b885b1467951e">02550</a> <span class="keywordtype">void</span> <a class="code" href="classbarrier__set__t.html#abb04291e7936dc009b0b885b1467951e">barrier_set_t::deallocate_barrier</a>( <span class="keywordtype">unsigned</span> cta_id )
<a name="l02551"></a>02551 {
<a name="l02552"></a>02552    cta_to_warp_t::iterator w=<a class="code" href="classbarrier__set__t.html#a9d4f49867b96d67eaad9e4943a627eac">m_cta_to_warps</a>.find(cta_id);
<a name="l02553"></a>02553    <span class="keywordflow">if</span>( w == <a class="code" href="classbarrier__set__t.html#a9d4f49867b96d67eaad9e4943a627eac">m_cta_to_warps</a>.end() )
<a name="l02554"></a>02554       <span class="keywordflow">return</span>;
<a name="l02555"></a>02555    <a class="code" href="shader_8h.html#af7aedb40da16c61f2a7600189ba7798a">warp_set_t</a> warps = w-&gt;second;
<a name="l02556"></a>02556    <a class="code" href="shader_8h.html#af7aedb40da16c61f2a7600189ba7798a">warp_set_t</a> at_barrier = warps &amp; <a class="code" href="classbarrier__set__t.html#aa30825e2b0c54b64ce02b7f967252ef6">m_warp_at_barrier</a>;
<a name="l02557"></a>02557    assert( at_barrier.any() == false ); <span class="comment">// no warps stuck at barrier</span>
<a name="l02558"></a>02558    <a class="code" href="shader_8h.html#af7aedb40da16c61f2a7600189ba7798a">warp_set_t</a> active = warps &amp; <a class="code" href="classbarrier__set__t.html#aefdd32d8df61c4b134689390e8854703">m_warp_active</a>;
<a name="l02559"></a>02559    assert( active.any() == false ); <span class="comment">// no warps in CTA still running</span>
<a name="l02560"></a>02560    m_warp_active &amp;= ~warps;
<a name="l02561"></a>02561    m_warp_at_barrier &amp;= ~warps;
<a name="l02562"></a>02562    <a class="code" href="classbarrier__set__t.html#a9d4f49867b96d67eaad9e4943a627eac">m_cta_to_warps</a>.erase(w);
<a name="l02563"></a>02563 }
<a name="l02564"></a>02564 
<a name="l02565"></a>02565 <span class="comment">// individual warp hits barrier</span>
<a name="l02566"></a><a class="code" href="classbarrier__set__t.html#a4ad261ac60abddad5d03f849a32967c3">02566</a> <span class="keywordtype">void</span> <a class="code" href="classbarrier__set__t.html#a4ad261ac60abddad5d03f849a32967c3">barrier_set_t::warp_reaches_barrier</a>( <span class="keywordtype">unsigned</span> cta_id, <span class="keywordtype">unsigned</span> warp_id )
<a name="l02567"></a>02567 {
<a name="l02568"></a>02568    cta_to_warp_t::iterator w=<a class="code" href="classbarrier__set__t.html#a9d4f49867b96d67eaad9e4943a627eac">m_cta_to_warps</a>.find(cta_id);
<a name="l02569"></a>02569 
<a name="l02570"></a>02570    <span class="keywordflow">if</span>( w == <a class="code" href="classbarrier__set__t.html#a9d4f49867b96d67eaad9e4943a627eac">m_cta_to_warps</a>.end() ) { <span class="comment">// cta is active</span>
<a name="l02571"></a>02571       printf(<span class="stringliteral">&quot;ERROR ** cta_id %u not found in barrier set on cycle %llu+%llu...\n&quot;</span>, cta_id, <a class="code" href="gpu-sim_8cc.html#acef6bbfd6ec09fe29e2641cace785058">gpu_tot_sim_cycle</a>, <a class="code" href="gpu-sim_8cc.html#a659fec271553d05e676c52314c8fcfe1">gpu_sim_cycle</a> );
<a name="l02572"></a>02572       <a class="code" href="classbarrier__set__t.html#a13240145943c9ccbe6ecef798e8bc492">dump</a>();
<a name="l02573"></a>02573       abort();
<a name="l02574"></a>02574    }
<a name="l02575"></a>02575    assert( w-&gt;second.test(warp_id) == true ); <span class="comment">// warp is in cta</span>
<a name="l02576"></a>02576 
<a name="l02577"></a>02577    <a class="code" href="classbarrier__set__t.html#aa30825e2b0c54b64ce02b7f967252ef6">m_warp_at_barrier</a>.set(warp_id);
<a name="l02578"></a>02578 
<a name="l02579"></a>02579    <a class="code" href="shader_8h.html#af7aedb40da16c61f2a7600189ba7798a">warp_set_t</a> warps_in_cta = w-&gt;second;
<a name="l02580"></a>02580    <a class="code" href="shader_8h.html#af7aedb40da16c61f2a7600189ba7798a">warp_set_t</a> at_barrier = warps_in_cta &amp; <a class="code" href="classbarrier__set__t.html#aa30825e2b0c54b64ce02b7f967252ef6">m_warp_at_barrier</a>;
<a name="l02581"></a>02581    <a class="code" href="shader_8h.html#af7aedb40da16c61f2a7600189ba7798a">warp_set_t</a> active = warps_in_cta &amp; <a class="code" href="classbarrier__set__t.html#aefdd32d8df61c4b134689390e8854703">m_warp_active</a>;
<a name="l02582"></a>02582 
<a name="l02583"></a>02583    <span class="keywordflow">if</span>( at_barrier == active ) {
<a name="l02584"></a>02584       <span class="comment">// all warps have reached barrier, so release waiting warps...</span>
<a name="l02585"></a>02585       m_warp_at_barrier &amp;= ~at_barrier;
<a name="l02586"></a>02586    }
<a name="l02587"></a>02587 }
<a name="l02588"></a>02588 
<a name="l02589"></a>02589 <span class="comment">// fetching a warp</span>
<a name="l02590"></a><a class="code" href="classbarrier__set__t.html#af0738555cf8df472862fdd4ece2c8b59">02590</a> <span class="keywordtype">bool</span> <a class="code" href="classbarrier__set__t.html#af0738555cf8df472862fdd4ece2c8b59">barrier_set_t::available_for_fetch</a>( <span class="keywordtype">unsigned</span> warp_id )<span class="keyword"> const</span>
<a name="l02591"></a>02591 <span class="keyword"></span>{
<a name="l02592"></a>02592    <span class="keywordflow">return</span> <a class="code" href="classbarrier__set__t.html#aefdd32d8df61c4b134689390e8854703">m_warp_active</a>.test(warp_id) &amp;&amp; <a class="code" href="classbarrier__set__t.html#aa30825e2b0c54b64ce02b7f967252ef6">m_warp_at_barrier</a>.test(warp_id);
<a name="l02593"></a>02593 }
<a name="l02594"></a>02594 
<a name="l02595"></a>02595 <span class="comment">// warp reaches exit </span>
<a name="l02596"></a><a class="code" href="classbarrier__set__t.html#a6ef5a4a8977c12c9a7cd15a8c95b11e7">02596</a> <span class="keywordtype">void</span> <a class="code" href="classbarrier__set__t.html#a6ef5a4a8977c12c9a7cd15a8c95b11e7">barrier_set_t::warp_exit</a>( <span class="keywordtype">unsigned</span> warp_id )
<a name="l02597"></a>02597 {
<a name="l02598"></a>02598    <span class="comment">// caller needs to verify all threads in warp are done, e.g., by checking PDOM stack to </span>
<a name="l02599"></a>02599    <span class="comment">// see it has only one entry during exit_impl()</span>
<a name="l02600"></a>02600    <a class="code" href="classbarrier__set__t.html#aefdd32d8df61c4b134689390e8854703">m_warp_active</a>.reset(warp_id);
<a name="l02601"></a>02601 
<a name="l02602"></a>02602    <span class="comment">// test for barrier release </span>
<a name="l02603"></a>02603    cta_to_warp_t::iterator w=<a class="code" href="classbarrier__set__t.html#a9d4f49867b96d67eaad9e4943a627eac">m_cta_to_warps</a>.begin(); 
<a name="l02604"></a>02604    <span class="keywordflow">for</span> (; w != <a class="code" href="classbarrier__set__t.html#a9d4f49867b96d67eaad9e4943a627eac">m_cta_to_warps</a>.end(); ++w) {
<a name="l02605"></a>02605       <span class="keywordflow">if</span> (w-&gt;second.test(warp_id) == <span class="keyword">true</span>) <span class="keywordflow">break</span>; 
<a name="l02606"></a>02606    }
<a name="l02607"></a>02607    <a class="code" href="shader_8h.html#af7aedb40da16c61f2a7600189ba7798a">warp_set_t</a> warps_in_cta = w-&gt;second;
<a name="l02608"></a>02608    <a class="code" href="shader_8h.html#af7aedb40da16c61f2a7600189ba7798a">warp_set_t</a> at_barrier = warps_in_cta &amp; <a class="code" href="classbarrier__set__t.html#aa30825e2b0c54b64ce02b7f967252ef6">m_warp_at_barrier</a>;
<a name="l02609"></a>02609    <a class="code" href="shader_8h.html#af7aedb40da16c61f2a7600189ba7798a">warp_set_t</a> active = warps_in_cta &amp; <a class="code" href="classbarrier__set__t.html#aefdd32d8df61c4b134689390e8854703">m_warp_active</a>;
<a name="l02610"></a>02610 
<a name="l02611"></a>02611    <span class="keywordflow">if</span>( at_barrier == active ) {
<a name="l02612"></a>02612       <span class="comment">// all warps have reached barrier, so release waiting warps...</span>
<a name="l02613"></a>02613       m_warp_at_barrier &amp;= ~at_barrier;
<a name="l02614"></a>02614    }
<a name="l02615"></a>02615 }
<a name="l02616"></a>02616 
<a name="l02617"></a>02617 <span class="comment">// assertions</span>
<a name="l02618"></a><a class="code" href="classbarrier__set__t.html#a1ac5ebbab8231971a2727432f40c37e7">02618</a> <span class="keywordtype">bool</span> <a class="code" href="classbarrier__set__t.html#a1ac5ebbab8231971a2727432f40c37e7">barrier_set_t::warp_waiting_at_barrier</a>( <span class="keywordtype">unsigned</span> warp_id )<span class="keyword"> const</span>
<a name="l02619"></a>02619 <span class="keyword"></span>{ 
<a name="l02620"></a>02620    <span class="keywordflow">return</span> <a class="code" href="classbarrier__set__t.html#aa30825e2b0c54b64ce02b7f967252ef6">m_warp_at_barrier</a>.test(warp_id);
<a name="l02621"></a>02621 }
<a name="l02622"></a>02622 
<a name="l02623"></a><a class="code" href="classbarrier__set__t.html#a13240145943c9ccbe6ecef798e8bc492">02623</a> <span class="keywordtype">void</span> <a class="code" href="classbarrier__set__t.html#a13240145943c9ccbe6ecef798e8bc492">barrier_set_t::dump</a>()<span class="keyword"> const</span>
<a name="l02624"></a>02624 <span class="keyword"></span>{
<a name="l02625"></a>02625    printf( <span class="stringliteral">&quot;barrier set information\n&quot;</span>);
<a name="l02626"></a>02626    printf( <span class="stringliteral">&quot;  m_max_cta_per_core = %u\n&quot;</span>,  <a class="code" href="classbarrier__set__t.html#ac9e4712c691bdab7f78d3fd68406a369">m_max_cta_per_core</a> );
<a name="l02627"></a>02627    printf( <span class="stringliteral">&quot;  m_max_warps_per_core = %u\n&quot;</span>, <a class="code" href="classbarrier__set__t.html#a02805de6de7996a48e11917bb502c641">m_max_warps_per_core</a> );
<a name="l02628"></a>02628    printf( <span class="stringliteral">&quot;  cta_to_warps:\n&quot;</span>);
<a name="l02629"></a>02629    
<a name="l02630"></a>02630    cta_to_warp_t::const_iterator i;
<a name="l02631"></a>02631    <span class="keywordflow">for</span>( i=<a class="code" href="classbarrier__set__t.html#a9d4f49867b96d67eaad9e4943a627eac">m_cta_to_warps</a>.begin(); i!=<a class="code" href="classbarrier__set__t.html#a9d4f49867b96d67eaad9e4943a627eac">m_cta_to_warps</a>.end(); i++ ) {
<a name="l02632"></a>02632       <span class="keywordtype">unsigned</span> cta_id = i-&gt;first;
<a name="l02633"></a>02633       <a class="code" href="shader_8h.html#af7aedb40da16c61f2a7600189ba7798a">warp_set_t</a> warps = i-&gt;second;
<a name="l02634"></a>02634       printf(<span class="stringliteral">&quot;    cta_id %u : %s\n&quot;</span>, cta_id, warps.to_string().c_str() );
<a name="l02635"></a>02635    }
<a name="l02636"></a>02636    printf(<span class="stringliteral">&quot;  warp_active: %s\n&quot;</span>, <a class="code" href="classbarrier__set__t.html#aefdd32d8df61c4b134689390e8854703">m_warp_active</a>.to_string().c_str() );
<a name="l02637"></a>02637    printf(<span class="stringliteral">&quot;  warp_at_barrier: %s\n&quot;</span>, <a class="code" href="classbarrier__set__t.html#aa30825e2b0c54b64ce02b7f967252ef6">m_warp_at_barrier</a>.to_string().c_str() );
<a name="l02638"></a>02638    fflush(stdout); 
<a name="l02639"></a>02639 }
<a name="l02640"></a>02640 
<a name="l02641"></a><a class="code" href="classshader__core__ctx.html#abea1a46d1b48d1d8aa2f2bbb3da3b0f9">02641</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#abea1a46d1b48d1d8aa2f2bbb3da3b0f9">shader_core_ctx::warp_exit</a>( <span class="keywordtype">unsigned</span> warp_id )
<a name="l02642"></a>02642 {
<a name="l02643"></a>02643     <span class="keywordtype">bool</span> done = <span class="keyword">true</span>;
<a name="l02644"></a>02644     <span class="keywordflow">for</span> (   <span class="keywordtype">unsigned</span> i = warp_id*<a class="code" href="classshader__core__ctx.html#a0dfa04be25f749a0a690843a13db0881">get_config</a>()-&gt;warp_size;
<a name="l02645"></a>02645             i &lt; (warp_id+1)*<a class="code" href="classshader__core__ctx.html#a0dfa04be25f749a0a690843a13db0881">get_config</a>()-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>;
<a name="l02646"></a>02646             i++ ) {
<a name="l02647"></a>02647 
<a name="l02648"></a>02648 <span class="comment">//      if(this-&gt;m_thread[i]-&gt;m_functional_model_thread_state &amp;&amp; this-&gt;m_thread[i].m_functional_model_thread_state-&gt;donecycle()==0) {</span>
<a name="l02649"></a>02649 <span class="comment">//          done = false;</span>
<a name="l02650"></a>02650 <span class="comment">//      }</span>
<a name="l02651"></a>02651 
<a name="l02652"></a>02652 
<a name="l02653"></a>02653         <span class="keywordflow">if</span> (<a class="code" href="classcore__t.html#a74ac58fba7a6ecd53ba31705ba5c38cd">m_thread</a>[i] &amp;&amp; !<a class="code" href="classcore__t.html#a74ac58fba7a6ecd53ba31705ba5c38cd">m_thread</a>[i]-&gt;is_done()) done = <span class="keyword">false</span>;
<a name="l02654"></a>02654     }
<a name="l02655"></a>02655     <span class="comment">//if (m_warp[warp_id].get_n_completed() == get_config()-&gt;warp_size)</span>
<a name="l02656"></a>02656     <span class="comment">//if (this-&gt;m_simt_stack[warp_id]-&gt;get_num_entries() == 0)</span>
<a name="l02657"></a>02657     <span class="keywordflow">if</span> (done)
<a name="l02658"></a>02658         <a class="code" href="classshader__core__ctx.html#ad1128668e0cb4889bcb9d257710e6f42">m_barriers</a>.<a class="code" href="classbarrier__set__t.html#a6ef5a4a8977c12c9a7cd15a8c95b11e7">warp_exit</a>( warp_id );
<a name="l02659"></a>02659 }
<a name="l02660"></a>02660 
<a name="l02661"></a><a class="code" href="classshader__core__ctx.html#ad268dafea2774592818fad4f813fca61">02661</a> <span class="keywordtype">bool</span> <a class="code" href="classshader__core__ctx.html#ad268dafea2774592818fad4f813fca61">shader_core_ctx::warp_waiting_at_barrier</a>( <span class="keywordtype">unsigned</span> warp_id )<span class="keyword"> const</span>
<a name="l02662"></a>02662 <span class="keyword"></span>{
<a name="l02663"></a>02663    <span class="keywordflow">return</span> <a class="code" href="classshader__core__ctx.html#ad1128668e0cb4889bcb9d257710e6f42">m_barriers</a>.<a class="code" href="classbarrier__set__t.html#a1ac5ebbab8231971a2727432f40c37e7">warp_waiting_at_barrier</a>(warp_id);
<a name="l02664"></a>02664 }
<a name="l02665"></a>02665 
<a name="l02666"></a><a class="code" href="classshader__core__ctx.html#a0184fbdd604e4012a16515c9a4272f08">02666</a> <span class="keywordtype">bool</span> <a class="code" href="classshader__core__ctx.html#a0184fbdd604e4012a16515c9a4272f08">shader_core_ctx::warp_waiting_at_mem_barrier</a>( <span class="keywordtype">unsigned</span> warp_id ) 
<a name="l02667"></a>02667 {
<a name="l02668"></a>02668    <span class="keywordflow">if</span>( !<a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[warp_id].get_membar() ) 
<a name="l02669"></a>02669       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02670"></a>02670    <span class="keywordflow">if</span>( !<a class="code" href="classshader__core__ctx.html#aeeef0a2c13838c8d65a9614c2c7610f4">m_scoreboard</a>-&gt;<a class="code" href="classScoreboard.html#acd976836194b50a0c1dcfd8404ebc155">pendingWrites</a>(warp_id) ) {
<a name="l02671"></a>02671       <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[warp_id].clear_membar();
<a name="l02672"></a>02672       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02673"></a>02673    }
<a name="l02674"></a>02674    <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02675"></a>02675 }
<a name="l02676"></a>02676 
<a name="l02677"></a><a class="code" href="classshader__core__ctx.html#ac6132ca24aaf9dfe6a773a5b000223af">02677</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#ac6132ca24aaf9dfe6a773a5b000223af">shader_core_ctx::set_max_cta</a>( <span class="keyword">const</span> <a class="code" href="classkernel__info__t.html">kernel_info_t</a> &amp;kernel ) 
<a name="l02678"></a>02678 {
<a name="l02679"></a>02679     <span class="comment">// calculate the max cta count and cta size for local memory address mapping</span>
<a name="l02680"></a>02680     <a class="code" href="classshader__core__ctx.html#a22242c73ea577d8feda0674d2dc5d46a">kernel_max_cta_per_shader</a> = <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#af5142cb9479ef1fb1b429c88dc96254b">max_cta</a>(kernel);
<a name="l02681"></a>02681     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> gpu_cta_size = kernel.<a class="code" href="classkernel__info__t.html#a7764459a63b3dd279dfb07576a1dc718">threads_per_cta</a>();
<a name="l02682"></a>02682     <a class="code" href="classshader__core__ctx.html#ae5d139cc58f75380f48612110a917aec">kernel_padded_threads_per_cta</a> = (gpu_cta_size%<a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>) ? 
<a name="l02683"></a>02683         <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>*((gpu_cta_size/<a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>)+1) : 
<a name="l02684"></a>02684         gpu_cta_size;
<a name="l02685"></a>02685 }
<a name="l02686"></a>02686 
<a name="l02687"></a><a class="code" href="classshader__core__ctx.html#a1c9b68750d113e22f23e52b80911b080">02687</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#a1c9b68750d113e22f23e52b80911b080">shader_core_ctx::decrement_atomic_count</a>( <span class="keywordtype">unsigned</span> wid, <span class="keywordtype">unsigned</span> <a class="code" href="rng_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a> )
<a name="l02688"></a>02688 {
<a name="l02689"></a>02689    assert( <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[wid].get_n_atomic() &gt;= n );
<a name="l02690"></a>02690    <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[wid].dec_n_atomic(n);
<a name="l02691"></a>02691 }
<a name="l02692"></a>02692 
<a name="l02693"></a>02693 
<a name="l02694"></a><a class="code" href="classshader__core__ctx.html#a239a9362b7ecf4ade27b6673b09f8416">02694</a> <span class="keywordtype">bool</span> <a class="code" href="classshader__core__ctx.html#a239a9362b7ecf4ade27b6673b09f8416">shader_core_ctx::fetch_unit_response_buffer_full</a>()<span class="keyword"> const</span>
<a name="l02695"></a>02695 <span class="keyword"></span>{
<a name="l02696"></a>02696     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02697"></a>02697 }
<a name="l02698"></a>02698 
<a name="l02699"></a><a class="code" href="classshader__core__ctx.html#a72dcf4891e3c01eef9a9826a1b7bda95">02699</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#a72dcf4891e3c01eef9a9826a1b7bda95">shader_core_ctx::accept_fetch_response</a>( <a class="code" href="classmem__fetch.html">mem_fetch</a> *mf )
<a name="l02700"></a>02700 {
<a name="l02701"></a>02701     mf-&gt;<a class="code" href="classmem__fetch.html#acbda50764b3c8d6f79ffa279021253da">set_status</a>(IN_SHADER_FETCHED,<a class="code" href="gpu-sim_8cc.html#a659fec271553d05e676c52314c8fcfe1">gpu_sim_cycle</a>+<a class="code" href="gpu-sim_8cc.html#acef6bbfd6ec09fe29e2641cace785058">gpu_tot_sim_cycle</a>);
<a name="l02702"></a>02702     <a class="code" href="classshader__core__ctx.html#ab4e5da01591cc8c202069addf3afad1c">m_L1I</a>-&gt;<a class="code" href="classbaseline__cache.html#aa797b46275001da9451a5ce16f815569" title="Interface for response from lower memory level (model bandwidth restictions in caller)...">fill</a>(mf,<a class="code" href="gpu-sim_8cc.html#a659fec271553d05e676c52314c8fcfe1">gpu_sim_cycle</a>+<a class="code" href="gpu-sim_8cc.html#acef6bbfd6ec09fe29e2641cace785058">gpu_tot_sim_cycle</a>);
<a name="l02703"></a>02703 }
<a name="l02704"></a>02704 
<a name="l02705"></a><a class="code" href="classshader__core__ctx.html#af93136f0bed22a567ae16ea3f92c3ca0">02705</a> <span class="keywordtype">bool</span> <a class="code" href="classshader__core__ctx.html#af93136f0bed22a567ae16ea3f92c3ca0">shader_core_ctx::ldst_unit_response_buffer_full</a>()<span class="keyword"> const</span>
<a name="l02706"></a>02706 <span class="keyword"></span>{
<a name="l02707"></a>02707     <span class="keywordflow">return</span> <a class="code" href="classshader__core__ctx.html#a11facb48161a3079025f0602e276969b">m_ldst_unit</a>-&gt;<a class="code" href="classldst__unit.html#a3f9446852a78a8ad4995eaf1d1f6c291">response_buffer_full</a>();
<a name="l02708"></a>02708 }
<a name="l02709"></a>02709 
<a name="l02710"></a><a class="code" href="classshader__core__ctx.html#a6bad3b5d1cda03c537e911da56e78111">02710</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#a6bad3b5d1cda03c537e911da56e78111">shader_core_ctx::accept_ldst_unit_response</a>(<a class="code" href="classmem__fetch.html">mem_fetch</a> * mf) 
<a name="l02711"></a>02711 {
<a name="l02712"></a>02712    <a class="code" href="classshader__core__ctx.html#a11facb48161a3079025f0602e276969b">m_ldst_unit</a>-&gt;<a class="code" href="classldst__unit.html#a6893386745321f4fab709390fc56cba6">fill</a>(mf);
<a name="l02713"></a>02713 }
<a name="l02714"></a>02714 
<a name="l02715"></a><a class="code" href="classshader__core__ctx.html#a6ec3f76dc2811675296ad24bf6d77667">02715</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#a6ec3f76dc2811675296ad24bf6d77667">shader_core_ctx::store_ack</a>( <span class="keyword">class</span> <a class="code" href="classmem__fetch.html">mem_fetch</a> *mf )
<a name="l02716"></a>02716 {
<a name="l02717"></a>02717     assert( mf-&gt;<a class="code" href="classmem__fetch.html#a1b66843ccce20aaf75b53c91f2d7ad61">get_type</a>() == <a class="code" href="mem__fetch_8h.html#a5830ce559c805683000f5d82d6f0a234a84df0ac61ee4b6f007ec6373ed8b3223">WRITE_ACK</a>  || ( <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#abe1f48d1bf3b8b7ec3531f957e15bbe1">gpgpu_perfect_mem</a> &amp;&amp; mf-&gt;<a class="code" href="classmem__fetch.html#a0e449bde79c7162ec62c433338ac0293">get_is_write</a>() ) );
<a name="l02718"></a>02718     <span class="keywordtype">unsigned</span> warp_id = mf-&gt;<a class="code" href="classmem__fetch.html#aa9e3a06ff563324393980d3d78bdba11">get_wid</a>();
<a name="l02719"></a>02719     <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[warp_id].dec_store_req();
<a name="l02720"></a>02720 }
<a name="l02721"></a>02721 
<a name="l02722"></a><a class="code" href="classshader__core__ctx.html#a3d2731bcd032c7d4a1cf553edd129265">02722</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#a3d2731bcd032c7d4a1cf553edd129265">shader_core_ctx::print_cache_stats</a>( FILE *fp, <span class="keywordtype">unsigned</span>&amp; dl1_accesses, <span class="keywordtype">unsigned</span>&amp; dl1_misses ) {
<a name="l02723"></a>02723    <a class="code" href="classshader__core__ctx.html#a11facb48161a3079025f0602e276969b">m_ldst_unit</a>-&gt;<a class="code" href="classldst__unit.html#a46d1e56cefbc64198dbc747a16625563">print_cache_stats</a>( fp, dl1_accesses, dl1_misses );
<a name="l02724"></a>02724 }
<a name="l02725"></a>02725 
<a name="l02726"></a><a class="code" href="classshader__core__ctx.html#acb7551ea3df499b66367b703bab87b82">02726</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#acb7551ea3df499b66367b703bab87b82">shader_core_ctx::get_cache_stats</a>(<a class="code" href="classcache__stats.html">cache_stats</a> &amp;cs){
<a name="l02727"></a>02727     <span class="comment">// Adds stats from each cache to &apos;cs&apos;</span>
<a name="l02728"></a>02728     cs += <a class="code" href="classshader__core__ctx.html#ab4e5da01591cc8c202069addf3afad1c">m_L1I</a>-&gt;<a class="code" href="classbaseline__cache.html#af3d41b44d4bdea8c07eb66693d0dcc4e">get_stats</a>(); <span class="comment">// Get L1I stats</span>
<a name="l02729"></a>02729     <a class="code" href="classshader__core__ctx.html#a11facb48161a3079025f0602e276969b">m_ldst_unit</a>-&gt;<a class="code" href="classldst__unit.html#a8b8b9263bf9322ef1b2494d2a488ef94">get_cache_stats</a>(cs); <span class="comment">// Get L1D, L1C, L1T stats</span>
<a name="l02730"></a>02730 }
<a name="l02731"></a>02731 
<a name="l02732"></a><a class="code" href="classshader__core__ctx.html#abec73e6461b4560d83281a3a71268fbf">02732</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#abec73e6461b4560d83281a3a71268fbf">shader_core_ctx::get_L1I_sub_stats</a>(<span class="keyword">struct</span> <a class="code" href="structcache__sub__stats.html">cache_sub_stats</a> &amp;css)<span class="keyword"> const</span>{
<a name="l02733"></a>02733     <span class="keywordflow">if</span>(<a class="code" href="classshader__core__ctx.html#ab4e5da01591cc8c202069addf3afad1c">m_L1I</a>)
<a name="l02734"></a>02734         <a class="code" href="classshader__core__ctx.html#ab4e5da01591cc8c202069addf3afad1c">m_L1I</a>-&gt;<a class="code" href="classbaseline__cache.html#ab18435fe3071f7d77a41cc221e9a774d">get_sub_stats</a>(css);
<a name="l02735"></a>02735 }
<a name="l02736"></a><a class="code" href="classshader__core__ctx.html#ab1522e0e0fee39d41965575832b3a7a9">02736</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#ab1522e0e0fee39d41965575832b3a7a9">shader_core_ctx::get_L1D_sub_stats</a>(<span class="keyword">struct</span> <a class="code" href="structcache__sub__stats.html">cache_sub_stats</a> &amp;css)<span class="keyword"> const</span>{
<a name="l02737"></a>02737     <a class="code" href="classshader__core__ctx.html#a11facb48161a3079025f0602e276969b">m_ldst_unit</a>-&gt;<a class="code" href="classldst__unit.html#afe5626eb00ad9a185fd692abf4ab1ae5">get_L1D_sub_stats</a>(css);
<a name="l02738"></a>02738 }
<a name="l02739"></a><a class="code" href="classshader__core__ctx.html#a86161c0c629a3981dd801386871c45f1">02739</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#a86161c0c629a3981dd801386871c45f1">shader_core_ctx::get_L1C_sub_stats</a>(<span class="keyword">struct</span> <a class="code" href="structcache__sub__stats.html">cache_sub_stats</a> &amp;css)<span class="keyword"> const</span>{
<a name="l02740"></a>02740     <a class="code" href="classshader__core__ctx.html#a11facb48161a3079025f0602e276969b">m_ldst_unit</a>-&gt;<a class="code" href="classldst__unit.html#a0f3e0103e1a9e7ab3e52217608680fff">get_L1C_sub_stats</a>(css);
<a name="l02741"></a>02741 }
<a name="l02742"></a><a class="code" href="classshader__core__ctx.html#ab05a3859164ed38e61b8cfdf48e4a4bd">02742</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#ab05a3859164ed38e61b8cfdf48e4a4bd">shader_core_ctx::get_L1T_sub_stats</a>(<span class="keyword">struct</span> <a class="code" href="structcache__sub__stats.html">cache_sub_stats</a> &amp;css)<span class="keyword"> const</span>{
<a name="l02743"></a>02743     <a class="code" href="classshader__core__ctx.html#a11facb48161a3079025f0602e276969b">m_ldst_unit</a>-&gt;<a class="code" href="classldst__unit.html#a4f1d72773132613e05ed8a761c2d2d0f">get_L1T_sub_stats</a>(css);
<a name="l02744"></a>02744 }
<a name="l02745"></a>02745 
<a name="l02746"></a><a class="code" href="classshader__core__ctx.html#a4c1c2b2fa01fbd013aab0a64e9da0962">02746</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#a4c1c2b2fa01fbd013aab0a64e9da0962">shader_core_ctx::get_icnt_power_stats</a>(<span class="keywordtype">long</span> &amp;n_simt_to_mem, <span class="keywordtype">long</span> &amp;n_mem_to_simt)<span class="keyword"> const</span>{
<a name="l02747"></a>02747     n_simt_to_mem += <a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a4a2a0096506cdafba4823d8caa073fa5">n_simt_to_mem</a>[<a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>];
<a name="l02748"></a>02748     n_mem_to_simt += <a class="code" href="classshader__core__ctx.html#a7344892ff8c4dbe6d598648f720e3131">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a06f927877d9c7bd2cf60d494ae2011a6">n_mem_to_simt</a>[<a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>];
<a name="l02749"></a>02749 }
<a name="l02750"></a>02750 
<a name="l02751"></a><a class="code" href="classshd__warp__t.html#aaed3eb4aada52585adbe8ed6b29d61eb">02751</a> <span class="keywordtype">bool</span> <a class="code" href="classshd__warp__t.html#aaed3eb4aada52585adbe8ed6b29d61eb">shd_warp_t::functional_done</a>()<span class="keyword"> const</span>
<a name="l02752"></a>02752 <span class="keyword"></span>{
<a name="l02753"></a>02753     <span class="keywordflow">return</span> <a class="code" href="classshd__warp__t.html#a987f4d2768730a071756a47ab88c850d">get_n_completed</a>() == <a class="code" href="classshd__warp__t.html#ae6ab26581c9d3e5c072183dcc8d393ff">m_warp_size</a>;
<a name="l02754"></a>02754 }
<a name="l02755"></a>02755 
<a name="l02756"></a><a class="code" href="classshd__warp__t.html#af126cb184a8c184c21d60ea13160eb23">02756</a> <span class="keywordtype">bool</span> <a class="code" href="classshd__warp__t.html#af126cb184a8c184c21d60ea13160eb23">shd_warp_t::hardware_done</a>()<span class="keyword"> const</span>
<a name="l02757"></a>02757 <span class="keyword"></span>{
<a name="l02758"></a>02758     <span class="keywordflow">return</span> <a class="code" href="classshd__warp__t.html#aaed3eb4aada52585adbe8ed6b29d61eb">functional_done</a>() &amp;&amp; <a class="code" href="classshd__warp__t.html#aba01f883b955f204a6e2c628a1eb602f">stores_done</a>() &amp;&amp; !<a class="code" href="classshd__warp__t.html#a9509519766060c24660b56280092c416">inst_in_pipeline</a>(); 
<a name="l02759"></a>02759 }
<a name="l02760"></a>02760 
<a name="l02761"></a><a class="code" href="classshd__warp__t.html#ac6fc987f2b4fd09b6610a41ea0e6ffba">02761</a> <span class="keywordtype">bool</span> <a class="code" href="classshd__warp__t.html#ac6fc987f2b4fd09b6610a41ea0e6ffba">shd_warp_t::waiting</a>() 
<a name="l02762"></a>02762 {
<a name="l02763"></a>02763     <span class="keywordflow">if</span> ( <a class="code" href="classshd__warp__t.html#aaed3eb4aada52585adbe8ed6b29d61eb">functional_done</a>() ) {
<a name="l02764"></a>02764         <span class="comment">// waiting to be initialized with a kernel</span>
<a name="l02765"></a>02765         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02766"></a>02766     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="classshd__warp__t.html#a54883a0a2b4b53148ce2e64b2af42752">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#ad268dafea2774592818fad4f813fca61">warp_waiting_at_barrier</a>(<a class="code" href="classshd__warp__t.html#a84a07060aac62f7c6d87a924404e289d">m_warp_id</a>) ) {
<a name="l02767"></a>02767         <span class="comment">// waiting for other warps in CTA to reach barrier</span>
<a name="l02768"></a>02768         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02769"></a>02769     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="classshd__warp__t.html#a54883a0a2b4b53148ce2e64b2af42752">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#a0184fbdd604e4012a16515c9a4272f08">warp_waiting_at_mem_barrier</a>(<a class="code" href="classshd__warp__t.html#a84a07060aac62f7c6d87a924404e289d">m_warp_id</a>) ) {
<a name="l02770"></a>02770         <span class="comment">// waiting for memory barrier</span>
<a name="l02771"></a>02771         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02772"></a>02772     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="classshd__warp__t.html#ae1db03f96f6a4e29b1b0f5d3baf5a80e">m_n_atomic</a> &gt;0 ) {
<a name="l02773"></a>02773         <span class="comment">// waiting for atomic operation to complete at memory:</span>
<a name="l02774"></a>02774         <span class="comment">// this stall is not required for accurate timing model, but rather we</span>
<a name="l02775"></a>02775         <span class="comment">// stall here since if a call/return instruction occurs in the meantime</span>
<a name="l02776"></a>02776         <span class="comment">// the functional execution of the atomic when it hits DRAM can cause</span>
<a name="l02777"></a>02777         <span class="comment">// the wrong register to be read.</span>
<a name="l02778"></a>02778         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02779"></a>02779     }
<a name="l02780"></a>02780     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02781"></a>02781 }
<a name="l02782"></a>02782 
<a name="l02783"></a><a class="code" href="classshd__warp__t.html#abae3f034478717de219e4231134cc799">02783</a> <span class="keywordtype">void</span> <a class="code" href="classshd__warp__t.html#abae3f034478717de219e4231134cc799">shd_warp_t::print</a>( FILE *fout )<span class="keyword"> const</span>
<a name="l02784"></a>02784 <span class="keyword"></span>{
<a name="l02785"></a>02785     <span class="keywordflow">if</span>( !<a class="code" href="classshd__warp__t.html#afd25c3deec8a38e7f920162986034c13">done_exit</a>() ) {
<a name="l02786"></a>02786         fprintf( fout, <span class="stringliteral">&quot;w%02u npc: 0x%04x, done:%c%c%c%c:%2u i:%u s:%u a:%u (done: &quot;</span>, 
<a name="l02787"></a>02787                 <a class="code" href="classshd__warp__t.html#a84a07060aac62f7c6d87a924404e289d">m_warp_id</a>,
<a name="l02788"></a>02788                 <a class="code" href="classshd__warp__t.html#a497cb5e62609c11c7e724ea5d4ed49d8">m_next_pc</a>,
<a name="l02789"></a>02789                 (<a class="code" href="classshd__warp__t.html#aaed3eb4aada52585adbe8ed6b29d61eb">functional_done</a>()?<span class="charliteral">&apos;f&apos;</span>:<span class="charliteral">&apos; &apos;</span>),
<a name="l02790"></a>02790                 (<a class="code" href="classshd__warp__t.html#aba01f883b955f204a6e2c628a1eb602f">stores_done</a>()?<span class="charliteral">&apos;s&apos;</span>:<span class="charliteral">&apos; &apos;</span>),
<a name="l02791"></a>02791                 (<a class="code" href="classshd__warp__t.html#a9509519766060c24660b56280092c416">inst_in_pipeline</a>()?<span class="charliteral">&apos; &apos;</span>:<span class="charliteral">&apos;i&apos;</span>),
<a name="l02792"></a>02792                 (<a class="code" href="classshd__warp__t.html#afd25c3deec8a38e7f920162986034c13">done_exit</a>()?<span class="charliteral">&apos;e&apos;</span>:<span class="charliteral">&apos; &apos;</span>),
<a name="l02793"></a>02793                 <a class="code" href="classshd__warp__t.html#a50b7888852f27fdf5775dc4dcc41221a">n_completed</a>,
<a name="l02794"></a>02794                 <a class="code" href="classshd__warp__t.html#adc91c3b886d426ac70c2361808d892ad">m_inst_in_pipeline</a>, 
<a name="l02795"></a>02795                 <a class="code" href="classshd__warp__t.html#a07200b8652fe470db7e30725db9a237a">m_stores_outstanding</a>,
<a name="l02796"></a>02796                 <a class="code" href="classshd__warp__t.html#ae1db03f96f6a4e29b1b0f5d3baf5a80e">m_n_atomic</a> );
<a name="l02797"></a>02797         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = <a class="code" href="classshd__warp__t.html#a84a07060aac62f7c6d87a924404e289d">m_warp_id</a>*<a class="code" href="classshd__warp__t.html#ae6ab26581c9d3e5c072183dcc8d393ff">m_warp_size</a>; i &lt; (<a class="code" href="classshd__warp__t.html#a84a07060aac62f7c6d87a924404e289d">m_warp_id</a>+1)*<a class="code" href="classshd__warp__t.html#ae6ab26581c9d3e5c072183dcc8d393ff">m_warp_size</a>; i++ ) {
<a name="l02798"></a>02798           <span class="keywordflow">if</span> ( <a class="code" href="classshd__warp__t.html#a54883a0a2b4b53148ce2e64b2af42752">m_shader</a>-&gt;<a class="code" href="classcore__t.html#aef36fb0d504e2357a78da821249f617a">ptx_thread_done</a>(i) ) fprintf(fout,<span class="stringliteral">&quot;1&quot;</span>);
<a name="l02799"></a>02799           <span class="keywordflow">else</span> fprintf(fout,<span class="stringliteral">&quot;0&quot;</span>);
<a name="l02800"></a>02800           <span class="keywordflow">if</span> ( (((i+1)%4) == 0) &amp;&amp; (i+1) &lt; (<a class="code" href="classshd__warp__t.html#a84a07060aac62f7c6d87a924404e289d">m_warp_id</a>+1)*<a class="code" href="classshd__warp__t.html#ae6ab26581c9d3e5c072183dcc8d393ff">m_warp_size</a> ) 
<a name="l02801"></a>02801              fprintf(fout,<span class="stringliteral">&quot;,&quot;</span>);
<a name="l02802"></a>02802         }
<a name="l02803"></a>02803         fprintf(fout,<span class="stringliteral">&quot;) &quot;</span>);
<a name="l02804"></a>02804         fprintf(fout,<span class="stringliteral">&quot; active=%s&quot;</span>, <a class="code" href="classshd__warp__t.html#a202ba6ee734bab48f553b83e437c188d">m_active_threads</a>.to_string().c_str() );
<a name="l02805"></a>02805         fprintf(fout,<span class="stringliteral">&quot; last fetched @ %5llu&quot;</span>, <a class="code" href="classshd__warp__t.html#a8000acc3ed186abfa68a0d5cfa23fca1">m_last_fetch</a>);
<a name="l02806"></a>02806         <span class="keywordflow">if</span>( <a class="code" href="classshd__warp__t.html#a80eb40a6e1f31a65ef7da13340b13647">m_imiss_pending</a> ) 
<a name="l02807"></a>02807             fprintf(fout,<span class="stringliteral">&quot; i-miss pending&quot;</span>);
<a name="l02808"></a>02808         fprintf(fout,<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02809"></a>02809     }
<a name="l02810"></a>02810 }
<a name="l02811"></a>02811 
<a name="l02812"></a><a class="code" href="classshd__warp__t.html#a3539b3761bc7f2be69cd5cb937a2ccbe">02812</a> <span class="keywordtype">void</span> <a class="code" href="classshd__warp__t.html#a3539b3761bc7f2be69cd5cb937a2ccbe">shd_warp_t::print_ibuffer</a>( FILE *fout )<span class="keyword"> const</span>
<a name="l02813"></a>02813 <span class="keyword"></span>{
<a name="l02814"></a>02814     fprintf(fout,<span class="stringliteral">&quot;  ibuffer[%2u] : &quot;</span>, <a class="code" href="classshd__warp__t.html#a84a07060aac62f7c6d87a924404e289d">m_warp_id</a> );
<a name="l02815"></a>02815     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i &lt; <a class="code" href="classshd__warp__t.html#ab2bf5b575e240331cff6ed9ad29c4c99">IBUFFER_SIZE</a>; i++) {
<a name="l02816"></a>02816         <span class="keyword">const</span> <a class="code" href="classinst__t.html">inst_t</a> *inst = <a class="code" href="classshd__warp__t.html#a03290853b7bb8e2f0b850ea4c6cbeabc">m_ibuffer</a>[i].<a class="code" href="structshd__warp__t_1_1ibuffer__entry.html#a595b4cacc0766b30a044cbff94ce7ccb">m_inst</a>;
<a name="l02817"></a>02817         <span class="keywordflow">if</span>( inst ) inst-&gt;<a class="code" href="classinst__t.html#a1bc08d98bbaa6de7059577167335e67c">print_insn</a>(fout);
<a name="l02818"></a>02818         <span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="classshd__warp__t.html#a03290853b7bb8e2f0b850ea4c6cbeabc">m_ibuffer</a>[i].m_valid ) 
<a name="l02819"></a>02819            fprintf(fout,<span class="stringliteral">&quot; &lt;invalid instruction&gt; &quot;</span>);
<a name="l02820"></a>02820         <span class="keywordflow">else</span> fprintf(fout,<span class="stringliteral">&quot; &lt;empty&gt; &quot;</span>);
<a name="l02821"></a>02821     }
<a name="l02822"></a>02822     fprintf(fout,<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02823"></a>02823 }
<a name="l02824"></a>02824 
<a name="l02825"></a><a class="code" href="classopndcoll__rfu__t.html#a02c9ca36eb4f3baf021bccb73e658b33">02825</a> <span class="keywordtype">void</span> <a class="code" href="classopndcoll__rfu__t.html#a02c9ca36eb4f3baf021bccb73e658b33">opndcoll_rfu_t::add_cu_set</a>(<span class="keywordtype">unsigned</span> set_id, <span class="keywordtype">unsigned</span> num_cu, <span class="keywordtype">unsigned</span> num_dispatch){
<a name="l02826"></a>02826     <a class="code" href="classopndcoll__rfu__t.html#a72478725d9534085249cee317d115c62">m_cus</a>[set_id].reserve(num_cu); <span class="comment">//this is necessary to stop pointers in m_cu from being invalid do to a resize;</span>
<a name="l02827"></a>02827     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_cu; i++) {
<a name="l02828"></a>02828         <a class="code" href="classopndcoll__rfu__t.html#a72478725d9534085249cee317d115c62">m_cus</a>[set_id].push_back(<a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html">collector_unit_t</a>());
<a name="l02829"></a>02829         <a class="code" href="classopndcoll__rfu__t.html#a40be91a44de8048dd3c54de54177807c">m_cu</a>.push_back(&amp;<a class="code" href="classopndcoll__rfu__t.html#a72478725d9534085249cee317d115c62">m_cus</a>[set_id].back());
<a name="l02830"></a>02830     }
<a name="l02831"></a>02831     <span class="comment">// for now each collector set gets dedicated dispatch units.</span>
<a name="l02832"></a>02832     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; num_dispatch; i++) {
<a name="l02833"></a>02833         <a class="code" href="classopndcoll__rfu__t.html#a17e1085f41a24039d0a905c3e03e8b3e">m_dispatch_units</a>.push_back(<a class="code" href="classopndcoll__rfu__t_1_1dispatch__unit__t.html">dispatch_unit_t</a>(&amp;<a class="code" href="classopndcoll__rfu__t.html#a72478725d9534085249cee317d115c62">m_cus</a>[set_id]));
<a name="l02834"></a>02834     }
<a name="l02835"></a>02835 }
<a name="l02836"></a>02836 
<a name="l02837"></a>02837 
<a name="l02838"></a><a class="code" href="classopndcoll__rfu__t.html#a761c70919115cf9f27ac2b976aa9c7bc">02838</a> <span class="keywordtype">void</span> <a class="code" href="classopndcoll__rfu__t.html#a761c70919115cf9f27ac2b976aa9c7bc">opndcoll_rfu_t::add_port</a>(port_vector_t &amp; <a class="code" href="lex_8yy_8c.html#a171692544b8e065853e387755849a433">input</a>, port_vector_t &amp; <a class="code" href="cuobjdump__to__ptxplus_8cc.html#a850af8cfb632548b213ce5b365fedd1a">output</a>, uint_vector_t cu_sets)
<a name="l02839"></a>02839 {
<a name="l02840"></a>02840     <span class="comment">//m_num_ports++;</span>
<a name="l02841"></a>02841     <span class="comment">//m_num_collectors += num_collector_units;</span>
<a name="l02842"></a>02842     <span class="comment">//m_input.resize(m_num_ports);</span>
<a name="l02843"></a>02843     <span class="comment">//m_output.resize(m_num_ports);</span>
<a name="l02844"></a>02844     <span class="comment">//m_num_collector_units.resize(m_num_ports);</span>
<a name="l02845"></a>02845     <span class="comment">//m_input[m_num_ports-1]=input_port;</span>
<a name="l02846"></a>02846     <span class="comment">//m_output[m_num_ports-1]=output_port;</span>
<a name="l02847"></a>02847     <span class="comment">//m_num_collector_units[m_num_ports-1]=num_collector_units;</span>
<a name="l02848"></a>02848     <a class="code" href="classopndcoll__rfu__t.html#a4010d4694aa8481c98412c636b75bdf2">m_in_ports</a>.push_back(<a class="code" href="classopndcoll__rfu__t_1_1input__port__t.html">input_port_t</a>(input,output,cu_sets));
<a name="l02849"></a>02849 }
<a name="l02850"></a>02850 
<a name="l02851"></a><a class="code" href="classopndcoll__rfu__t.html#a6a69c8d3f2952ce95e6ea8fffbbdba97">02851</a> <span class="keywordtype">void</span> <a class="code" href="classopndcoll__rfu__t.html#a6a69c8d3f2952ce95e6ea8fffbbdba97">opndcoll_rfu_t::init</a>( <span class="keywordtype">unsigned</span> num_banks, <a class="code" href="classshader__core__ctx.html">shader_core_ctx</a> *shader )
<a name="l02852"></a>02852 {
<a name="l02853"></a>02853    <a class="code" href="classopndcoll__rfu__t.html#a946511568d01f1831a2fa388b39d07bc">m_shader</a>=shader;
<a name="l02854"></a>02854    <a class="code" href="classopndcoll__rfu__t.html#a9961fece010ab32ea90584d02ce548e1">m_arbiter</a>.<a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#ab42655a17bf0f2f302ba0fabc48f12c7">init</a>(<a class="code" href="classopndcoll__rfu__t.html#a40be91a44de8048dd3c54de54177807c">m_cu</a>.size(),num_banks);
<a name="l02855"></a>02855    <span class="comment">//for( unsigned n=0; n&lt;m_num_ports;n++ ) </span>
<a name="l02856"></a>02856    <span class="comment">//    m_dispatch_units[m_output[n]].init( m_num_collector_units[n] );</span>
<a name="l02857"></a>02857    <a class="code" href="classopndcoll__rfu__t.html#acffc1924bee3fe2be1030d33a0c042ec">m_num_banks</a> = num_banks;
<a name="l02858"></a>02858    <a class="code" href="classopndcoll__rfu__t.html#afe383eab3afc8915895b861cda6a7c13">m_bank_warp_shift</a> = 0; 
<a name="l02859"></a>02859    <a class="code" href="classopndcoll__rfu__t.html#a652f508adaf292e0f986646a05127eaa">m_warp_size</a> = shader-&gt;<a class="code" href="classshader__core__ctx.html#a0dfa04be25f749a0a690843a13db0881">get_config</a>()-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>;
<a name="l02860"></a>02860    <a class="code" href="classopndcoll__rfu__t.html#afe383eab3afc8915895b861cda6a7c13">m_bank_warp_shift</a> = (unsigned)(<span class="keywordtype">int</span>) (log(<a class="code" href="classopndcoll__rfu__t.html#a652f508adaf292e0f986646a05127eaa">m_warp_size</a>+0.5) / log(2.0));
<a name="l02861"></a>02861    assert( (<a class="code" href="classopndcoll__rfu__t.html#afe383eab3afc8915895b861cda6a7c13">m_bank_warp_shift</a> == 5) || (<a class="code" href="classopndcoll__rfu__t.html#a652f508adaf292e0f986646a05127eaa">m_warp_size</a> != 32) );
<a name="l02862"></a>02862 
<a name="l02863"></a>02863    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> j=0; j&lt;<a class="code" href="classopndcoll__rfu__t.html#a40be91a44de8048dd3c54de54177807c">m_cu</a>.size(); j++) {
<a name="l02864"></a>02864        <a class="code" href="classopndcoll__rfu__t.html#a40be91a44de8048dd3c54de54177807c">m_cu</a>[j]-&gt;init(j,num_banks,<a class="code" href="classopndcoll__rfu__t.html#afe383eab3afc8915895b861cda6a7c13">m_bank_warp_shift</a>,shader-&gt;<a class="code" href="classshader__core__ctx.html#a0dfa04be25f749a0a690843a13db0881">get_config</a>(),<span class="keyword">this</span>);
<a name="l02865"></a>02865    }
<a name="l02866"></a>02866    <a class="code" href="classopndcoll__rfu__t.html#a91f7e3aa3d0a1138ce4e9da7038a0bbc">m_initialized</a>=<span class="keyword">true</span>;
<a name="l02867"></a>02867 }
<a name="l02868"></a>02868 
<a name="l02869"></a><a class="code" href="shader_8h.html#a1284ac0a0c72fa3a3d27a7c3bcf32ea5">02869</a> <span class="keywordtype">int</span> <a class="code" href="shader_8cc.html#a1284ac0a0c72fa3a3d27a7c3bcf32ea5">register_bank</a>(<span class="keywordtype">int</span> regnum, <span class="keywordtype">int</span> wid, <span class="keywordtype">unsigned</span> num_banks, <span class="keywordtype">unsigned</span> bank_warp_shift)
<a name="l02870"></a>02870 {
<a name="l02871"></a>02871    <span class="keywordtype">int</span> bank = regnum;
<a name="l02872"></a>02872    <span class="keywordflow">if</span> (bank_warp_shift)
<a name="l02873"></a>02873       bank += wid;
<a name="l02874"></a>02874    <span class="keywordflow">return</span> bank % num_banks;
<a name="l02875"></a>02875 }
<a name="l02876"></a>02876 
<a name="l02877"></a><a class="code" href="classopndcoll__rfu__t.html#a28c5383a06f97b62df0a047a252661df">02877</a> <span class="keywordtype">bool</span> <a class="code" href="classopndcoll__rfu__t.html#a28c5383a06f97b62df0a047a252661df">opndcoll_rfu_t::writeback</a>( <span class="keyword">const</span> <a class="code" href="classwarp__inst__t.html">warp_inst_t</a> &amp;inst )
<a name="l02878"></a>02878 {
<a name="l02879"></a>02879    assert( !inst.<a class="code" href="classwarp__inst__t.html#a6d8dcd93a49b024688585d9e37a86a4e">empty</a>() );
<a name="l02880"></a>02880    std::list&lt;unsigned&gt; <a class="code" href="structgpgpu__ptx__sim__kernel__info.html#a631651e9205d73a33c6df4678a5c7453">regs</a> = <a class="code" href="classopndcoll__rfu__t.html#a946511568d01f1831a2fa388b39d07bc">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#aed71e2ca04337bdac201f2d54378d7e1">get_regs_written</a>(inst);
<a name="l02881"></a>02881    std::list&lt;unsigned&gt;::iterator r;
<a name="l02882"></a>02882    <span class="keywordtype">unsigned</span> <a class="code" href="rng_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>=0;
<a name="l02883"></a>02883    <span class="keywordflow">for</span>( r=regs.begin(); r!=regs.end();r++,n++ ) {
<a name="l02884"></a>02884       <span class="keywordtype">unsigned</span> reg = *r;
<a name="l02885"></a>02885       <span class="keywordtype">unsigned</span> bank = <a class="code" href="shader_8cc.html#a1284ac0a0c72fa3a3d27a7c3bcf32ea5">register_bank</a>(reg,inst.<a class="code" href="classwarp__inst__t.html#ab1dd215e5b3d4083cdb473d4f8bf8bf2">warp_id</a>(),<a class="code" href="classopndcoll__rfu__t.html#acffc1924bee3fe2be1030d33a0c042ec">m_num_banks</a>,<a class="code" href="classopndcoll__rfu__t.html#afe383eab3afc8915895b861cda6a7c13">m_bank_warp_shift</a>);
<a name="l02886"></a>02886       <span class="keywordflow">if</span>( <a class="code" href="classopndcoll__rfu__t.html#a9961fece010ab32ea90584d02ce548e1">m_arbiter</a>.<a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#a87a6f2c807732b61dd76c52d5d13c49e">bank_idle</a>(bank) ) {
<a name="l02887"></a>02887           <a class="code" href="classopndcoll__rfu__t.html#a9961fece010ab32ea90584d02ce548e1">m_arbiter</a>.<a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#aed5cf88f7d1dbae19c6a4de6e9ad7dea">allocate_bank_for_write</a>(bank,<a class="code" href="classopndcoll__rfu__t_1_1op__t.html">op_t</a>(&amp;inst,reg,<a class="code" href="classopndcoll__rfu__t.html#acffc1924bee3fe2be1030d33a0c042ec">m_num_banks</a>,<a class="code" href="classopndcoll__rfu__t.html#afe383eab3afc8915895b861cda6a7c13">m_bank_warp_shift</a>));
<a name="l02888"></a>02888       } <span class="keywordflow">else</span> {
<a name="l02889"></a>02889           <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02890"></a>02890       }
<a name="l02891"></a>02891    }
<a name="l02892"></a>02892    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;(unsigned)regs.size();i++){
<a name="l02893"></a>02893           <span class="keywordflow">if</span>(<a class="code" href="classopndcoll__rfu__t.html#a946511568d01f1831a2fa388b39d07bc">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#a0dfa04be25f749a0a690843a13db0881">get_config</a>()-&gt;<a class="code" href="structshader__core__config.html#adcdf4af92cb25889d1bad10cacbe612d">gpgpu_clock_gated_reg_file</a>){
<a name="l02894"></a>02894               <span class="keywordtype">unsigned</span> active_count=0;
<a name="l02895"></a>02895               <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;<a class="code" href="classopndcoll__rfu__t.html#a946511568d01f1831a2fa388b39d07bc">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#a0dfa04be25f749a0a690843a13db0881">get_config</a>()-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>;i=i+<a class="code" href="classopndcoll__rfu__t.html#a946511568d01f1831a2fa388b39d07bc">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#a0dfa04be25f749a0a690843a13db0881">get_config</a>()-&gt;<a class="code" href="structshader__core__config.html#abd67e4a527a3ca5a722a5cae60189c03">n_regfile_gating_group</a>){
<a name="l02896"></a>02896                   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0;j&lt;<a class="code" href="classopndcoll__rfu__t.html#a946511568d01f1831a2fa388b39d07bc">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#a0dfa04be25f749a0a690843a13db0881">get_config</a>()-&gt;<a class="code" href="structshader__core__config.html#abd67e4a527a3ca5a722a5cae60189c03">n_regfile_gating_group</a>;j++){
<a name="l02897"></a>02897                       <span class="keywordflow">if</span>(inst.<a class="code" href="classwarp__inst__t.html#af4512b9950894b5c8433182c378dca15">get_active_mask</a>().test(i+j)){
<a name="l02898"></a>02898                           active_count+=<a class="code" href="classopndcoll__rfu__t.html#a946511568d01f1831a2fa388b39d07bc">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#a0dfa04be25f749a0a690843a13db0881">get_config</a>()-&gt;<a class="code" href="structshader__core__config.html#abd67e4a527a3ca5a722a5cae60189c03">n_regfile_gating_group</a>;
<a name="l02899"></a>02899                           <span class="keywordflow">break</span>;
<a name="l02900"></a>02900                       }
<a name="l02901"></a>02901                   }
<a name="l02902"></a>02902               }
<a name="l02903"></a>02903               <a class="code" href="classopndcoll__rfu__t.html#a946511568d01f1831a2fa388b39d07bc">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#aa9a4488d38f18e24d9a1bf3b12a2a3a1">incregfile_writes</a>(active_count);
<a name="l02904"></a>02904           }<span class="keywordflow">else</span>{
<a name="l02905"></a>02905               <a class="code" href="classopndcoll__rfu__t.html#a946511568d01f1831a2fa388b39d07bc">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#aa9a4488d38f18e24d9a1bf3b12a2a3a1">incregfile_writes</a>(<a class="code" href="classopndcoll__rfu__t.html#a946511568d01f1831a2fa388b39d07bc">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#a0dfa04be25f749a0a690843a13db0881">get_config</a>()-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>);<span class="comment">//inst.active_count());</span>
<a name="l02906"></a>02906           }
<a name="l02907"></a>02907    }
<a name="l02908"></a>02908    <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02909"></a>02909 }
<a name="l02910"></a>02910 
<a name="l02911"></a><a class="code" href="classopndcoll__rfu__t.html#a57635ed7ef0669f55b495062b4033ee3">02911</a> <span class="keywordtype">void</span> <a class="code" href="classopndcoll__rfu__t.html#a57635ed7ef0669f55b495062b4033ee3">opndcoll_rfu_t::dispatch_ready_cu</a>()
<a name="l02912"></a>02912 {
<a name="l02913"></a>02913    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> p=0; p &lt; <a class="code" href="classopndcoll__rfu__t.html#a17e1085f41a24039d0a905c3e03e8b3e">m_dispatch_units</a>.size(); ++p ) {
<a name="l02914"></a>02914       <a class="code" href="classopndcoll__rfu__t_1_1dispatch__unit__t.html">dispatch_unit_t</a> &amp;du = <a class="code" href="classopndcoll__rfu__t.html#a17e1085f41a24039d0a905c3e03e8b3e">m_dispatch_units</a>[p];
<a name="l02915"></a>02915       <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html">collector_unit_t</a> *cu = du.<a class="code" href="classopndcoll__rfu__t_1_1dispatch__unit__t.html#aec6e9d5d7ebd4af2153a8fa7ac0dff96">find_ready</a>();
<a name="l02916"></a>02916       <span class="keywordflow">if</span>( cu ) {
<a name="l02917"></a>02917          <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;(cu-&gt;<a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#a6684086a615e008d73ec71af0cbef4de">get_num_operands</a>()-cu-&gt;<a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#abdffc0f868b854d52efc17e6ce803914">get_num_regs</a>());i++){
<a name="l02918"></a>02918           <span class="keywordflow">if</span>(<a class="code" href="classopndcoll__rfu__t.html#a946511568d01f1831a2fa388b39d07bc">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#a0dfa04be25f749a0a690843a13db0881">get_config</a>()-&gt;<a class="code" href="structshader__core__config.html#adcdf4af92cb25889d1bad10cacbe612d">gpgpu_clock_gated_reg_file</a>){
<a name="l02919"></a>02919               <span class="keywordtype">unsigned</span> active_count=0;
<a name="l02920"></a>02920               <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;<a class="code" href="classopndcoll__rfu__t.html#a946511568d01f1831a2fa388b39d07bc">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#a0dfa04be25f749a0a690843a13db0881">get_config</a>()-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>;i=i+<a class="code" href="classopndcoll__rfu__t.html#a946511568d01f1831a2fa388b39d07bc">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#a0dfa04be25f749a0a690843a13db0881">get_config</a>()-&gt;<a class="code" href="structshader__core__config.html#abd67e4a527a3ca5a722a5cae60189c03">n_regfile_gating_group</a>){
<a name="l02921"></a>02921                   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0;j&lt;<a class="code" href="classopndcoll__rfu__t.html#a946511568d01f1831a2fa388b39d07bc">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#a0dfa04be25f749a0a690843a13db0881">get_config</a>()-&gt;<a class="code" href="structshader__core__config.html#abd67e4a527a3ca5a722a5cae60189c03">n_regfile_gating_group</a>;j++){
<a name="l02922"></a>02922                       <span class="keywordflow">if</span>(cu-&gt;<a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#a09da9bdd1f885954d77c82d81c700935">get_active_mask</a>().test(i+j)){
<a name="l02923"></a>02923                           active_count+=<a class="code" href="classopndcoll__rfu__t.html#a946511568d01f1831a2fa388b39d07bc">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#a0dfa04be25f749a0a690843a13db0881">get_config</a>()-&gt;<a class="code" href="structshader__core__config.html#abd67e4a527a3ca5a722a5cae60189c03">n_regfile_gating_group</a>;
<a name="l02924"></a>02924                           <span class="keywordflow">break</span>;
<a name="l02925"></a>02925                       }
<a name="l02926"></a>02926                   }
<a name="l02927"></a>02927               }
<a name="l02928"></a>02928               <a class="code" href="classopndcoll__rfu__t.html#a946511568d01f1831a2fa388b39d07bc">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#aa3978e5e42ab15bcf3301d160a93c01a">incnon_rf_operands</a>(active_count);
<a name="l02929"></a>02929           }<span class="keywordflow">else</span>{
<a name="l02930"></a>02930              <a class="code" href="classopndcoll__rfu__t.html#a946511568d01f1831a2fa388b39d07bc">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#aa3978e5e42ab15bcf3301d160a93c01a">incnon_rf_operands</a>(<a class="code" href="classopndcoll__rfu__t.html#a946511568d01f1831a2fa388b39d07bc">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#a0dfa04be25f749a0a690843a13db0881">get_config</a>()-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>);<span class="comment">//cu-&gt;get_active_count());</span>
<a name="l02931"></a>02931           }
<a name="l02932"></a>02932         }
<a name="l02933"></a>02933          cu-&gt;<a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#a2d93a33920b4b0d039e1711689bfd327">dispatch</a>();
<a name="l02934"></a>02934       }
<a name="l02935"></a>02935    }
<a name="l02936"></a>02936 }
<a name="l02937"></a>02937 
<a name="l02938"></a><a class="code" href="classopndcoll__rfu__t.html#aaed7037736f7ad74d76099fe8b1333a2">02938</a> <span class="keywordtype">void</span> <a class="code" href="classopndcoll__rfu__t.html#aaed7037736f7ad74d76099fe8b1333a2">opndcoll_rfu_t::allocate_cu</a>( <span class="keywordtype">unsigned</span> port_num )
<a name="l02939"></a>02939 {
<a name="l02940"></a>02940    <a class="code" href="classopndcoll__rfu__t_1_1input__port__t.html">input_port_t</a>&amp; inp = <a class="code" href="classopndcoll__rfu__t.html#a4010d4694aa8481c98412c636b75bdf2">m_in_ports</a>[port_num];
<a name="l02941"></a>02941    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; inp.<a class="code" href="classopndcoll__rfu__t_1_1input__port__t.html#a96c21eb4e931f537843eec844c689cfb">m_in</a>.size(); i++) {
<a name="l02942"></a>02942        <span class="keywordflow">if</span>( (*inp.<a class="code" href="classopndcoll__rfu__t_1_1input__port__t.html#a96c21eb4e931f537843eec844c689cfb">m_in</a>[i]).has_ready() ) {
<a name="l02943"></a>02943           <span class="comment">//find a free cu </span>
<a name="l02944"></a>02944           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; inp.<a class="code" href="classopndcoll__rfu__t_1_1input__port__t.html#aa06a5602961f7511afc1606b99e55715">m_cu_sets</a>.size(); j++) {
<a name="l02945"></a>02945               std::vector&lt;collector_unit_t&gt; &amp; cu_set = <a class="code" href="classopndcoll__rfu__t.html#a72478725d9534085249cee317d115c62">m_cus</a>[inp.<a class="code" href="classopndcoll__rfu__t_1_1input__port__t.html#aa06a5602961f7511afc1606b99e55715">m_cu_sets</a>[j]];
<a name="l02946"></a>02946           <span class="keywordtype">bool</span> allocated = <span class="keyword">false</span>;
<a name="l02947"></a>02947               <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> k = 0; k &lt; cu_set.size(); k++) {
<a name="l02948"></a>02948                   <span class="keywordflow">if</span>(cu_set[k].is_free()) {
<a name="l02949"></a>02949                      <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html">collector_unit_t</a> *cu = &amp;cu_set[k];
<a name="l02950"></a>02950                      allocated = cu-&gt;<a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#a9cc0a41e77655e4d199c3bb423d84d55">allocate</a>(inp.<a class="code" href="classopndcoll__rfu__t_1_1input__port__t.html#a96c21eb4e931f537843eec844c689cfb">m_in</a>[i],inp.<a class="code" href="classopndcoll__rfu__t_1_1input__port__t.html#aa307ab8cba0a225993f8211761c23f18">m_out</a>[i]);
<a name="l02951"></a>02951                      <a class="code" href="classopndcoll__rfu__t.html#a9961fece010ab32ea90584d02ce548e1">m_arbiter</a>.<a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#a97f031e99b09a5e651bef6cf9b12e773">add_read_requests</a>(cu);
<a name="l02952"></a>02952                      <span class="keywordflow">break</span>;
<a name="l02953"></a>02953                   }
<a name="l02954"></a>02954               }
<a name="l02955"></a>02955               <span class="keywordflow">if</span> (allocated) <span class="keywordflow">break</span>; <span class="comment">//cu has been allocated, no need to search more.</span>
<a name="l02956"></a>02956           }
<a name="l02957"></a>02957           <span class="keywordflow">break</span>; <span class="comment">// can only service a single input, if it failed it will fail for others.</span>
<a name="l02958"></a>02958        }
<a name="l02959"></a>02959    }
<a name="l02960"></a>02960 }
<a name="l02961"></a>02961 
<a name="l02962"></a><a class="code" href="classopndcoll__rfu__t.html#afcbb13b2c5834824bff302665479590c">02962</a> <span class="keywordtype">void</span> <a class="code" href="classopndcoll__rfu__t.html#afcbb13b2c5834824bff302665479590c">opndcoll_rfu_t::allocate_reads</a>()
<a name="l02963"></a>02963 {
<a name="l02964"></a>02964    <span class="comment">// process read requests that do not have conflicts</span>
<a name="l02965"></a>02965    std::list&lt;op_t&gt; allocated = <a class="code" href="classopndcoll__rfu__t.html#a9961fece010ab32ea90584d02ce548e1">m_arbiter</a>.<a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#ab3986ca2a1c2152b898bf804a8295962">allocate_reads</a>();
<a name="l02966"></a>02966    std::map&lt;unsigned,op_t&gt; read_ops;
<a name="l02967"></a>02967    <span class="keywordflow">for</span>( std::list&lt;op_t&gt;::iterator r=allocated.begin(); r!=allocated.end(); r++ ) {
<a name="l02968"></a>02968       <span class="keyword">const</span> <a class="code" href="classopndcoll__rfu__t_1_1op__t.html">op_t</a> &amp;rr = *r;
<a name="l02969"></a>02969       <span class="keywordtype">unsigned</span> reg = rr.<a class="code" href="classopndcoll__rfu__t_1_1op__t.html#aea2dbb31537541e9bb9e8b0281ac185f">get_reg</a>();
<a name="l02970"></a>02970       <span class="keywordtype">unsigned</span> wid = rr.<a class="code" href="classopndcoll__rfu__t_1_1op__t.html#a91e315c37bb12b182c63d3745e10d90a">get_wid</a>();
<a name="l02971"></a>02971       <span class="keywordtype">unsigned</span> bank = <a class="code" href="shader_8cc.html#a1284ac0a0c72fa3a3d27a7c3bcf32ea5">register_bank</a>(reg,wid,<a class="code" href="classopndcoll__rfu__t.html#acffc1924bee3fe2be1030d33a0c042ec">m_num_banks</a>,<a class="code" href="classopndcoll__rfu__t.html#afe383eab3afc8915895b861cda6a7c13">m_bank_warp_shift</a>);
<a name="l02972"></a>02972       <a class="code" href="classopndcoll__rfu__t.html#a9961fece010ab32ea90584d02ce548e1">m_arbiter</a>.<a class="code" href="classopndcoll__rfu__t_1_1arbiter__t.html#a7d9b9ba2d2cea6436f768f9e408bac01">allocate_for_read</a>(bank,rr);
<a name="l02973"></a>02973       read_ops[bank] = rr;
<a name="l02974"></a>02974    }
<a name="l02975"></a>02975    std::map&lt;unsigned,op_t&gt;::iterator r;
<a name="l02976"></a>02976    <span class="keywordflow">for</span>(r=read_ops.begin();r!=read_ops.end();++r ) {
<a name="l02977"></a>02977       <a class="code" href="classopndcoll__rfu__t_1_1op__t.html">op_t</a> &amp;op = r-&gt;second;
<a name="l02978"></a>02978       <span class="keywordtype">unsigned</span> cu = op.<a class="code" href="classopndcoll__rfu__t_1_1op__t.html#abfcf6e681bd6e0aad650d215496a0a34">get_oc_id</a>();
<a name="l02979"></a>02979       <span class="keywordtype">unsigned</span> operand = op.<a class="code" href="classopndcoll__rfu__t_1_1op__t.html#a943795098af2b02f5657eb2f11bc11c8">get_operand</a>();
<a name="l02980"></a>02980       <a class="code" href="classopndcoll__rfu__t.html#a40be91a44de8048dd3c54de54177807c">m_cu</a>[cu]-&gt;collect_operand(operand);
<a name="l02981"></a>02981       <span class="keywordflow">if</span>(<a class="code" href="classopndcoll__rfu__t.html#a946511568d01f1831a2fa388b39d07bc">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#a0dfa04be25f749a0a690843a13db0881">get_config</a>()-&gt;<a class="code" href="structshader__core__config.html#adcdf4af92cb25889d1bad10cacbe612d">gpgpu_clock_gated_reg_file</a>){
<a name="l02982"></a>02982           <span class="keywordtype">unsigned</span> active_count=0;
<a name="l02983"></a>02983           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;<a class="code" href="classopndcoll__rfu__t.html#a946511568d01f1831a2fa388b39d07bc">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#a0dfa04be25f749a0a690843a13db0881">get_config</a>()-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>;i=i+<a class="code" href="classopndcoll__rfu__t.html#a946511568d01f1831a2fa388b39d07bc">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#a0dfa04be25f749a0a690843a13db0881">get_config</a>()-&gt;<a class="code" href="structshader__core__config.html#abd67e4a527a3ca5a722a5cae60189c03">n_regfile_gating_group</a>){
<a name="l02984"></a>02984               <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0;j&lt;<a class="code" href="classopndcoll__rfu__t.html#a946511568d01f1831a2fa388b39d07bc">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#a0dfa04be25f749a0a690843a13db0881">get_config</a>()-&gt;<a class="code" href="structshader__core__config.html#abd67e4a527a3ca5a722a5cae60189c03">n_regfile_gating_group</a>;j++){
<a name="l02985"></a>02985                   <span class="keywordflow">if</span>(op.<a class="code" href="classopndcoll__rfu__t_1_1op__t.html#a7fdc5ab7e123cb069b180e012f007020">get_active_mask</a>().test(i+j)){
<a name="l02986"></a>02986                       active_count+=<a class="code" href="classopndcoll__rfu__t.html#a946511568d01f1831a2fa388b39d07bc">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#a0dfa04be25f749a0a690843a13db0881">get_config</a>()-&gt;<a class="code" href="structshader__core__config.html#abd67e4a527a3ca5a722a5cae60189c03">n_regfile_gating_group</a>;
<a name="l02987"></a>02987                       <span class="keywordflow">break</span>;
<a name="l02988"></a>02988                   }
<a name="l02989"></a>02989               }
<a name="l02990"></a>02990           }
<a name="l02991"></a>02991           <a class="code" href="classopndcoll__rfu__t.html#a946511568d01f1831a2fa388b39d07bc">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#a178cfa180822c7fa464684a99867cdfb">incregfile_reads</a>(active_count);
<a name="l02992"></a>02992       }<span class="keywordflow">else</span>{
<a name="l02993"></a>02993           <a class="code" href="classopndcoll__rfu__t.html#a946511568d01f1831a2fa388b39d07bc">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#a178cfa180822c7fa464684a99867cdfb">incregfile_reads</a>(<a class="code" href="classopndcoll__rfu__t.html#a946511568d01f1831a2fa388b39d07bc">m_shader</a>-&gt;<a class="code" href="classshader__core__ctx.html#a0dfa04be25f749a0a690843a13db0881">get_config</a>()-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>);<span class="comment">//op.get_active_count());</span>
<a name="l02994"></a>02994       }
<a name="l02995"></a>02995   }
<a name="l02996"></a>02996 } 
<a name="l02997"></a>02997 
<a name="l02998"></a><a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#a4db6feda52874fd30e8d1dad4ed7832e">02998</a> <span class="keywordtype">bool</span> <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#a4db6feda52874fd30e8d1dad4ed7832e">opndcoll_rfu_t::collector_unit_t::ready</a>()<span class="keyword"> const </span>
<a name="l02999"></a>02999 <span class="keyword"></span>{ 
<a name="l03000"></a>03000    <span class="keywordflow">return</span> (!<a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#abd0a8c581bd5749feaa59c36b22ccf37">m_free</a>) &amp;&amp; <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#a741fe75d3c9ba50c48580690d8a2f9fd">m_not_ready</a>.none() &amp;&amp; (*m_output_register).has_free(); 
<a name="l03001"></a>03001 }
<a name="l03002"></a>03002 
<a name="l03003"></a><a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#a870d208cb7944c61cf07645f9c46d7f2">03003</a> <span class="keywordtype">void</span> <a class="code" href="classopndcoll__rfu__t.html#a644f00038d535e92da930beb68524ec1">opndcoll_rfu_t::collector_unit_t::dump</a>(FILE *fp, <span class="keyword">const</span> <a class="code" href="classshader__core__ctx.html">shader_core_ctx</a> *shader )<span class="keyword"> const</span>
<a name="l03004"></a>03004 <span class="keyword"></span>{
<a name="l03005"></a>03005    <span class="keywordflow">if</span>( <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#abd0a8c581bd5749feaa59c36b22ccf37">m_free</a> ) {
<a name="l03006"></a>03006       fprintf(fp,<span class="stringliteral">&quot;    &lt;free&gt;\n&quot;</span>);
<a name="l03007"></a>03007    } <span class="keywordflow">else</span> {
<a name="l03008"></a>03008       <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#ac66f8448f715af371d43b0056cf22d96">m_warp</a>-&gt;<a class="code" href="classwarp__inst__t.html#a55adcc62951f84d8b005c0a8a1a056e2">print</a>(fp);
<a name="l03009"></a>03009       <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i &lt; MAX_REG_OPERANDS*2; i++ ) {
<a name="l03010"></a>03010          <span class="keywordflow">if</span>( <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#a741fe75d3c9ba50c48580690d8a2f9fd">m_not_ready</a>.test(i) ) {
<a name="l03011"></a>03011             std::string r = <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#aeb7f326c78c768a6c94680eead3ef6f3">m_src_op</a>[i].<a class="code" href="classopndcoll__rfu__t_1_1op__t.html#acf64383fdf0b82df0d51160f358b70ec">get_reg_string</a>();
<a name="l03012"></a>03012             fprintf(fp,<span class="stringliteral">&quot;    &apos;%s&apos; not ready\n&quot;</span>, r.c_str() );
<a name="l03013"></a>03013          }
<a name="l03014"></a>03014       }
<a name="l03015"></a>03015    }
<a name="l03016"></a>03016 }
<a name="l03017"></a>03017 
<a name="l03018"></a><a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#a380cb0dbd04e44da368572a23445e0c5">03018</a> <span class="keywordtype">void</span> <a class="code" href="classopndcoll__rfu__t.html#a6a69c8d3f2952ce95e6ea8fffbbdba97">opndcoll_rfu_t::collector_unit_t::init</a>( <span class="keywordtype">unsigned</span> <a class="code" href="rng_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>, 
<a name="l03019"></a>03019                                              <span class="keywordtype">unsigned</span> num_banks, 
<a name="l03020"></a>03020                                              <span class="keywordtype">unsigned</span> log2_warp_size,
<a name="l03021"></a>03021                                              <span class="keyword">const</span> <a class="code" href="structcore__config.html">core_config</a> *config,
<a name="l03022"></a>03022                                              <a class="code" href="classopndcoll__rfu__t.html">opndcoll_rfu_t</a> *rfu ) 
<a name="l03023"></a>03023 { 
<a name="l03024"></a>03024    <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#aa0abc70b54d96d5915fcace9df95881f">m_rfu</a>=rfu;
<a name="l03025"></a>03025    <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#a35e9f8c7dc1a118c1f44f8fbfb9aca2a">m_cuid</a>=n; 
<a name="l03026"></a>03026    <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#a0c441ad3f1b5f55ca9d1f887bdf13e0a">m_num_banks</a>=num_banks;
<a name="l03027"></a>03027    assert(<a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#ac66f8448f715af371d43b0056cf22d96">m_warp</a>==NULL); 
<a name="l03028"></a>03028    <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#ac66f8448f715af371d43b0056cf22d96">m_warp</a> = <span class="keyword">new</span> <a class="code" href="classwarp__inst__t.html">warp_inst_t</a>(config);
<a name="l03029"></a>03029    <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#a6b3b4aada4bae6997c777d8623d0e4c4">m_bank_warp_shift</a>=log2_warp_size;
<a name="l03030"></a>03030 }
<a name="l03031"></a>03031 
<a name="l03032"></a><a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#a9cc0a41e77655e4d199c3bb423d84d55">03032</a> <span class="keywordtype">bool</span> <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#a9cc0a41e77655e4d199c3bb423d84d55">opndcoll_rfu_t::collector_unit_t::allocate</a>( <a class="code" href="classregister__set.html">register_set</a>* pipeline_reg_set, <a class="code" href="classregister__set.html">register_set</a>* output_reg_set ) 
<a name="l03033"></a>03033 {
<a name="l03034"></a>03034    assert(<a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#abd0a8c581bd5749feaa59c36b22ccf37">m_free</a>);
<a name="l03035"></a>03035    assert(<a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#a741fe75d3c9ba50c48580690d8a2f9fd">m_not_ready</a>.none());
<a name="l03036"></a>03036    <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#abd0a8c581bd5749feaa59c36b22ccf37">m_free</a> = <span class="keyword">false</span>;
<a name="l03037"></a>03037    <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#a43876fd028e7707435b2b47745891a6a">m_output_register</a> = output_reg_set;
<a name="l03038"></a>03038    <a class="code" href="classwarp__inst__t.html">warp_inst_t</a> **pipeline_reg = pipeline_reg_set-&gt;<a class="code" href="classregister__set.html#a736ba5ce2956c0c6814177768f50f07b">get_ready</a>();
<a name="l03039"></a>03039    <span class="keywordflow">if</span>( (pipeline_reg) and !((*pipeline_reg)-&gt;empty()) ) {
<a name="l03040"></a>03040       <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#aee4e0b39ee6515fb8aca152fd798ced2">m_warp_id</a> = (*pipeline_reg)-&gt;warp_id();
<a name="l03041"></a>03041       <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> op=0; op &lt; MAX_REG_OPERANDS; op++ ) {
<a name="l03042"></a>03042          <span class="keywordtype">int</span> reg_num = (*pipeline_reg)-&gt;arch_reg.src[op]; <span class="comment">// this math needs to match that used in function_info::ptx_decode_inst</span>
<a name="l03043"></a>03043          <span class="keywordflow">if</span>( reg_num &gt;= 0 ) { <span class="comment">// valid register</span>
<a name="l03044"></a>03044             <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#aeb7f326c78c768a6c94680eead3ef6f3">m_src_op</a>[op] = <a class="code" href="classopndcoll__rfu__t_1_1op__t.html">op_t</a>( <span class="keyword">this</span>, op, reg_num, <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#a0c441ad3f1b5f55ca9d1f887bdf13e0a">m_num_banks</a>, <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#a6b3b4aada4bae6997c777d8623d0e4c4">m_bank_warp_shift</a> );
<a name="l03045"></a>03045             <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#a741fe75d3c9ba50c48580690d8a2f9fd">m_not_ready</a>.set(op);
<a name="l03046"></a>03046          } <span class="keywordflow">else</span> 
<a name="l03047"></a>03047             <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#aeb7f326c78c768a6c94680eead3ef6f3">m_src_op</a>[op] = <a class="code" href="classopndcoll__rfu__t_1_1op__t.html">op_t</a>();
<a name="l03048"></a>03048       }
<a name="l03049"></a>03049       <span class="comment">//move_warp(m_warp,*pipeline_reg);</span>
<a name="l03050"></a>03050       pipeline_reg_set-&gt;<a class="code" href="classregister__set.html#ad689d3116b019bd30e84e0cd17101f94">move_out_to</a>(<a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#ac66f8448f715af371d43b0056cf22d96">m_warp</a>);
<a name="l03051"></a>03051       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03052"></a>03052    }
<a name="l03053"></a>03053    <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03054"></a>03054 }
<a name="l03055"></a>03055 
<a name="l03056"></a><a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#a2d93a33920b4b0d039e1711689bfd327">03056</a> <span class="keywordtype">void</span> <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#a2d93a33920b4b0d039e1711689bfd327">opndcoll_rfu_t::collector_unit_t::dispatch</a>()
<a name="l03057"></a>03057 {
<a name="l03058"></a>03058    assert( <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#a741fe75d3c9ba50c48580690d8a2f9fd">m_not_ready</a>.none() );
<a name="l03059"></a>03059    <span class="comment">//move_warp(*m_output_register,m_warp);</span>
<a name="l03060"></a>03060    <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#a43876fd028e7707435b2b47745891a6a">m_output_register</a>-&gt;<a class="code" href="classregister__set.html#aa1bc637d8a6b46e0f69749028ba2bfdf">move_in</a>(<a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#ac66f8448f715af371d43b0056cf22d96">m_warp</a>);
<a name="l03061"></a>03061    <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#abd0a8c581bd5749feaa59c36b22ccf37">m_free</a>=<span class="keyword">true</span>;
<a name="l03062"></a>03062    <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#a43876fd028e7707435b2b47745891a6a">m_output_register</a> = NULL;
<a name="l03063"></a>03063    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i&lt;MAX_REG_OPERANDS*2;i++)
<a name="l03064"></a>03064       <a class="code" href="classopndcoll__rfu__t_1_1collector__unit__t.html#aeb7f326c78c768a6c94680eead3ef6f3">m_src_op</a>[i].reset();
<a name="l03065"></a>03065 }
<a name="l03066"></a>03066 
<a name="l03067"></a><a class="code" href="classsimt__core__cluster.html#ad55773e952134901143f8c85c42f1f3d">03067</a> <a class="code" href="classsimt__core__cluster.html#ad55773e952134901143f8c85c42f1f3d">simt_core_cluster::simt_core_cluster</a>( <span class="keyword">class</span> <a class="code" href="classgpgpu__sim.html">gpgpu_sim</a> *gpu, 
<a name="l03068"></a>03068                                       <span class="keywordtype">unsigned</span> cluster_id, 
<a name="l03069"></a>03069                                       <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structshader__core__config.html">shader_core_config</a> *config, 
<a name="l03070"></a>03070                                       <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structmemory__config.html">memory_config</a> *mem_config,
<a name="l03071"></a>03071                                       <a class="code" href="classshader__core__stats.html">shader_core_stats</a> *stats, 
<a name="l03072"></a>03072                                       <span class="keyword">class</span> <a class="code" href="classmemory__stats__t.html">memory_stats_t</a> *mstats )
<a name="l03073"></a>03073 {
<a name="l03074"></a>03074     <a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a> = config;
<a name="l03075"></a>03075     <a class="code" href="classsimt__core__cluster.html#a61d0a6a5aba377ec8a6328e83439a040">m_cta_issue_next_core</a>=<a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a104c9f8d770de04280e3b2ef3618ea01">n_simt_cores_per_cluster</a>-1; <span class="comment">// this causes first launch to use hw cta 0</span>
<a name="l03076"></a>03076     <a class="code" href="classsimt__core__cluster.html#a32ece7c7f8d2f91f438aad34128ad0aa">m_cluster_id</a>=cluster_id;
<a name="l03077"></a>03077     <a class="code" href="classsimt__core__cluster.html#aa9b81f2c6ae8506ab6585d40aa385397">m_gpu</a> = gpu;
<a name="l03078"></a>03078     <a class="code" href="classsimt__core__cluster.html#aaaffcd1d7a7e598074cd1de5a5cfe7b6">m_stats</a> = stats;
<a name="l03079"></a>03079     <a class="code" href="classsimt__core__cluster.html#a2e6a1fe68953f90016f482920cae43ac">m_memory_stats</a> = mstats;
<a name="l03080"></a>03080     <a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a> = <span class="keyword">new</span> <a class="code" href="classshader__core__ctx.html">shader_core_ctx</a>*[ config-&gt;<a class="code" href="structshader__core__config.html#a104c9f8d770de04280e3b2ef3618ea01">n_simt_cores_per_cluster</a> ];
<a name="l03081"></a>03081     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i &lt; config-&gt;<a class="code" href="structshader__core__config.html#a104c9f8d770de04280e3b2ef3618ea01">n_simt_cores_per_cluster</a>; i++ ) {
<a name="l03082"></a>03082         <span class="keywordtype">unsigned</span> sid = <a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a5872bf33db645b99da0b5123b49cb6e3">cid_to_sid</a>(i,<a class="code" href="classsimt__core__cluster.html#a32ece7c7f8d2f91f438aad34128ad0aa">m_cluster_id</a>);
<a name="l03083"></a>03083         <a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a>[i] = <span class="keyword">new</span> <a class="code" href="classshader__core__ctx.html">shader_core_ctx</a>(gpu,<span class="keyword">this</span>,sid,<a class="code" href="classsimt__core__cluster.html#a32ece7c7f8d2f91f438aad34128ad0aa">m_cluster_id</a>,config,mem_config,stats);
<a name="l03084"></a>03084         <a class="code" href="classsimt__core__cluster.html#afb73b0ec353a60aeaf90c9dab47064ea">m_core_sim_order</a>.push_back(i); 
<a name="l03085"></a>03085     }
<a name="l03086"></a>03086 }
<a name="l03087"></a>03087 
<a name="l03088"></a><a class="code" href="classsimt__core__cluster.html#a4fd95f4e2be4b5ce7be423268859ab89">03088</a> <span class="keywordtype">void</span> <a class="code" href="classsimt__core__cluster.html#a4fd95f4e2be4b5ce7be423268859ab89">simt_core_cluster::core_cycle</a>()
<a name="l03089"></a>03089 {
<a name="l03090"></a>03090     <span class="keywordflow">for</span>( std::list&lt;unsigned&gt;::iterator it = <a class="code" href="classsimt__core__cluster.html#afb73b0ec353a60aeaf90c9dab47064ea">m_core_sim_order</a>.begin(); it != <a class="code" href="classsimt__core__cluster.html#afb73b0ec353a60aeaf90c9dab47064ea">m_core_sim_order</a>.end(); ++it ) {
<a name="l03091"></a>03091         <a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a>[*it]-&gt;<a class="code" href="classshader__core__ctx.html#aa890a6df3b96a815cb62448fd28409c6">cycle</a>();
<a name="l03092"></a>03092     }
<a name="l03093"></a>03093 
<a name="l03094"></a>03094     <span class="keywordflow">if</span> (<a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a7938abb814fd509de144aa80199730a1">simt_core_sim_order</a> == 1) {
<a name="l03095"></a>03095         <a class="code" href="classsimt__core__cluster.html#afb73b0ec353a60aeaf90c9dab47064ea">m_core_sim_order</a>.splice(<a class="code" href="classsimt__core__cluster.html#afb73b0ec353a60aeaf90c9dab47064ea">m_core_sim_order</a>.end(), <a class="code" href="classsimt__core__cluster.html#afb73b0ec353a60aeaf90c9dab47064ea">m_core_sim_order</a>, <a class="code" href="classsimt__core__cluster.html#afb73b0ec353a60aeaf90c9dab47064ea">m_core_sim_order</a>.begin()); 
<a name="l03096"></a>03096     }
<a name="l03097"></a>03097 }
<a name="l03098"></a>03098 
<a name="l03099"></a><a class="code" href="classsimt__core__cluster.html#ad4734e10efac0b7f0cf84668b0239957">03099</a> <span class="keywordtype">void</span> <a class="code" href="classsimt__core__cluster.html#ad4734e10efac0b7f0cf84668b0239957">simt_core_cluster::reinit</a>()
<a name="l03100"></a>03100 {
<a name="l03101"></a>03101     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i &lt; <a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a104c9f8d770de04280e3b2ef3618ea01">n_simt_cores_per_cluster</a>; i++ ) 
<a name="l03102"></a>03102         <a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a>[i]-&gt;<a class="code" href="classsimt__core__cluster.html#ad4734e10efac0b7f0cf84668b0239957">reinit</a>(0,<a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a559092b8eaeffafe04a61f83cefe74d2">n_thread_per_shader</a>,<span class="keyword">true</span>);
<a name="l03103"></a>03103 }
<a name="l03104"></a>03104 
<a name="l03105"></a><a class="code" href="classsimt__core__cluster.html#a7961d639f86f79a0f2d8e06f486e5c2e">03105</a> <span class="keywordtype">unsigned</span> <a class="code" href="classsimt__core__cluster.html#a7961d639f86f79a0f2d8e06f486e5c2e">simt_core_cluster::max_cta</a>( <span class="keyword">const</span> <a class="code" href="classkernel__info__t.html">kernel_info_t</a> &amp;kernel )
<a name="l03106"></a>03106 {
<a name="l03107"></a>03107     <span class="keywordflow">return</span> <a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a104c9f8d770de04280e3b2ef3618ea01">n_simt_cores_per_cluster</a> * <a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#af5142cb9479ef1fb1b429c88dc96254b">max_cta</a>(kernel);
<a name="l03108"></a>03108 }
<a name="l03109"></a>03109 
<a name="l03110"></a><a class="code" href="classsimt__core__cluster.html#a095497ca2c487133684f463df9303a72">03110</a> <span class="keywordtype">unsigned</span> <a class="code" href="classsimt__core__cluster.html#a095497ca2c487133684f463df9303a72">simt_core_cluster::get_not_completed</a>()<span class="keyword"> const</span>
<a name="l03111"></a>03111 <span class="keyword"></span>{
<a name="l03112"></a>03112     <span class="keywordtype">unsigned</span> not_completed=0;
<a name="l03113"></a>03113     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i &lt; <a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a104c9f8d770de04280e3b2ef3618ea01">n_simt_cores_per_cluster</a>; i++ ) 
<a name="l03114"></a>03114         not_completed += <a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a>[i]-&gt;<a class="code" href="classsimt__core__cluster.html#a095497ca2c487133684f463df9303a72">get_not_completed</a>();
<a name="l03115"></a>03115     <span class="keywordflow">return</span> not_completed;
<a name="l03116"></a>03116 }
<a name="l03117"></a>03117 
<a name="l03118"></a><a class="code" href="classsimt__core__cluster.html#a35b46a4958d4560ed9d8587ab77ee47e">03118</a> <span class="keywordtype">void</span> <a class="code" href="classsimt__core__cluster.html#a35b46a4958d4560ed9d8587ab77ee47e">simt_core_cluster::print_not_completed</a>( FILE *fp )<span class="keyword"> const</span>
<a name="l03119"></a>03119 <span class="keyword"></span>{
<a name="l03120"></a>03120     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i &lt; <a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a104c9f8d770de04280e3b2ef3618ea01">n_simt_cores_per_cluster</a>; i++ ) {
<a name="l03121"></a>03121         <span class="keywordtype">unsigned</span> not_completed=<a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a>[i]-&gt;<a class="code" href="classshader__core__ctx.html#ad845d721a6325cd0f4b73e0625f90629">get_not_completed</a>();
<a name="l03122"></a>03122         <span class="keywordtype">unsigned</span> sid=<a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a5872bf33db645b99da0b5123b49cb6e3">cid_to_sid</a>(i,<a class="code" href="classsimt__core__cluster.html#a32ece7c7f8d2f91f438aad34128ad0aa">m_cluster_id</a>);
<a name="l03123"></a>03123         fprintf(fp,<span class="stringliteral">&quot;%u(%u) &quot;</span>, sid, not_completed );
<a name="l03124"></a>03124     }
<a name="l03125"></a>03125 }
<a name="l03126"></a>03126 
<a name="l03127"></a><a class="code" href="classsimt__core__cluster.html#a36044eb386282c3c17c3179cfd8af07c">03127</a> <span class="keywordtype">unsigned</span> <a class="code" href="classsimt__core__cluster.html#a36044eb386282c3c17c3179cfd8af07c">simt_core_cluster::get_n_active_cta</a>()<span class="keyword"> const</span>
<a name="l03128"></a>03128 <span class="keyword"></span>{
<a name="l03129"></a>03129     <span class="keywordtype">unsigned</span> <a class="code" href="rng_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>=0;
<a name="l03130"></a>03130     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i &lt; <a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a104c9f8d770de04280e3b2ef3618ea01">n_simt_cores_per_cluster</a>; i++ ) 
<a name="l03131"></a>03131         n += <a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a>[i]-&gt;<a class="code" href="classsimt__core__cluster.html#a36044eb386282c3c17c3179cfd8af07c">get_n_active_cta</a>();
<a name="l03132"></a>03132     <span class="keywordflow">return</span> n;
<a name="l03133"></a>03133 }
<a name="l03134"></a>03134 
<a name="l03135"></a><a class="code" href="classsimt__core__cluster.html#af507ab86c92c4f6eaee46a3907479364">03135</a> <span class="keywordtype">unsigned</span> <a class="code" href="classsimt__core__cluster.html#af507ab86c92c4f6eaee46a3907479364">simt_core_cluster::get_n_active_sms</a>()<span class="keyword"> const</span>
<a name="l03136"></a>03136 <span class="keyword"></span>{
<a name="l03137"></a>03137     <span class="keywordtype">unsigned</span> <a class="code" href="rng_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>=0;
<a name="l03138"></a>03138     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i &lt; <a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a104c9f8d770de04280e3b2ef3618ea01">n_simt_cores_per_cluster</a>; i++ )
<a name="l03139"></a>03139         n += <a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a>[i]-&gt;isactive();
<a name="l03140"></a>03140     <span class="keywordflow">return</span> n;
<a name="l03141"></a>03141 }
<a name="l03142"></a>03142 
<a name="l03143"></a><a class="code" href="classsimt__core__cluster.html#a133955339eb7a7e5ae878912eab41593">03143</a> <span class="keywordtype">unsigned</span> <a class="code" href="classsimt__core__cluster.html#a133955339eb7a7e5ae878912eab41593">simt_core_cluster::issue_block2core</a>()
<a name="l03144"></a>03144 {
<a name="l03145"></a>03145     <span class="keywordtype">unsigned</span> num_blocks_issued=0;
<a name="l03146"></a>03146     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i &lt; <a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a104c9f8d770de04280e3b2ef3618ea01">n_simt_cores_per_cluster</a>; i++ ) {
<a name="l03147"></a>03147         <span class="keywordtype">unsigned</span> core = (i+<a class="code" href="classsimt__core__cluster.html#a61d0a6a5aba377ec8a6328e83439a040">m_cta_issue_next_core</a>+1)%<a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a104c9f8d770de04280e3b2ef3618ea01">n_simt_cores_per_cluster</a>;
<a name="l03148"></a>03148         <span class="keywordflow">if</span>( <a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a>[core]-&gt;<a class="code" href="classshader__core__ctx.html#ad845d721a6325cd0f4b73e0625f90629">get_not_completed</a>() == 0 ) {
<a name="l03149"></a>03149             <span class="keywordflow">if</span>( <a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a>[core]-&gt;get_kernel() == NULL ) {
<a name="l03150"></a>03150                 <a class="code" href="classkernel__info__t.html">kernel_info_t</a> *k = <a class="code" href="classsimt__core__cluster.html#aa9b81f2c6ae8506ab6585d40aa385397">m_gpu</a>-&gt;<a class="code" href="classgpgpu__sim.html#a1553293edb404940fd9a43a5f4de91cd">select_kernel</a>();
<a name="l03151"></a>03151                 <span class="keywordflow">if</span>( k ) 
<a name="l03152"></a>03152                     <a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a>[core]-&gt;<a class="code" href="classshader__core__ctx.html#a340f904a8397dc95c61a3a2d0e654444">set_kernel</a>(k);
<a name="l03153"></a>03153             }
<a name="l03154"></a>03154         }
<a name="l03155"></a>03155         <a class="code" href="classkernel__info__t.html">kernel_info_t</a> *kernel = <a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a>[core]-&gt;<a class="code" href="classshader__core__ctx.html#abe661cc61e560fa7c1947a5dcd3ad17c">get_kernel</a>();
<a name="l03156"></a>03156         <span class="keywordflow">if</span>( kernel &amp;&amp; !kernel-&gt;<a class="code" href="classkernel__info__t.html#a245a21ded3eebcf3b400a875f2eced46">no_more_ctas_to_run</a>() &amp;&amp; (<a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a>[core]-&gt;<a class="code" href="classshader__core__ctx.html#a3d44dfa98f3b9c6d6895603f0671c1d1">get_n_active_cta</a>() &lt; <a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#af5142cb9479ef1fb1b429c88dc96254b">max_cta</a>(*kernel)) ) {
<a name="l03157"></a>03157             <a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a>[core]-&gt;<a class="code" href="classshader__core__ctx.html#acb30e6cc6cd5cc783d29b28c8aa1614d">issue_block2core</a>(*kernel);
<a name="l03158"></a>03158             num_blocks_issued++;
<a name="l03159"></a>03159             <a class="code" href="classsimt__core__cluster.html#a61d0a6a5aba377ec8a6328e83439a040">m_cta_issue_next_core</a>=core; 
<a name="l03160"></a>03160             <span class="keywordflow">break</span>;
<a name="l03161"></a>03161         }
<a name="l03162"></a>03162     }
<a name="l03163"></a>03163     <span class="keywordflow">return</span> num_blocks_issued;
<a name="l03164"></a>03164 }
<a name="l03165"></a>03165 
<a name="l03166"></a><a class="code" href="classsimt__core__cluster.html#a42bbf8b6a62c3a916e0125b9b228fe5d">03166</a> <span class="keywordtype">void</span> <a class="code" href="classsimt__core__cluster.html#a42bbf8b6a62c3a916e0125b9b228fe5d">simt_core_cluster::cache_flush</a>()
<a name="l03167"></a>03167 {
<a name="l03168"></a>03168     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> i=0; i &lt; <a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a104c9f8d770de04280e3b2ef3618ea01">n_simt_cores_per_cluster</a>; i++ ) 
<a name="l03169"></a>03169         <a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a>[i]-&gt;<a class="code" href="classsimt__core__cluster.html#a42bbf8b6a62c3a916e0125b9b228fe5d">cache_flush</a>();
<a name="l03170"></a>03170 }
<a name="l03171"></a>03171 
<a name="l03172"></a><a class="code" href="classsimt__core__cluster.html#a9729c34cee03f576e6190542ff791b56">03172</a> <span class="keywordtype">bool</span> <a class="code" href="classsimt__core__cluster.html#a9729c34cee03f576e6190542ff791b56">simt_core_cluster::icnt_injection_buffer_full</a>(<span class="keywordtype">unsigned</span> size, <span class="keywordtype">bool</span> write)
<a name="l03173"></a>03173 {
<a name="l03174"></a>03174     <span class="keywordtype">unsigned</span> request_size = size;
<a name="l03175"></a>03175     <span class="keywordflow">if</span> (!write) 
<a name="l03176"></a>03176         request_size = READ_PACKET_SIZE;
<a name="l03177"></a>03177     <span class="keywordflow">return</span> !<a class="code" href="icnt__wrapper_8cc.html#a452eab43997f8f535acb20d10fbcb464"> ::icnt_has_buffer</a>(<a class="code" href="classsimt__core__cluster.html#a32ece7c7f8d2f91f438aad34128ad0aa">m_cluster_id</a>, request_size);
<a name="l03178"></a>03178 }
<a name="l03179"></a>03179 
<a name="l03180"></a><a class="code" href="classsimt__core__cluster.html#ac4e4aa65dde3af08ffd64954c2f5109b">03180</a> <span class="keywordtype">void</span> <a class="code" href="classsimt__core__cluster.html#ac4e4aa65dde3af08ffd64954c2f5109b">simt_core_cluster::icnt_inject_request_packet</a>(<span class="keyword">class</span> <a class="code" href="classmem__fetch.html">mem_fetch</a> *mf)
<a name="l03181"></a>03181 {
<a name="l03182"></a>03182     <span class="comment">// stats</span>
<a name="l03183"></a>03183     <span class="keywordflow">if</span> (mf-&gt;<a class="code" href="classmem__fetch.html#a0e449bde79c7162ec62c433338ac0293">get_is_write</a>()) <a class="code" href="classsimt__core__cluster.html#aaaffcd1d7a7e598074cd1de5a5cfe7b6">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a0a9ab4546d55290f0af764ed32d6dc81">made_write_mfs</a>++;
<a name="l03184"></a>03184     <span class="keywordflow">else</span> <a class="code" href="classsimt__core__cluster.html#aaaffcd1d7a7e598074cd1de5a5cfe7b6">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a65da0089377dba617b4000bed3118cb9">made_read_mfs</a>++;
<a name="l03185"></a>03185     switch (mf-&gt;<a class="code" href="classmem__fetch.html#ad6d11b27562271b7e6a99c76005021b1">get_access_type</a>()) {
<a name="l03186"></a>03186     <span class="keywordflow">case</span> CONST_ACC_R: <a class="code" href="classsimt__core__cluster.html#aaaffcd1d7a7e598074cd1de5a5cfe7b6">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#aa017876bbdc07c96da87f0320fcaff64">gpgpu_n_mem_const</a>++; <span class="keywordflow">break</span>;
<a name="l03187"></a>03187     <span class="keywordflow">case</span> TEXTURE_ACC_R: <a class="code" href="classsimt__core__cluster.html#aaaffcd1d7a7e598074cd1de5a5cfe7b6">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a531a02dc928208a1fed1981db287f8b6">gpgpu_n_mem_texture</a>++; <span class="keywordflow">break</span>;
<a name="l03188"></a>03188     <span class="keywordflow">case</span> GLOBAL_ACC_R: <a class="code" href="classsimt__core__cluster.html#aaaffcd1d7a7e598074cd1de5a5cfe7b6">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a2c3350864c49e362b1d6dae945ceab53">gpgpu_n_mem_read_global</a>++; <span class="keywordflow">break</span>;
<a name="l03189"></a>03189     <span class="keywordflow">case</span> GLOBAL_ACC_W: <a class="code" href="classsimt__core__cluster.html#aaaffcd1d7a7e598074cd1de5a5cfe7b6">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#afebac3fd1caa9f3fe318c6aff1d0e90a">gpgpu_n_mem_write_global</a>++; <span class="keywordflow">break</span>;
<a name="l03190"></a>03190     <span class="keywordflow">case</span> LOCAL_ACC_R: <a class="code" href="classsimt__core__cluster.html#aaaffcd1d7a7e598074cd1de5a5cfe7b6">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a9c2ef17eb5ea99529c46dac56f6e3d43">gpgpu_n_mem_read_local</a>++; <span class="keywordflow">break</span>;
<a name="l03191"></a>03191     <span class="keywordflow">case</span> LOCAL_ACC_W: <a class="code" href="classsimt__core__cluster.html#aaaffcd1d7a7e598074cd1de5a5cfe7b6">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#aaf3d94f40863d9638d8d2941d7bc786a">gpgpu_n_mem_write_local</a>++; <span class="keywordflow">break</span>;
<a name="l03192"></a>03192     <span class="keywordflow">case</span> INST_ACC_R: <a class="code" href="classsimt__core__cluster.html#aaaffcd1d7a7e598074cd1de5a5cfe7b6">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#ae6fee275eb198d03ca82d88cb7439154">gpgpu_n_mem_read_inst</a>++; <span class="keywordflow">break</span>;
<a name="l03193"></a>03193     <span class="keywordflow">case</span> L1_WRBK_ACC: <a class="code" href="classsimt__core__cluster.html#aaaffcd1d7a7e598074cd1de5a5cfe7b6">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#afebac3fd1caa9f3fe318c6aff1d0e90a">gpgpu_n_mem_write_global</a>++; <span class="keywordflow">break</span>;
<a name="l03194"></a>03194     <span class="keywordflow">case</span> L2_WRBK_ACC: <a class="code" href="classsimt__core__cluster.html#aaaffcd1d7a7e598074cd1de5a5cfe7b6">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a54d0dd1087c8107cc274ce9f2ca0fa1e">gpgpu_n_mem_l2_writeback</a>++; <span class="keywordflow">break</span>;
<a name="l03195"></a>03195     <span class="keywordflow">case</span> L1_WR_ALLOC_R: <a class="code" href="classsimt__core__cluster.html#aaaffcd1d7a7e598074cd1de5a5cfe7b6">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#add8f6b1681ff0c99a4d895d632229afb">gpgpu_n_mem_l1_write_allocate</a>++; <span class="keywordflow">break</span>;
<a name="l03196"></a>03196     <span class="keywordflow">case</span> L2_WR_ALLOC_R: <a class="code" href="classsimt__core__cluster.html#aaaffcd1d7a7e598074cd1de5a5cfe7b6">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#abefc9eb0271586e365bfda76386a31bd">gpgpu_n_mem_l2_write_allocate</a>++; <span class="keywordflow">break</span>;
<a name="l03197"></a>03197     <span class="keywordflow">default</span>: assert(0);
<a name="l03198"></a>03198     }
<a name="l03199"></a>03199 
<a name="l03200"></a>03200    <span class="comment">// The packet size varies depending on the type of request: </span>
<a name="l03201"></a>03201    <span class="comment">// - For write request and atomic request, the packet contains the data </span>
<a name="l03202"></a>03202    <span class="comment">// - For read request (i.e. not write nor atomic), the packet only has control metadata</span>
<a name="l03203"></a>03203    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> packet_size = mf-&gt;<a class="code" href="classmem__fetch.html#a8ae0f84b9c51d5f738964a53c54730b9">size</a>(); 
<a name="l03204"></a>03204    <span class="keywordflow">if</span> (!mf-&gt;<a class="code" href="classmem__fetch.html#a0e449bde79c7162ec62c433338ac0293">get_is_write</a>() &amp;&amp; !mf-&gt;<a class="code" href="classmem__fetch.html#aa5bcee879d65fa5954c35a05a50e7f5e">isatomic</a>()) {
<a name="l03205"></a>03205       packet_size = mf-&gt;<a class="code" href="classmem__fetch.html#a98e0c026a5fc79bd6a8aabe2204d5a33">get_ctrl_size</a>(); 
<a name="l03206"></a>03206    }
<a name="l03207"></a>03207    <a class="code" href="classsimt__core__cluster.html#aaaffcd1d7a7e598074cd1de5a5cfe7b6">m_stats</a>-&gt;<a class="code" href="classshader__core__stats.html#aea480ad72e59b87d900ef4b9491e4225">m_outgoing_traffic_stats</a>-&gt;<a class="code" href="classtraffic__breakdown.html#a7d331f3b0e145439409b4e729e205a59">record_traffic</a>(mf, packet_size); 
<a name="l03208"></a>03208    <span class="keywordtype">unsigned</span> destination = mf-&gt;<a class="code" href="classmem__fetch.html#a8c4e8b2934d81906b5dfbd1c826e6048">get_sub_partition_id</a>();
<a name="l03209"></a>03209    mf-&gt;<a class="code" href="classmem__fetch.html#acbda50764b3c8d6f79ffa279021253da">set_status</a>(IN_ICNT_TO_MEM,<a class="code" href="gpu-sim_8cc.html#a659fec271553d05e676c52314c8fcfe1">gpu_sim_cycle</a>+<a class="code" href="gpu-sim_8cc.html#acef6bbfd6ec09fe29e2641cace785058">gpu_tot_sim_cycle</a>);
<a name="l03210"></a>03210    <span class="keywordflow">if</span> (!mf-&gt;<a class="code" href="classmem__fetch.html#a0e449bde79c7162ec62c433338ac0293">get_is_write</a>() &amp;&amp; !mf-&gt;<a class="code" href="classmem__fetch.html#aa5bcee879d65fa5954c35a05a50e7f5e">isatomic</a>())
<a name="l03211"></a>03211       ::<a class="code" href="icnt__wrapper_8cc.html#a1a69b2b074d5360a225312dfafa9b270">icnt_push</a>(<a class="code" href="classsimt__core__cluster.html#a32ece7c7f8d2f91f438aad34128ad0aa">m_cluster_id</a>, <a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#ab014bf54b860bd0454c3e3a6da38758a">mem2device</a>(destination), (<span class="keywordtype">void</span>*)mf, mf-&gt;<a class="code" href="classmem__fetch.html#a98e0c026a5fc79bd6a8aabe2204d5a33">get_ctrl_size</a>() );
<a name="l03212"></a>03212    <a class="code" href="icnt__wrapper_8cc.html#a1a69b2b074d5360a225312dfafa9b270">else </a>
<a name="l03213"></a>03213 <a class="code" href="icnt__wrapper_8cc.html#a1a69b2b074d5360a225312dfafa9b270">      ::icnt_push</a>(<a class="code" href="classsimt__core__cluster.html#a32ece7c7f8d2f91f438aad34128ad0aa">m_cluster_id</a>, <a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#ab014bf54b860bd0454c3e3a6da38758a">mem2device</a>(destination), (<span class="keywordtype">void</span>*)mf, mf-&gt;<a class="code" href="classmem__fetch.html#a8ae0f84b9c51d5f738964a53c54730b9">size</a>());
<a name="l03214"></a>03214 }
<a name="l03215"></a>03215 
<a name="l03216"></a><a class="code" href="classsimt__core__cluster.html#a21f7cd2c5b1ea1703429dae45f5d669b">03216</a> <span class="keywordtype">void</span> <a class="code" href="classsimt__core__cluster.html#a21f7cd2c5b1ea1703429dae45f5d669b">simt_core_cluster::icnt_cycle</a>()
<a name="l03217"></a>03217 {
<a name="l03218"></a>03218     <span class="keywordflow">if</span>( !<a class="code" href="classsimt__core__cluster.html#ad6306ee6b1660694b6dd379e26336a6a">m_response_fifo</a>.empty() ) {
<a name="l03219"></a>03219         <a class="code" href="classmem__fetch.html">mem_fetch</a> *mf = <a class="code" href="classsimt__core__cluster.html#ad6306ee6b1660694b6dd379e26336a6a">m_response_fifo</a>.front();
<a name="l03220"></a>03220         <span class="keywordtype">unsigned</span> cid = <a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a9557fce0d7ca1fd1e8625daf6db48cba">sid_to_cid</a>(mf-&gt;<a class="code" href="classmem__fetch.html#a4feac2a897988e75f7694dc285a25771">get_sid</a>());
<a name="l03221"></a>03221         <span class="keywordflow">if</span>( mf-&gt;<a class="code" href="classmem__fetch.html#ad6d11b27562271b7e6a99c76005021b1">get_access_type</a>() == INST_ACC_R ) {
<a name="l03222"></a>03222             <span class="comment">// instruction fetch response</span>
<a name="l03223"></a>03223             <span class="keywordflow">if</span>( !<a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a>[cid]-&gt;fetch_unit_response_buffer_full() ) {
<a name="l03224"></a>03224                 <a class="code" href="classsimt__core__cluster.html#ad6306ee6b1660694b6dd379e26336a6a">m_response_fifo</a>.pop_front();
<a name="l03225"></a>03225                 <a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a>[cid]-&gt;<a class="code" href="classshader__core__ctx.html#a72dcf4891e3c01eef9a9826a1b7bda95">accept_fetch_response</a>(mf);
<a name="l03226"></a>03226             }
<a name="l03227"></a>03227         } <span class="keywordflow">else</span> {
<a name="l03228"></a>03228             <span class="comment">// data response</span>
<a name="l03229"></a>03229             <span class="keywordflow">if</span>( !<a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a>[cid]-&gt;ldst_unit_response_buffer_full() ) {
<a name="l03230"></a>03230                 <a class="code" href="classsimt__core__cluster.html#ad6306ee6b1660694b6dd379e26336a6a">m_response_fifo</a>.pop_front();
<a name="l03231"></a>03231                 <a class="code" href="classsimt__core__cluster.html#a2e6a1fe68953f90016f482920cae43ac">m_memory_stats</a>-&gt;<a class="code" href="classmemory__stats__t.html#a15c053f5179e8ab899d58ab6cf8f08df">memlatstat_read_done</a>(mf);
<a name="l03232"></a>03232                 <a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a>[cid]-&gt;<a class="code" href="classshader__core__ctx.html#a6bad3b5d1cda03c537e911da56e78111">accept_ldst_unit_response</a>(mf);
<a name="l03233"></a>03233             }
<a name="l03234"></a>03234         }
<a name="l03235"></a>03235     }
<a name="l03236"></a>03236     <span class="keywordflow">if</span>( <a class="code" href="classsimt__core__cluster.html#ad6306ee6b1660694b6dd379e26336a6a">m_response_fifo</a>.size() &lt; <a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#ac75c25ebdbd6e67d642e2aa3aa387971">n_simt_ejection_buffer_size</a> ) {
<a name="l03237"></a>03237         <a class="code" href="classmem__fetch.html">mem_fetch</a> *mf = (<a class="code" href="classmem__fetch.html">mem_fetch</a>*) ::<a class="code" href="icnt__wrapper_8cc.html#a3be0c1bc60622d3d78c2c48e8d2a58de">icnt_pop</a>(<a class="code" href="classsimt__core__cluster.html#a32ece7c7f8d2f91f438aad34128ad0aa">m_cluster_id</a>);
<a name="l03238"></a>03238         <span class="keywordflow">if</span> (!mf) 
<a name="l03239"></a>03239             <span class="keywordflow">return</span>;
<a name="l03240"></a>03240         assert(mf-&gt;<a class="code" href="classmem__fetch.html#ad17b8a2f85059a3068e55b9e51f273b1">get_tpc</a>() == <a class="code" href="classsimt__core__cluster.html#a32ece7c7f8d2f91f438aad34128ad0aa">m_cluster_id</a>);
<a name="l03241"></a>03241         assert(mf-&gt;<a class="code" href="classmem__fetch.html#a1b66843ccce20aaf75b53c91f2d7ad61">get_type</a>() == <a class="code" href="mem__fetch_8h.html#a5830ce559c805683000f5d82d6f0a234ad29ebe94017e26edd2d85fca99976299">READ_REPLY</a> || mf-&gt;<a class="code" href="classmem__fetch.html#a1b66843ccce20aaf75b53c91f2d7ad61">get_type</a>() == <a class="code" href="mem__fetch_8h.html#a5830ce559c805683000f5d82d6f0a234a84df0ac61ee4b6f007ec6373ed8b3223">WRITE_ACK</a> );
<a name="l03242"></a>03242 
<a name="l03243"></a>03243         <span class="comment">// The packet size varies depending on the type of request: </span>
<a name="l03244"></a>03244         <span class="comment">// - For read request and atomic request, the packet contains the data </span>
<a name="l03245"></a>03245         <span class="comment">// - For write-ack, the packet only has control metadata</span>
<a name="l03246"></a>03246         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> packet_size = (mf-&gt;<a class="code" href="classmem__fetch.html#a0e449bde79c7162ec62c433338ac0293">get_is_write</a>())? mf-&gt;<a class="code" href="classmem__fetch.html#a98e0c026a5fc79bd6a8aabe2204d5a33">get_ctrl_size</a>() : mf-&gt;<a class="code" href="classmem__fetch.html#a8ae0f84b9c51d5f738964a53c54730b9">size</a>(); 
<a name="l03247"></a>03247         <a class="code" href="classsimt__core__cluster.html#aaaffcd1d7a7e598074cd1de5a5cfe7b6">m_stats</a>-&gt;<a class="code" href="classshader__core__stats.html#a30a43fd19ee6b9f808f21ff2c11012fe">m_incoming_traffic_stats</a>-&gt;<a class="code" href="classtraffic__breakdown.html#a7d331f3b0e145439409b4e729e205a59">record_traffic</a>(mf, packet_size); 
<a name="l03248"></a>03248         mf-&gt;<a class="code" href="classmem__fetch.html#acbda50764b3c8d6f79ffa279021253da">set_status</a>(IN_CLUSTER_TO_SHADER_QUEUE,<a class="code" href="gpu-sim_8cc.html#a659fec271553d05e676c52314c8fcfe1">gpu_sim_cycle</a>+<a class="code" href="gpu-sim_8cc.html#acef6bbfd6ec09fe29e2641cace785058">gpu_tot_sim_cycle</a>);
<a name="l03249"></a>03249         <span class="comment">//m_memory_stats-&gt;memlatstat_read_done(mf,m_shader_config-&gt;max_warps_per_shader);</span>
<a name="l03250"></a>03250         <a class="code" href="classsimt__core__cluster.html#ad6306ee6b1660694b6dd379e26336a6a">m_response_fifo</a>.push_back(mf);
<a name="l03251"></a>03251         <a class="code" href="classsimt__core__cluster.html#aaaffcd1d7a7e598074cd1de5a5cfe7b6">m_stats</a>-&gt;<a class="code" href="structshader__core__stats__pod.html#a06f927877d9c7bd2cf60d494ae2011a6">n_mem_to_simt</a>[<a class="code" href="classsimt__core__cluster.html#a32ece7c7f8d2f91f438aad34128ad0aa">m_cluster_id</a>] += mf-&gt;<a class="code" href="classmem__fetch.html#a079d4ffc13adc5bb433c4775aabf1a76" title="Returns number of flits traversing interconnect. simt_to_mem specifies the direction...">get_num_flits</a>(<span class="keyword">false</span>);
<a name="l03252"></a>03252     }
<a name="l03253"></a>03253 }
<a name="l03254"></a>03254 
<a name="l03255"></a><a class="code" href="classsimt__core__cluster.html#af90ed66c3f1d26b81bf2a2c6c05a69e4">03255</a> <span class="keywordtype">void</span> <a class="code" href="classsimt__core__cluster.html#af90ed66c3f1d26b81bf2a2c6c05a69e4">simt_core_cluster::get_pdom_stack_top_info</a>( <span class="keywordtype">unsigned</span> sid, <span class="keywordtype">unsigned</span> tid, <span class="keywordtype">unsigned</span> *pc, <span class="keywordtype">unsigned</span> *rpc )<span class="keyword"> const</span>
<a name="l03256"></a>03256 <span class="keyword"></span>{
<a name="l03257"></a>03257     <span class="keywordtype">unsigned</span> cid = <a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a9557fce0d7ca1fd1e8625daf6db48cba">sid_to_cid</a>(sid);
<a name="l03258"></a>03258     <a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a>[cid]-&gt;<a class="code" href="classshader__core__ctx.html#a2dacf18ba045bb4376ce5cca4581da99">get_pdom_stack_top_info</a>(tid,pc,rpc);
<a name="l03259"></a>03259 }
<a name="l03260"></a>03260 
<a name="l03261"></a><a class="code" href="classsimt__core__cluster.html#a711c5d974ab3611eb03c25c42ff97997">03261</a> <span class="keywordtype">void</span> <a class="code" href="classsimt__core__cluster.html#a711c5d974ab3611eb03c25c42ff97997">simt_core_cluster::display_pipeline</a>( <span class="keywordtype">unsigned</span> sid, FILE *fout, <span class="keywordtype">int</span> print_mem, <span class="keywordtype">int</span> mask )
<a name="l03262"></a>03262 {
<a name="l03263"></a>03263     <a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a>[<a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a9557fce0d7ca1fd1e8625daf6db48cba">sid_to_cid</a>(sid)]-&gt;<a class="code" href="classshader__core__ctx.html#a8e58be74671cfdc92a493fcdd84ab5e3">display_pipeline</a>(fout,print_mem,mask);
<a name="l03264"></a>03264 
<a name="l03265"></a>03265     fprintf(fout,<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l03266"></a>03266     fprintf(fout,<span class="stringliteral">&quot;Cluster %u pipeline state\n&quot;</span>, <a class="code" href="classsimt__core__cluster.html#a32ece7c7f8d2f91f438aad34128ad0aa">m_cluster_id</a> );
<a name="l03267"></a>03267     fprintf(fout,<span class="stringliteral">&quot;Response FIFO (occupancy = %zu):\n&quot;</span>, <a class="code" href="classsimt__core__cluster.html#ad6306ee6b1660694b6dd379e26336a6a">m_response_fifo</a>.size() );
<a name="l03268"></a>03268     <span class="keywordflow">for</span>( std::list&lt;mem_fetch*&gt;::const_iterator i=<a class="code" href="classsimt__core__cluster.html#ad6306ee6b1660694b6dd379e26336a6a">m_response_fifo</a>.begin(); i != <a class="code" href="classsimt__core__cluster.html#ad6306ee6b1660694b6dd379e26336a6a">m_response_fifo</a>.end(); i++ ) {
<a name="l03269"></a>03269         <span class="keyword">const</span> <a class="code" href="classmem__fetch.html">mem_fetch</a> *mf = *i;
<a name="l03270"></a>03270         mf-&gt;<a class="code" href="classmem__fetch.html#a604c79db27d4ce4e6d83d76db53ce00e">print</a>(fout);
<a name="l03271"></a>03271     }
<a name="l03272"></a>03272 }
<a name="l03273"></a>03273 
<a name="l03274"></a><a class="code" href="classsimt__core__cluster.html#a813e8560d307d9110b6c84cb21cb3893">03274</a> <span class="keywordtype">void</span> <a class="code" href="classsimt__core__cluster.html#a813e8560d307d9110b6c84cb21cb3893">simt_core_cluster::print_cache_stats</a>( FILE *fp, <span class="keywordtype">unsigned</span>&amp; dl1_accesses, <span class="keywordtype">unsigned</span>&amp; dl1_misses )<span class="keyword"> const </span>{
<a name="l03275"></a>03275    <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> i = 0; i &lt; <a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a104c9f8d770de04280e3b2ef3618ea01">n_simt_cores_per_cluster</a>; ++i ) {
<a name="l03276"></a>03276       <a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a>[ i ]-&gt;<a class="code" href="classshader__core__ctx.html#a3d2731bcd032c7d4a1cf553edd129265">print_cache_stats</a>( fp, dl1_accesses, dl1_misses );
<a name="l03277"></a>03277    }
<a name="l03278"></a>03278 }
<a name="l03279"></a>03279 
<a name="l03280"></a><a class="code" href="classsimt__core__cluster.html#acf9ec05eadf047aa5eaa3cbb20888eb3">03280</a> <span class="keywordtype">void</span> <a class="code" href="classsimt__core__cluster.html#acf9ec05eadf047aa5eaa3cbb20888eb3">simt_core_cluster::get_icnt_stats</a>(<span class="keywordtype">long</span> &amp;n_simt_to_mem, <span class="keywordtype">long</span> &amp;n_mem_to_simt)<span class="keyword"> const </span>{
<a name="l03281"></a>03281     <span class="keywordtype">long</span> simt_to_mem=0;
<a name="l03282"></a>03282     <span class="keywordtype">long</span> mem_to_simt=0;
<a name="l03283"></a>03283     <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> i = 0; i &lt; <a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a104c9f8d770de04280e3b2ef3618ea01">n_simt_cores_per_cluster</a>; ++i ) {
<a name="l03284"></a>03284         <a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a>[i]-&gt;<a class="code" href="classshader__core__ctx.html#a4c1c2b2fa01fbd013aab0a64e9da0962">get_icnt_power_stats</a>(simt_to_mem, mem_to_simt);
<a name="l03285"></a>03285     }
<a name="l03286"></a>03286     n_simt_to_mem = simt_to_mem;
<a name="l03287"></a>03287     n_mem_to_simt = mem_to_simt;
<a name="l03288"></a>03288 }
<a name="l03289"></a>03289 
<a name="l03290"></a><a class="code" href="classsimt__core__cluster.html#a503d300129a40249fb9dc41dfb13578e">03290</a> <span class="keywordtype">void</span> <a class="code" href="classsimt__core__cluster.html#a503d300129a40249fb9dc41dfb13578e">simt_core_cluster::get_cache_stats</a>(<a class="code" href="classcache__stats.html">cache_stats</a> &amp;cs)<span class="keyword"> const</span>{
<a name="l03291"></a>03291     <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> i = 0; i &lt; <a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a104c9f8d770de04280e3b2ef3618ea01">n_simt_cores_per_cluster</a>; ++i ) {
<a name="l03292"></a>03292         <a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a>[i]-&gt;<a class="code" href="classshader__core__ctx.html#acb7551ea3df499b66367b703bab87b82">get_cache_stats</a>(cs);
<a name="l03293"></a>03293     }
<a name="l03294"></a>03294 }
<a name="l03295"></a>03295 
<a name="l03296"></a><a class="code" href="classsimt__core__cluster.html#aa84c052767266e1ea61c7dc4b5281f61">03296</a> <span class="keywordtype">void</span> <a class="code" href="classsimt__core__cluster.html#aa84c052767266e1ea61c7dc4b5281f61">simt_core_cluster::get_L1I_sub_stats</a>(<span class="keyword">struct</span> <a class="code" href="structcache__sub__stats.html">cache_sub_stats</a> &amp;css)<span class="keyword"> const</span>{
<a name="l03297"></a>03297     <span class="keyword">struct </span><a class="code" href="structcache__sub__stats.html">cache_sub_stats</a> temp_css;
<a name="l03298"></a>03298     <span class="keyword">struct </span><a class="code" href="structcache__sub__stats.html">cache_sub_stats</a> total_css;
<a name="l03299"></a>03299     temp_css.<a class="code" href="structcache__sub__stats.html#a4d2c836830777dc9daa30e14609d1e06">clear</a>();
<a name="l03300"></a>03300     total_css.<a class="code" href="structcache__sub__stats.html#a4d2c836830777dc9daa30e14609d1e06">clear</a>();
<a name="l03301"></a>03301     <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> i = 0; i &lt; <a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a104c9f8d770de04280e3b2ef3618ea01">n_simt_cores_per_cluster</a>; ++i ) {
<a name="l03302"></a>03302         <a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a>[i]-&gt;<a class="code" href="classshader__core__ctx.html#abec73e6461b4560d83281a3a71268fbf">get_L1I_sub_stats</a>(temp_css);
<a name="l03303"></a>03303         total_css += temp_css;
<a name="l03304"></a>03304     }
<a name="l03305"></a>03305     css = total_css;
<a name="l03306"></a>03306 }
<a name="l03307"></a><a class="code" href="classsimt__core__cluster.html#afded1adf25fe48b5c4e5a6a628f361de">03307</a> <span class="keywordtype">void</span> <a class="code" href="classsimt__core__cluster.html#afded1adf25fe48b5c4e5a6a628f361de">simt_core_cluster::get_L1D_sub_stats</a>(<span class="keyword">struct</span> <a class="code" href="structcache__sub__stats.html">cache_sub_stats</a> &amp;css)<span class="keyword"> const</span>{
<a name="l03308"></a>03308     <span class="keyword">struct </span><a class="code" href="structcache__sub__stats.html">cache_sub_stats</a> temp_css;
<a name="l03309"></a>03309     <span class="keyword">struct </span><a class="code" href="structcache__sub__stats.html">cache_sub_stats</a> total_css;
<a name="l03310"></a>03310     temp_css.<a class="code" href="structcache__sub__stats.html#a4d2c836830777dc9daa30e14609d1e06">clear</a>();
<a name="l03311"></a>03311     total_css.<a class="code" href="structcache__sub__stats.html#a4d2c836830777dc9daa30e14609d1e06">clear</a>();
<a name="l03312"></a>03312     <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> i = 0; i &lt; <a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a104c9f8d770de04280e3b2ef3618ea01">n_simt_cores_per_cluster</a>; ++i ) {
<a name="l03313"></a>03313         <a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a>[i]-&gt;<a class="code" href="classshader__core__ctx.html#ab1522e0e0fee39d41965575832b3a7a9">get_L1D_sub_stats</a>(temp_css);
<a name="l03314"></a>03314         total_css += temp_css;
<a name="l03315"></a>03315     }
<a name="l03316"></a>03316     css = total_css;
<a name="l03317"></a>03317 }
<a name="l03318"></a><a class="code" href="classsimt__core__cluster.html#abca528f41482b5b1a165cc31b6c7c66d">03318</a> <span class="keywordtype">void</span> <a class="code" href="classsimt__core__cluster.html#abca528f41482b5b1a165cc31b6c7c66d">simt_core_cluster::get_L1C_sub_stats</a>(<span class="keyword">struct</span> <a class="code" href="structcache__sub__stats.html">cache_sub_stats</a> &amp;css)<span class="keyword"> const</span>{
<a name="l03319"></a>03319     <span class="keyword">struct </span><a class="code" href="structcache__sub__stats.html">cache_sub_stats</a> temp_css;
<a name="l03320"></a>03320     <span class="keyword">struct </span><a class="code" href="structcache__sub__stats.html">cache_sub_stats</a> total_css;
<a name="l03321"></a>03321     temp_css.<a class="code" href="structcache__sub__stats.html#a4d2c836830777dc9daa30e14609d1e06">clear</a>();
<a name="l03322"></a>03322     total_css.<a class="code" href="structcache__sub__stats.html#a4d2c836830777dc9daa30e14609d1e06">clear</a>();
<a name="l03323"></a>03323     <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> i = 0; i &lt; <a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a104c9f8d770de04280e3b2ef3618ea01">n_simt_cores_per_cluster</a>; ++i ) {
<a name="l03324"></a>03324         <a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a>[i]-&gt;<a class="code" href="classshader__core__ctx.html#a86161c0c629a3981dd801386871c45f1">get_L1C_sub_stats</a>(temp_css);
<a name="l03325"></a>03325         total_css += temp_css;
<a name="l03326"></a>03326     }
<a name="l03327"></a>03327     css = total_css;
<a name="l03328"></a>03328 }
<a name="l03329"></a><a class="code" href="classsimt__core__cluster.html#a4b793aa21296aff9469c36b37197fbb8">03329</a> <span class="keywordtype">void</span> <a class="code" href="classsimt__core__cluster.html#a4b793aa21296aff9469c36b37197fbb8">simt_core_cluster::get_L1T_sub_stats</a>(<span class="keyword">struct</span> <a class="code" href="structcache__sub__stats.html">cache_sub_stats</a> &amp;css)<span class="keyword"> const</span>{
<a name="l03330"></a>03330     <span class="keyword">struct </span><a class="code" href="structcache__sub__stats.html">cache_sub_stats</a> temp_css;
<a name="l03331"></a>03331     <span class="keyword">struct </span><a class="code" href="structcache__sub__stats.html">cache_sub_stats</a> total_css;
<a name="l03332"></a>03332     temp_css.<a class="code" href="structcache__sub__stats.html#a4d2c836830777dc9daa30e14609d1e06">clear</a>();
<a name="l03333"></a>03333     total_css.<a class="code" href="structcache__sub__stats.html#a4d2c836830777dc9daa30e14609d1e06">clear</a>();
<a name="l03334"></a>03334     <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> i = 0; i &lt; <a class="code" href="classsimt__core__cluster.html#af8b2faca0f3be5c74523b790627ba90b">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a104c9f8d770de04280e3b2ef3618ea01">n_simt_cores_per_cluster</a>; ++i ) {
<a name="l03335"></a>03335         <a class="code" href="classsimt__core__cluster.html#a6ef5998cf4f4e3007a843172475b2cb8">m_core</a>[i]-&gt;<a class="code" href="classshader__core__ctx.html#ab05a3859164ed38e61b8cfdf48e4a4bd">get_L1T_sub_stats</a>(temp_css);
<a name="l03336"></a>03336         total_css += temp_css;
<a name="l03337"></a>03337     }
<a name="l03338"></a>03338     css = total_css;
<a name="l03339"></a>03339 }
<a name="l03340"></a>03340 
<a name="l03341"></a><a class="code" href="classshader__core__ctx.html#a4d4c75861a8ece41de209f701197d6d6">03341</a> <span class="keywordtype">void</span> <a class="code" href="classshader__core__ctx.html#a4d4c75861a8ece41de209f701197d6d6">shader_core_ctx::checkExecutionStatusAndUpdate</a>(<a class="code" href="classwarp__inst__t.html">warp_inst_t</a> &amp;inst, <span class="keywordtype">unsigned</span> t, <span class="keywordtype">unsigned</span> tid)
<a name="l03342"></a>03342 {
<a name="l03343"></a>03343     <span class="keywordflow">if</span>( inst.<a class="code" href="classwarp__inst__t.html#a18c8a6b673bf545f55d6edef2928abd1">has_callback</a>(t) ) 
<a name="l03344"></a>03344            <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[inst.<a class="code" href="classwarp__inst__t.html#ab1dd215e5b3d4083cdb473d4f8bf8bf2">warp_id</a>()].inc_n_atomic();
<a name="l03345"></a>03345         <span class="keywordflow">if</span> (inst.<a class="code" href="classinst__t.html#a7830eb1cfe5a305e426d8530563c11da">space</a>.<a class="code" href="classmemory__space__t.html#a3923696fe191c32d4444d57295713783">is_local</a>() &amp;&amp; (inst.<a class="code" href="classinst__t.html#a2a7f0ff5bdc4a059f744487d2cf255bd">is_load</a>() || inst.<a class="code" href="classinst__t.html#a4a4af03ae60d4f77f84d07c0264a5354">is_store</a>())) {
<a name="l03346"></a>03346             <a class="code" href="abstract__hardware__model_8h.html#adcde2e548bc855c5cb446e23e38bd12d">new_addr_type</a> localaddrs[<a class="code" href="abstract__hardware__model_8h.html#acc19e1a3f40248ac6a83b3cdb3df9449">MAX_ACCESSES_PER_INSN_PER_THREAD</a>];
<a name="l03347"></a>03347             <span class="keywordtype">unsigned</span> num_addrs;
<a name="l03348"></a>03348             num_addrs = <a class="code" href="classshader__core__ctx.html#a0c8c252c80ac39881d7f9e9e509bfb92">translate_local_memaddr</a>(inst.<a class="code" href="classwarp__inst__t.html#ad6eb1b42860bc299f4674a7609bf6395">get_addr</a>(t), tid, <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a21b867d06fc4757d3a9b63404eb16692">n_simt_clusters</a>*<a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structshader__core__config.html#a104c9f8d770de04280e3b2ef3618ea01">n_simt_cores_per_cluster</a>,
<a name="l03349"></a>03349                    inst.<a class="code" href="classinst__t.html#a17ce412c0e2dc350263be5e20efb4b36">data_size</a>, (<a class="code" href="abstract__hardware__model_8h.html#adcde2e548bc855c5cb446e23e38bd12d">new_addr_type</a>*) localaddrs );
<a name="l03350"></a>03350             inst.<a class="code" href="classwarp__inst__t.html#afd733ed202cb8ea4a2fdfea5d1ed9e4d">set_addr</a>(t, (<a class="code" href="abstract__hardware__model_8h.html#adcde2e548bc855c5cb446e23e38bd12d">new_addr_type</a>*) localaddrs, num_addrs);
<a name="l03351"></a>03351         }
<a name="l03352"></a>03352         <span class="keywordflow">if</span> ( <a class="code" href="classcore__t.html#aef36fb0d504e2357a78da821249f617a">ptx_thread_done</a>(tid) ) {
<a name="l03353"></a>03353             <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[inst.<a class="code" href="classwarp__inst__t.html#ab1dd215e5b3d4083cdb473d4f8bf8bf2">warp_id</a>()].set_completed(t);
<a name="l03354"></a>03354             <a class="code" href="classshader__core__ctx.html#aee614f5a61e2900604f3b28e71a23947">m_warp</a>[inst.<a class="code" href="classwarp__inst__t.html#ab1dd215e5b3d4083cdb473d4f8bf8bf2">warp_id</a>()].ibuffer_flush();
<a name="l03355"></a>03355         }
<a name="l03356"></a>03356 
<a name="l03357"></a>03357     <span class="comment">// PC-Histogram Update </span>
<a name="l03358"></a>03358     <span class="keywordtype">unsigned</span> warp_id = inst.<a class="code" href="classwarp__inst__t.html#ab1dd215e5b3d4083cdb473d4f8bf8bf2">warp_id</a>(); 
<a name="l03359"></a>03359     <span class="keywordtype">unsigned</span> pc = inst.<a class="code" href="classinst__t.html#a76aea27709c3a0256c2615451c7daa56">pc</a>; 
<a name="l03360"></a>03360     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> t = 0; t &lt; <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a>; t++) {
<a name="l03361"></a>03361         <span class="keywordflow">if</span> (inst.<a class="code" href="classwarp__inst__t.html#ae44d8d3d283dc0ecf16db55f57f3c03d">active</a>(t)) {
<a name="l03362"></a>03362             <span class="keywordtype">int</span> tid = warp_id * <a class="code" href="classshader__core__ctx.html#aed6af92e2c101962bd5ffdb91196e684">m_config</a>-&gt;<a class="code" href="structcore__config.html#a13edb2e659903146089ba0e75ce36ed1">warp_size</a> + t; 
<a name="l03363"></a>03363             <a class="code" href="stat-tool_8cc.html#ad9e32471d0b9d1c203a111bf42672341">cflog_update_thread_pc</a>(<a class="code" href="classshader__core__ctx.html#a6477f9fb530039ae2de0307fcfedabbd">m_sid</a>, tid, pc);  
<a name="l03364"></a>03364         }
<a name="l03365"></a>03365     }
<a name="l03366"></a>03366 }
<a name="l03367"></a>03367 
</pre></div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 13 May 2014 for GPGPU-Sim by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
