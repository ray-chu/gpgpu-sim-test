<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>GPGPU-Sim: v3.x/libopencl/opencl_runtime_api.cc Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_c934b74ccb33d6b9bfd1e576787940d8.html">v3.x</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_dbedd5f44bccf6a41b20311432b80b7d.html">libopencl</a>
  </div>
</div>
<div class="contents">
<h1>opencl_runtime_api.cc</h1><a href="opencl__runtime__api_8cc.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* </span>
<a name="l00002"></a>00002 <span class="comment"> * opencl_runtime_api.cc</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * Copyright Â© 2009 by Tor M. Aamodt and the University of British Columbia, </span>
<a name="l00005"></a>00005 <span class="comment"> * Vancouver, BC V6T 1Z4, All Rights Reserved.</span>
<a name="l00006"></a>00006 <span class="comment"> * </span>
<a name="l00007"></a>00007 <span class="comment"> * THIS IS A LEGAL DOCUMENT BY DOWNLOADING GPGPU-SIM, YOU ARE AGREEING TO THESE</span>
<a name="l00008"></a>00008 <span class="comment"> * TERMS AND CONDITIONS.</span>
<a name="l00009"></a>00009 <span class="comment"> * </span>
<a name="l00010"></a>00010 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<a name="l00011"></a>00011 <span class="comment"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<a name="l00012"></a>00012 <span class="comment"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<a name="l00013"></a>00013 <span class="comment"> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNERS OR CONTRIBUTORS BE</span>
<a name="l00014"></a>00014 <span class="comment"> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<a name="l00015"></a>00015 <span class="comment"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<a name="l00016"></a>00016 <span class="comment"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<a name="l00017"></a>00017 <span class="comment"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<a name="l00018"></a>00018 <span class="comment"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<a name="l00019"></a>00019 <span class="comment"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<a name="l00020"></a>00020 <span class="comment"> * POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00021"></a>00021 <span class="comment"> * </span>
<a name="l00022"></a>00022 <span class="comment"> * NOTE: The files libcuda/cuda_runtime_api.c and src/cuda-sim/cuda-math.h</span>
<a name="l00023"></a>00023 <span class="comment"> * are derived from the CUDA Toolset available from http://www.nvidia.com/cuda</span>
<a name="l00024"></a>00024 <span class="comment"> * (property of NVIDIA).  The files benchmarks/BlackScholes/ and </span>
<a name="l00025"></a>00025 <span class="comment"> * benchmarks/template/ are derived from the CUDA SDK available from </span>
<a name="l00026"></a>00026 <span class="comment"> * http://www.nvidia.com/cuda (also property of NVIDIA).  The files from </span>
<a name="l00027"></a>00027 <span class="comment"> * src/intersim/ are derived from Booksim (a simulator provided with the </span>
<a name="l00028"></a>00028 <span class="comment"> * textbook &quot;Principles and Practices of Interconnection Networks&quot; available </span>
<a name="l00029"></a>00029 <span class="comment"> * from http://cva.stanford.edu/books/ppin/). As such, those files are bound by </span>
<a name="l00030"></a>00030 <span class="comment"> * the corresponding legal terms and conditions set forth separately (original </span>
<a name="l00031"></a>00031 <span class="comment"> * copyright notices are left in files from these sources and where we have </span>
<a name="l00032"></a>00032 <span class="comment"> * modified a file our copyright notice appears before the original copyright </span>
<a name="l00033"></a>00033 <span class="comment"> * notice).  </span>
<a name="l00034"></a>00034 <span class="comment"> * </span>
<a name="l00035"></a>00035 <span class="comment"> * Using this version of GPGPU-Sim requires a complete installation of CUDA </span>
<a name="l00036"></a>00036 <span class="comment"> * which is distributed seperately by NVIDIA under separate terms and </span>
<a name="l00037"></a>00037 <span class="comment"> * conditions.  To use this version of GPGPU-Sim with OpenCL requires a</span>
<a name="l00038"></a>00038 <span class="comment"> * recent version of NVIDIA&apos;s drivers which support OpenCL.</span>
<a name="l00039"></a>00039 <span class="comment"> * </span>
<a name="l00040"></a>00040 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<a name="l00041"></a>00041 <span class="comment"> * modification, are permitted provided that the following conditions are met:</span>
<a name="l00042"></a>00042 <span class="comment"> * </span>
<a name="l00043"></a>00043 <span class="comment"> * 1. Redistributions of source code must retain the above copyright notice,</span>
<a name="l00044"></a>00044 <span class="comment"> * this list of conditions and the following disclaimer.</span>
<a name="l00045"></a>00045 <span class="comment"> * </span>
<a name="l00046"></a>00046 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<a name="l00047"></a>00047 <span class="comment"> * this list of conditions and the following disclaimer in the documentation</span>
<a name="l00048"></a>00048 <span class="comment"> * and/or other materials provided with the distribution.</span>
<a name="l00049"></a>00049 <span class="comment"> * </span>
<a name="l00050"></a>00050 <span class="comment"> * 3. Neither the name of the University of British Columbia nor the names of</span>
<a name="l00051"></a>00051 <span class="comment"> * its contributors may be used to endorse or promote products derived from</span>
<a name="l00052"></a>00052 <span class="comment"> * this software without specific prior written permission.</span>
<a name="l00053"></a>00053 <span class="comment"> * </span>
<a name="l00054"></a>00054 <span class="comment"> * 4. This version of GPGPU-SIM is distributed freely for non-commercial use only.  </span>
<a name="l00055"></a>00055 <span class="comment"> *  </span>
<a name="l00056"></a>00056 <span class="comment"> * 5. No nonprofit user may place any restrictions on the use of this software,</span>
<a name="l00057"></a>00057 <span class="comment"> * including as modified by the user, by any other authorized user.</span>
<a name="l00058"></a>00058 <span class="comment"> * </span>
<a name="l00059"></a>00059 <span class="comment"> * 6. GPGPU-SIM was developed primarily by Tor M. Aamodt, Wilson W. L. Fung, </span>
<a name="l00060"></a>00060 <span class="comment"> * Ali Bakhoda, George L. Yuan, at the University of British Columbia, </span>
<a name="l00061"></a>00061 <span class="comment"> * Vancouver, BC V6T 1Z4</span>
<a name="l00062"></a>00062 <span class="comment"> */</span>
<a name="l00063"></a>00063 
<a name="l00064"></a>00064 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00065"></a>00065 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00066"></a>00066 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00067"></a>00067 <span class="preprocessor">#include &lt;assert.h&gt;</span>
<a name="l00068"></a>00068 <span class="preprocessor">#include &lt;time.h&gt;</span>
<a name="l00069"></a>00069 <span class="preprocessor">#ifdef OPENGL_SUPPORT</span>
<a name="l00070"></a>00070 <span class="preprocessor"></span><span class="preprocessor">#define GL_GLEXT_PROTOTYPES</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span><span class="preprocessor">#include &lt;GL/gl.h&gt;</span>
<a name="l00072"></a>00072 <span class="preprocessor">#endif</span>
<a name="l00073"></a>00073 <span class="preprocessor"></span>
<a name="l00074"></a>00074 <span class="preprocessor">#define __CUDA_RUNTIME_API_H__</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span><span class="preprocessor">#include &quot;host_defines.h&quot;</span>
<a name="l00076"></a>00076 <span class="preprocessor">#include &quot;builtin_types.h&quot;</span>
<a name="l00077"></a>00077 <span class="preprocessor">#include &quot;__cudaFatFormat.h&quot;</span>
<a name="l00078"></a>00078 <span class="preprocessor">#include &quot;../src/abstract_hardware_model.h&quot;</span>
<a name="l00079"></a>00079 <span class="preprocessor">#include &quot;../src/cuda-sim/cuda-sim.h&quot;</span>
<a name="l00080"></a>00080 <span class="preprocessor">#include &quot;../src/cuda-sim/ptx_loader.h&quot;</span>
<a name="l00081"></a>00081 <span class="preprocessor">#include &quot;../src/cuda-sim/ptx_ir.h&quot;</span>
<a name="l00082"></a>00082 <span class="preprocessor">#include &quot;../src/gpgpusim_entrypoint.h&quot;</span>
<a name="l00083"></a>00083 <span class="preprocessor">#include &quot;../src/gpgpu-sim/gpu-sim.h&quot;</span>
<a name="l00084"></a>00084 <span class="preprocessor">#include &quot;../src/gpgpu-sim/shader.h&quot;</span>
<a name="l00085"></a>00085 
<a name="l00086"></a>00086 <span class="comment">//#   define __my_func__    __PRETTY_FUNCTION__</span>
<a name="l00087"></a>00087 <span class="preprocessor"># if defined __cplusplus ? __GNUC_PREREQ (2, 6) : __GNUC_PREREQ (2, 4)</span>
<a name="l00088"></a>00088 <span class="preprocessor"></span><span class="preprocessor">#   define __my_func__    __func__</span>
<a name="l00089"></a>00089 <span class="preprocessor"></span><span class="preprocessor"># else</span>
<a name="l00090"></a>00090 <span class="preprocessor"></span><span class="preprocessor">#  if defined __STDC_VERSION__ &amp;&amp; __STDC_VERSION__ &gt;= 199901L</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span><span class="preprocessor">#   define __my_func__    __my_func__</span>
<a name="l00092"></a>00092 <span class="preprocessor"></span><span class="preprocessor">#  else</span>
<a name="l00093"></a>00093 <span class="preprocessor"></span><span class="preprocessor">#   define __my_func__    ((__const char *) 0)</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span><span class="preprocessor">#  endif</span>
<a name="l00095"></a>00095 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00096"></a>00096 <span class="preprocessor"></span>
<a name="l00097"></a>00097 <span class="preprocessor">#define CL_USE_DEPRECATED_OPENCL_1_0_APIS</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span><span class="preprocessor">#include &lt;CL/cl.h&gt;</span>
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00101"></a>00101 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00102"></a>00102 
<a name="l00103"></a><a class="code" href="opencl__runtime__api_8cc.html#a39aab942676c56e70bd1cb9ed952b4b1">00103</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="opencl__runtime__api_8cc.html#a39aab942676c56e70bd1cb9ed952b4b1">setErrCode</a>(cl_int *errcode_ret, cl_int err_code) {
<a name="l00104"></a>00104    <span class="keywordflow">if</span> ( errcode_ret ) {
<a name="l00105"></a>00105       *errcode_ret = err_code;
<a name="l00106"></a>00106    }
<a name="l00107"></a>00107 }
<a name="l00108"></a>00108 
<a name="l00109"></a><a class="code" href="struct__cl__context.html">00109</a> <span class="keyword">struct </span><a class="code" href="struct__cl__context.html">_cl_context</a> {
<a name="l00110"></a>00110    <a class="code" href="struct__cl__context.html#a6841afd8075a83248d8f2df41eb2ac0e">_cl_context</a>( cl_device_id gpu );
<a name="l00111"></a>00111    cl_device_id <a class="code" href="struct__cl__context.html#a4c3ca03c89afcb62809e47bd60adbe10">get_first_device</a>();
<a name="l00112"></a>00112    cl_mem <a class="code" href="struct__cl__context.html#aea614318eb7157c7212fd24755ebf163">CreateBuffer</a>(
<a name="l00113"></a>00113                cl_mem_flags flags,
<a name="l00114"></a>00114                <span class="keywordtype">size_t</span>       size ,
<a name="l00115"></a>00115                <span class="keywordtype">void</span> *       host_ptr,
<a name="l00116"></a>00116                cl_int *     errcode_ret );
<a name="l00117"></a>00117    cl_mem <a class="code" href="struct__cl__context.html#a0968653b329b998c0742940a377e6aa2">lookup_mem</a>( cl_mem m );
<a name="l00118"></a>00118 <span class="keyword">private</span>:
<a name="l00119"></a><a class="code" href="struct__cl__context.html#a750fe75a1cf1779dc5c8fecaef953034">00119</a>    <span class="keywordtype">unsigned</span> <a class="code" href="struct__cl__context.html#a750fe75a1cf1779dc5c8fecaef953034">m_uid</a>;
<a name="l00120"></a><a class="code" href="struct__cl__context.html#a8e11ff42c1ec91392d6275d8bedda1f4">00120</a>    cl_device_id <a class="code" href="struct__cl__context.html#a8e11ff42c1ec91392d6275d8bedda1f4">m_gpu</a>;
<a name="l00121"></a><a class="code" href="struct__cl__context.html#a87d08d4f1a5a7059dc2214dcdc0173e2">00121</a>    <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <a class="code" href="struct__cl__context.html#a87d08d4f1a5a7059dc2214dcdc0173e2">sm_context_uid</a>;
<a name="l00122"></a>00122 
<a name="l00123"></a><a class="code" href="struct__cl__context.html#a6f1dfbe16f401b0d8d578478e753123b">00123</a>    std::map&lt;<span class="keywordtype">void</span>*<span class="comment">/*host_ptr*/</span>,cl_mem&gt; <a class="code" href="struct__cl__context.html#a6f1dfbe16f401b0d8d578478e753123b">m_hostptr_to_cl_mem</a>;
<a name="l00124"></a><a class="code" href="struct__cl__context.html#a5fa44c815b36a73e04abb0d5e0cef05f">00124</a>    std::map&lt;cl_mem<span class="comment">/*device ptr*/</span>,cl_mem&gt; <a class="code" href="struct__cl__context.html#a5fa44c815b36a73e04abb0d5e0cef05f">m_devptr_to_cl_mem</a>;
<a name="l00125"></a>00125 };
<a name="l00126"></a>00126 
<a name="l00127"></a><a class="code" href="struct__cl__device__id.html">00127</a> <span class="keyword">struct </span><a class="code" href="struct__cl__device__id.html">_cl_device_id</a> {
<a name="l00128"></a><a class="code" href="struct__cl__device__id.html#a2bf32ec4ec514b8d33beaada022249b4">00128</a>    <a class="code" href="struct__cl__device__id.html#a2bf32ec4ec514b8d33beaada022249b4">_cl_device_id</a>(<a class="code" href="classgpgpu__sim.html">gpgpu_sim</a>* gpu) {<a class="code" href="struct__cl__device__id.html#a6d1fcf0dde34ee5db648d562bcedd155">m_id</a> = 0; <a class="code" href="struct__cl__device__id.html#a97ee58a79bf012833d027f73cc69d27f">m_next</a> = NULL; <a class="code" href="struct__cl__device__id.html#ab854a522a0fada3e0b048873b2295a73">m_gpgpu</a>=gpu;}
<a name="l00129"></a><a class="code" href="struct__cl__device__id.html#a4cbeaf09bb413549651e1acc704c2a40">00129</a>    <span class="keyword">struct </span><a class="code" href="struct__cl__device__id.html">_cl_device_id</a> *<a class="code" href="struct__cl__device__id.html#a4cbeaf09bb413549651e1acc704c2a40">next</a>() { <span class="keywordflow">return</span> <a class="code" href="struct__cl__device__id.html#a97ee58a79bf012833d027f73cc69d27f">m_next</a>; }
<a name="l00130"></a><a class="code" href="struct__cl__device__id.html#a4b4f1fb55b5839b282f27dd92f4af19a">00130</a>    <a class="code" href="classgpgpu__sim.html">gpgpu_sim</a> *<a class="code" href="struct__cl__device__id.html#a4b4f1fb55b5839b282f27dd92f4af19a">the_device</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="struct__cl__device__id.html#ab854a522a0fada3e0b048873b2295a73">m_gpgpu</a>; }
<a name="l00131"></a>00131 <span class="keyword">private</span>:
<a name="l00132"></a><a class="code" href="struct__cl__device__id.html#a6d1fcf0dde34ee5db648d562bcedd155">00132</a>    <span class="keywordtype">unsigned</span> <a class="code" href="struct__cl__device__id.html#a6d1fcf0dde34ee5db648d562bcedd155">m_id</a>;
<a name="l00133"></a><a class="code" href="struct__cl__device__id.html#ab854a522a0fada3e0b048873b2295a73">00133</a>    <a class="code" href="classgpgpu__sim.html">gpgpu_sim</a> *<a class="code" href="struct__cl__device__id.html#ab854a522a0fada3e0b048873b2295a73">m_gpgpu</a>;
<a name="l00134"></a><a class="code" href="struct__cl__device__id.html#a97ee58a79bf012833d027f73cc69d27f">00134</a>    <span class="keyword">struct </span><a class="code" href="struct__cl__device__id.html">_cl_device_id</a> *<a class="code" href="struct__cl__device__id.html#a97ee58a79bf012833d027f73cc69d27f">m_next</a>;
<a name="l00135"></a>00135 };
<a name="l00136"></a>00136 
<a name="l00137"></a><a class="code" href="struct__cl__command__queue.html">00137</a> <span class="keyword">struct </span><a class="code" href="struct__cl__command__queue.html">_cl_command_queue</a> 
<a name="l00138"></a>00138 { 
<a name="l00139"></a><a class="code" href="struct__cl__command__queue.html#afc5b6a2081db7d5e454caed24d635be0">00139</a>    <a class="code" href="struct__cl__command__queue.html#afc5b6a2081db7d5e454caed24d635be0">_cl_command_queue</a>( cl_context context, cl_device_id device, cl_command_queue_properties properties ) 
<a name="l00140"></a>00140    {
<a name="l00141"></a>00141       <a class="code" href="struct__cl__command__queue.html#a1acc67b8de4c65179cef349cea3ec113">m_valid</a> = <span class="keyword">true</span>;
<a name="l00142"></a>00142       <a class="code" href="struct__cl__command__queue.html#a5688ad6798efdab853cc7f0cdd45a7bd">m_context</a> = context;
<a name="l00143"></a>00143       <a class="code" href="struct__cl__command__queue.html#a6ef437a9aad64d0afa2a442297ddf5e2">m_device</a> = device;
<a name="l00144"></a>00144       <a class="code" href="struct__cl__command__queue.html#aac4425697fff92d2e9f07280c284ef6b">m_properties</a> = properties;
<a name="l00145"></a>00145    }
<a name="l00146"></a><a class="code" href="struct__cl__command__queue.html#a010104a311439ba33b5fad7d35ca5ac4">00146</a>    <span class="keywordtype">bool</span> <a class="code" href="struct__cl__command__queue.html#a010104a311439ba33b5fad7d35ca5ac4">is_valid</a>() { <span class="keywordflow">return</span> <a class="code" href="struct__cl__command__queue.html#a1acc67b8de4c65179cef349cea3ec113">m_valid</a>; }
<a name="l00147"></a><a class="code" href="struct__cl__command__queue.html#a8c6f36aedf15dc513a68889f801803d5">00147</a>    cl_context <a class="code" href="struct__cl__command__queue.html#a8c6f36aedf15dc513a68889f801803d5">get_context</a>() { <span class="keywordflow">return</span> <a class="code" href="struct__cl__command__queue.html#a5688ad6798efdab853cc7f0cdd45a7bd">m_context</a>; }
<a name="l00148"></a><a class="code" href="struct__cl__command__queue.html#a7bb1ae13a87ecc96248043306843cb7a">00148</a>    cl_device_id <a class="code" href="struct__cl__command__queue.html#a7bb1ae13a87ecc96248043306843cb7a">get_device</a>() { <span class="keywordflow">return</span> <a class="code" href="struct__cl__command__queue.html#a6ef437a9aad64d0afa2a442297ddf5e2">m_device</a>; }
<a name="l00149"></a><a class="code" href="struct__cl__command__queue.html#acae5bea77dc81864da9be9319528cd6d">00149</a>    cl_command_queue_properties <a class="code" href="struct__cl__command__queue.html#acae5bea77dc81864da9be9319528cd6d">get_properties</a>() { <span class="keywordflow">return</span> <a class="code" href="struct__cl__command__queue.html#aac4425697fff92d2e9f07280c284ef6b">m_properties</a>; }
<a name="l00150"></a>00150 <span class="keyword">private</span>:
<a name="l00151"></a><a class="code" href="struct__cl__command__queue.html#a1acc67b8de4c65179cef349cea3ec113">00151</a>    <span class="keywordtype">bool</span> <a class="code" href="struct__cl__command__queue.html#a1acc67b8de4c65179cef349cea3ec113">m_valid</a>;
<a name="l00152"></a><a class="code" href="struct__cl__command__queue.html#a5688ad6798efdab853cc7f0cdd45a7bd">00152</a>    cl_context                     <a class="code" href="struct__cl__command__queue.html#a5688ad6798efdab853cc7f0cdd45a7bd">m_context</a>;
<a name="l00153"></a><a class="code" href="struct__cl__command__queue.html#a6ef437a9aad64d0afa2a442297ddf5e2">00153</a>    cl_device_id                   <a class="code" href="struct__cl__command__queue.html#a6ef437a9aad64d0afa2a442297ddf5e2">m_device</a>;
<a name="l00154"></a><a class="code" href="struct__cl__command__queue.html#aac4425697fff92d2e9f07280c284ef6b">00154</a>    cl_command_queue_properties    <a class="code" href="struct__cl__command__queue.html#aac4425697fff92d2e9f07280c284ef6b">m_properties</a>;
<a name="l00155"></a>00155 };
<a name="l00156"></a>00156 
<a name="l00157"></a><a class="code" href="struct__cl__mem.html">00157</a> <span class="keyword">struct </span><a class="code" href="struct__cl__mem.html">_cl_mem</a> {
<a name="l00158"></a>00158    <a class="code" href="struct__cl__mem.html#a3fc58e0ab1f4081d9dd8578edc4d8ccf">_cl_mem</a>( cl_mem_flags flags, <span class="keywordtype">size_t</span> size , <span class="keywordtype">void</span> *<a class="code" href="struct__cl__mem.html#ae428f8f9f2b1e0ccc66dc8fcf86c263a">host_ptr</a>, cl_int *errcode_ret, cl_device_id gpu );
<a name="l00159"></a>00159    cl_mem <a class="code" href="struct__cl__mem.html#a726bbc965573e0f779f7d9e4e9990520">device_ptr</a>();
<a name="l00160"></a>00160    <span class="keywordtype">void</span>* <a class="code" href="struct__cl__mem.html#ae428f8f9f2b1e0ccc66dc8fcf86c263a">host_ptr</a>();
<a name="l00161"></a><a class="code" href="struct__cl__mem.html#a0fa4be6f84f1dcb2038661c1acf608b4">00161</a>    <span class="keywordtype">bool</span> <a class="code" href="struct__cl__mem.html#a0fa4be6f84f1dcb2038661c1acf608b4">is_on_host</a>() { <span class="keywordflow">return</span> <a class="code" href="struct__cl__mem.html#ad31afeb002295a89bbaa8e7bdffc9da4">m_is_on_host</a>; }
<a name="l00162"></a>00162 <span class="keyword">private</span>:
<a name="l00163"></a><a class="code" href="struct__cl__mem.html#ad31afeb002295a89bbaa8e7bdffc9da4">00163</a>    <span class="keywordtype">bool</span> <a class="code" href="struct__cl__mem.html#ad31afeb002295a89bbaa8e7bdffc9da4">m_is_on_host</a>;
<a name="l00164"></a><a class="code" href="struct__cl__mem.html#a1c8cdf06ee30aafd4787cc2cfcfbb1ae">00164</a>    <span class="keywordtype">size_t</span> <a class="code" href="struct__cl__mem.html#a1c8cdf06ee30aafd4787cc2cfcfbb1ae">m_device_ptr</a>;
<a name="l00165"></a><a class="code" href="struct__cl__mem.html#a2da5a4cc662b840ffaa6533027a0d36a">00165</a>    <span class="keywordtype">void</span> *<a class="code" href="struct__cl__mem.html#a2da5a4cc662b840ffaa6533027a0d36a">m_host_ptr</a>;
<a name="l00166"></a><a class="code" href="struct__cl__mem.html#a7b7c84d73f4079c61f1190c38eb0c555">00166</a>    cl_mem_flags <a class="code" href="struct__cl__mem.html#a7b7c84d73f4079c61f1190c38eb0c555">m_flags</a>; 
<a name="l00167"></a><a class="code" href="struct__cl__mem.html#ad28ffff3eb91d7b91f69185d10e8001f">00167</a>    <span class="keywordtype">size_t</span> <a class="code" href="struct__cl__mem.html#ad28ffff3eb91d7b91f69185d10e8001f">m_size</a>;
<a name="l00168"></a>00168 };
<a name="l00169"></a>00169 
<a name="l00170"></a><a class="code" href="structpgm__info.html">00170</a> <span class="keyword">struct </span><a class="code" href="structpgm__info.html">pgm_info</a> {
<a name="l00171"></a><a class="code" href="structpgm__info.html#ac512c454382e56af6c9fe9eaa8217ec9">00171</a>    std::string   <a class="code" href="structpgm__info.html#ac512c454382e56af6c9fe9eaa8217ec9">m_source</a>;
<a name="l00172"></a><a class="code" href="structpgm__info.html#ab15a4b1c33f8e05b1ab06b8f8e660939">00172</a>    std::string   <a class="code" href="structpgm__info.html#ab15a4b1c33f8e05b1ab06b8f8e660939">m_asm</a>;
<a name="l00173"></a><a class="code" href="structpgm__info.html#a11f7108a3f798b60f7e08739a4359827">00173</a>    <span class="keyword">class </span><a class="code" href="classsymbol__table.html">symbol_table</a> *<a class="code" href="structpgm__info.html#a11f7108a3f798b60f7e08739a4359827">m_symtab</a>;
<a name="l00174"></a><a class="code" href="structpgm__info.html#a9230c523e1d02756709978ce0f2415bb">00174</a>    std::map&lt;std::string,function_info*&gt; <a class="code" href="structpgm__info.html#a9230c523e1d02756709978ce0f2415bb">m_kernels</a>;
<a name="l00175"></a>00175 };
<a name="l00176"></a>00176 
<a name="l00177"></a><a class="code" href="struct__cl__program.html">00177</a> <span class="keyword">struct </span><a class="code" href="struct__cl__program.html">_cl_program</a> {
<a name="l00178"></a>00178    <a class="code" href="struct__cl__program.html#a002a303bca997760e7d3afe3b8ef1abc">_cl_program</a>( cl_context context,
<a name="l00179"></a>00179                 cl_uint           count, 
<a name="l00180"></a>00180              <span class="keyword">const</span> <span class="keywordtype">char</span> **     strings,   
<a name="l00181"></a>00181              <span class="keyword">const</span> <span class="keywordtype">size_t</span> *    lengths );
<a name="l00182"></a>00182    <span class="keywordtype">void</span> <a class="code" href="struct__cl__program.html#a809adef8d893d67619304543cf356ae7">Build</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *options);
<a name="l00183"></a>00183    cl_kernel <a class="code" href="struct__cl__program.html#a773e6c0c14e7a387c2c42f0fe31213de">CreateKernel</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> *kernel_name, cl_int *errcode_ret );
<a name="l00184"></a><a class="code" href="struct__cl__program.html#a20f9ac9063124f44c1b32c9ece99f967">00184</a>    cl_context <a class="code" href="struct__cl__program.html#a20f9ac9063124f44c1b32c9ece99f967">get_context</a>() { <span class="keywordflow">return</span> <a class="code" href="struct__cl__program.html#a0ce934320a86ca53d93dc28da088f7e9">m_context</a>; }
<a name="l00185"></a>00185    <span class="keywordtype">char</span> *<a class="code" href="struct__cl__program.html#a35f4f6a682edfe789229ac8c60f6cf45">get_ptx</a>();
<a name="l00186"></a>00186    <span class="keywordtype">size_t</span> <a class="code" href="struct__cl__program.html#a802f9f1fd4f863716a0935a570d5e623">get_ptx_size</a>();
<a name="l00187"></a>00187 
<a name="l00188"></a>00188 <span class="keyword">private</span>:
<a name="l00189"></a><a class="code" href="struct__cl__program.html#a0ce934320a86ca53d93dc28da088f7e9">00189</a>    cl_context <a class="code" href="struct__cl__program.html#a0ce934320a86ca53d93dc28da088f7e9">m_context</a>;
<a name="l00190"></a><a class="code" href="struct__cl__program.html#a7beecabd493a8dcaa9dae88c6e8268f0">00190</a>    std::map&lt;cl_uint,pgm_info&gt; <a class="code" href="struct__cl__program.html#a7beecabd493a8dcaa9dae88c6e8268f0">m_pgm</a>;
<a name="l00191"></a><a class="code" href="struct__cl__program.html#abc19bd152a384600b0d7221fde701e39">00191</a>    <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <a class="code" href="struct__cl__program.html#abc19bd152a384600b0d7221fde701e39">m_kernels_compiled</a>;
<a name="l00192"></a>00192 };
<a name="l00193"></a>00193 
<a name="l00194"></a><a class="code" href="struct__cl__kernel.html">00194</a> <span class="keyword">struct </span><a class="code" href="struct__cl__kernel.html">_cl_kernel</a> {
<a name="l00195"></a>00195    <a class="code" href="struct__cl__kernel.html#a64ae3fb3898e31811fa719ad77febaec">_cl_kernel</a>( cl_program prog, <span class="keyword">const</span> <span class="keywordtype">char</span>* kernel_name, <span class="keyword">class</span> <a class="code" href="classfunction__info.html">function_info</a> *kernel_impl );
<a name="l00196"></a>00196    <span class="keywordtype">void</span> <a class="code" href="struct__cl__kernel.html#a20dede8498e4296f8d41500f051f824b">SetKernelArg</a>(
<a name="l00197"></a>00197       cl_uint      arg_index,
<a name="l00198"></a>00198       <span class="keywordtype">size_t</span>       arg_size,
<a name="l00199"></a>00199       <span class="keyword">const</span> <span class="keywordtype">void</span> * arg_value );
<a name="l00200"></a>00200    cl_int <a class="code" href="struct__cl__kernel.html#a6fccc4cdd8e1f50b37eff5b098740222">bind_args</a>( <a class="code" href="abstract__hardware__model_8h.html#a400ae36727fbd6ac693cb1adc886e3d4">gpgpu_ptx_sim_arg_list_t</a> &amp;arg_list );
<a name="l00201"></a><a class="code" href="struct__cl__kernel.html#a28c67de2eff6faebe1b05932adb9f1a0">00201</a>    std::string <a class="code" href="struct__cl__kernel.html#a28c67de2eff6faebe1b05932adb9f1a0">name</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="struct__cl__kernel.html#ad48a14adbf1c600eb2f48341c4066587">m_kernel_name</a>; }
<a name="l00202"></a>00202    <span class="keywordtype">size_t</span> <a class="code" href="struct__cl__kernel.html#af261776b863fbd77b425eeb8a40ca6e2">get_workgroup_size</a>(cl_device_id device);
<a name="l00203"></a><a class="code" href="struct__cl__kernel.html#ad86db0debaedcf534c4cfd0503265a1e">00203</a>    cl_program <a class="code" href="struct__cl__kernel.html#ad86db0debaedcf534c4cfd0503265a1e">get_program</a>() { <span class="keywordflow">return</span> <a class="code" href="struct__cl__kernel.html#a1f42f328f319baea1952d1b769f0004b">m_prog</a>; }
<a name="l00204"></a><a class="code" href="struct__cl__kernel.html#a6e54cb6cc2572ac8906adc9fa255b094">00204</a>    <span class="keyword">class </span><a class="code" href="classfunction__info.html">function_info</a> *<a class="code" href="struct__cl__kernel.html#a6e54cb6cc2572ac8906adc9fa255b094">get_implementation</a>() { <span class="keywordflow">return</span> <a class="code" href="struct__cl__kernel.html#aa70be6207432f226fd9d1de1e8bd5f0a">m_kernel_impl</a>; }
<a name="l00205"></a>00205 <span class="keyword">private</span>:
<a name="l00206"></a><a class="code" href="struct__cl__kernel.html#a5b54ff813e175606a3b577d70fcf58eb">00206</a>    <span class="keywordtype">unsigned</span> <a class="code" href="struct__cl__kernel.html#a5b54ff813e175606a3b577d70fcf58eb">m_uid</a>;
<a name="l00207"></a><a class="code" href="struct__cl__kernel.html#a20e70791f85ef0893dcd8d957dbec7a9">00207</a>    <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <a class="code" href="struct__cl__kernel.html#a20e70791f85ef0893dcd8d957dbec7a9">sm_context_uid</a>;
<a name="l00208"></a><a class="code" href="struct__cl__kernel.html#a1f42f328f319baea1952d1b769f0004b">00208</a>    cl_program <a class="code" href="struct__cl__kernel.html#a1f42f328f319baea1952d1b769f0004b">m_prog</a>;
<a name="l00209"></a>00209 
<a name="l00210"></a><a class="code" href="struct__cl__kernel.html#ad48a14adbf1c600eb2f48341c4066587">00210</a>    std::string <a class="code" href="struct__cl__kernel.html#ad48a14adbf1c600eb2f48341c4066587">m_kernel_name</a>;
<a name="l00211"></a>00211 
<a name="l00212"></a><a class="code" href="struct__cl__kernel_1_1arg__info.html">00212</a>    <span class="keyword">struct </span><a class="code" href="struct__cl__kernel_1_1arg__info.html">arg_info</a> {
<a name="l00213"></a><a class="code" href="struct__cl__kernel_1_1arg__info.html#a5d056aac499abdba6265e4b71b2bd085">00213</a>       <span class="keywordtype">size_t</span> <a class="code" href="struct__cl__kernel_1_1arg__info.html#a5d056aac499abdba6265e4b71b2bd085">m_arg_size</a>;
<a name="l00214"></a><a class="code" href="struct__cl__kernel_1_1arg__info.html#a9807198fd3e221527e601041486000ae">00214</a>       <span class="keyword">const</span> <span class="keywordtype">void</span> *<a class="code" href="struct__cl__kernel_1_1arg__info.html#a9807198fd3e221527e601041486000ae">m_arg_value</a>;
<a name="l00215"></a>00215    };
<a name="l00216"></a>00216    
<a name="l00217"></a><a class="code" href="struct__cl__kernel.html#a408df50f328ea9fb74cfce08b51c55a6">00217</a>    std::map&lt;unsigned, arg_info&gt; <a class="code" href="struct__cl__kernel.html#a408df50f328ea9fb74cfce08b51c55a6">m_args</a>;
<a name="l00218"></a><a class="code" href="struct__cl__kernel.html#aa70be6207432f226fd9d1de1e8bd5f0a">00218</a>    <span class="keyword">class </span><a class="code" href="classfunction__info.html">function_info</a> *<a class="code" href="struct__cl__kernel.html#aa70be6207432f226fd9d1de1e8bd5f0a">m_kernel_impl</a>;
<a name="l00219"></a>00219 };
<a name="l00220"></a>00220 
<a name="l00221"></a><a class="code" href="struct__cl__platform__id.html">00221</a> <span class="keyword">struct </span><a class="code" href="struct__cl__platform__id.html">_cl_platform_id</a> {
<a name="l00222"></a><a class="code" href="struct__cl__platform__id.html#a19bfb91c9a074da77286be1cd278ea28">00222</a>    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <a class="code" href="struct__cl__platform__id.html#a19bfb91c9a074da77286be1cd278ea28">m_uid</a> = 0;
<a name="l00223"></a>00223 };
<a name="l00224"></a>00224 
<a name="l00225"></a><a class="code" href="opencl__runtime__api_8cc.html#a158cda46f7dea36f60603c58053b3276">00225</a> <span class="keyword">struct </span><a class="code" href="struct__cl__platform__id.html">_cl_platform_id</a> <a class="code" href="opencl__runtime__api_8cc.html#a158cda46f7dea36f60603c58053b3276">g_gpgpu_sim_platform_id</a>;
<a name="l00226"></a>00226 
<a name="l00227"></a><a class="code" href="opencl__runtime__api_8cc.html#a285f965c2a3d427022dadea4b8a73517">00227</a> <span class="keywordtype">void</span> <a class="code" href="opencl__runtime__api_8cc.html#a285f965c2a3d427022dadea4b8a73517">gpgpusim_exit</a>()
<a name="l00228"></a>00228 {
<a name="l00229"></a>00229    abort();
<a name="l00230"></a>00230 }
<a name="l00231"></a>00231 
<a name="l00232"></a><a class="code" href="opencl__runtime__api_8cc.html#aa5b14a4414d6febccda5d793e905deb5">00232</a> <span class="keywordtype">void</span> <a class="code" href="opencl__runtime__api_8cc.html#aa5b14a4414d6febccda5d793e905deb5">gpgpusim_opencl_warning</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* func, <span class="keywordtype">unsigned</span> line, <span class="keyword">const</span> <span class="keywordtype">char</span> *desc )
<a name="l00233"></a>00233 {
<a name="l00234"></a>00234    printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: Warning (%s:%u) ** %s\n&quot;</span>, func,line,desc);
<a name="l00235"></a>00235 }
<a name="l00236"></a>00236 
<a name="l00237"></a><a class="code" href="opencl__runtime__api_8cc.html#a77eeeaf34ab24fa98b6a3ce144099aef">00237</a> <span class="keywordtype">void</span> <a class="code" href="opencl__runtime__api_8cc.html#a77eeeaf34ab24fa98b6a3ce144099aef">gpgpusim_opencl_error</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* func, <span class="keywordtype">unsigned</span> line, <span class="keyword">const</span> <span class="keywordtype">char</span> *desc )
<a name="l00238"></a>00238 {
<a name="l00239"></a>00239    printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: ERROR (%s:%u) ** %s\n&quot;</span>, func,line,desc);
<a name="l00240"></a>00240    <a class="code" href="opencl__runtime__api_8cc.html#a285f965c2a3d427022dadea4b8a73517">gpgpusim_exit</a>();
<a name="l00241"></a>00241 }
<a name="l00242"></a>00242 
<a name="l00243"></a><a class="code" href="struct__cl__kernel.html#a64ae3fb3898e31811fa719ad77febaec">00243</a> <a class="code" href="struct__cl__kernel.html#a64ae3fb3898e31811fa719ad77febaec">_cl_kernel::_cl_kernel</a>( cl_program prog, <span class="keyword">const</span> <span class="keywordtype">char</span>* kernel_name, <span class="keyword">class</span> <a class="code" href="classfunction__info.html">function_info</a> *kernel_impl )
<a name="l00244"></a>00244 {
<a name="l00245"></a>00245    <a class="code" href="struct__cl__kernel.html#a5b54ff813e175606a3b577d70fcf58eb">m_uid</a> = <a class="code" href="struct__cl__kernel.html#a20e70791f85ef0893dcd8d957dbec7a9">sm_context_uid</a>++;
<a name="l00246"></a>00246    <a class="code" href="struct__cl__kernel.html#ad48a14adbf1c600eb2f48341c4066587">m_kernel_name</a> = std::string(kernel_name);
<a name="l00247"></a>00247    <a class="code" href="struct__cl__kernel.html#aa70be6207432f226fd9d1de1e8bd5f0a">m_kernel_impl</a> = kernel_impl;
<a name="l00248"></a>00248    <a class="code" href="struct__cl__kernel.html#a1f42f328f319baea1952d1b769f0004b">m_prog</a> = prog;
<a name="l00249"></a>00249 }
<a name="l00250"></a>00250 
<a name="l00251"></a><a class="code" href="struct__cl__kernel.html#a20dede8498e4296f8d41500f051f824b">00251</a> <span class="keywordtype">void</span> <a class="code" href="struct__cl__kernel.html#a20dede8498e4296f8d41500f051f824b">_cl_kernel::SetKernelArg</a>(
<a name="l00252"></a>00252       cl_uint      arg_index,
<a name="l00253"></a>00253       <span class="keywordtype">size_t</span>       arg_size,
<a name="l00254"></a>00254       <span class="keyword">const</span> <span class="keywordtype">void</span> * arg_value )
<a name="l00255"></a>00255 {
<a name="l00256"></a>00256    <a class="code" href="struct__cl__kernel_1_1arg__info.html">arg_info</a> arg;
<a name="l00257"></a>00257    arg.<a class="code" href="struct__cl__kernel_1_1arg__info.html#a5d056aac499abdba6265e4b71b2bd085">m_arg_size</a> = arg_size;
<a name="l00258"></a>00258    arg.<a class="code" href="struct__cl__kernel_1_1arg__info.html#a9807198fd3e221527e601041486000ae">m_arg_value</a> = arg_value;
<a name="l00259"></a>00259    <a class="code" href="struct__cl__kernel.html#a408df50f328ea9fb74cfce08b51c55a6">m_args</a>[arg_index] = arg;
<a name="l00260"></a>00260 }
<a name="l00261"></a>00261 
<a name="l00262"></a><a class="code" href="struct__cl__kernel.html#a6fccc4cdd8e1f50b37eff5b098740222">00262</a> cl_int <a class="code" href="struct__cl__kernel.html#a6fccc4cdd8e1f50b37eff5b098740222">_cl_kernel::bind_args</a>( <a class="code" href="abstract__hardware__model_8h.html#a400ae36727fbd6ac693cb1adc886e3d4">gpgpu_ptx_sim_arg_list_t</a> &amp;arg_list )
<a name="l00263"></a>00263 {
<a name="l00264"></a>00264    assert( arg_list.empty() );
<a name="l00265"></a>00265    <span class="keywordtype">unsigned</span> k=0;
<a name="l00266"></a>00266    std::map&lt;unsigned, arg_info&gt;::iterator i;
<a name="l00267"></a>00267    <span class="keywordflow">for</span>( i = <a class="code" href="struct__cl__kernel.html#a408df50f328ea9fb74cfce08b51c55a6">m_args</a>.begin(); i!=<a class="code" href="struct__cl__kernel.html#a408df50f328ea9fb74cfce08b51c55a6">m_args</a>.end(); i++ ) {
<a name="l00268"></a>00268       <span class="keywordflow">if</span>( i-&gt;first != k ) 
<a name="l00269"></a>00269          <span class="keywordflow">return</span> CL_INVALID_KERNEL_ARGS;
<a name="l00270"></a>00270       <a class="code" href="struct__cl__kernel_1_1arg__info.html">arg_info</a> arg = i-&gt;second;
<a name="l00271"></a>00271       <a class="code" href="structgpgpu__ptx__sim__arg.html">gpgpu_ptx_sim_arg</a> param( arg.<a class="code" href="struct__cl__kernel_1_1arg__info.html#a9807198fd3e221527e601041486000ae">m_arg_value</a>, arg.<a class="code" href="struct__cl__kernel_1_1arg__info.html#a5d056aac499abdba6265e4b71b2bd085">m_arg_size</a>, 0 );
<a name="l00272"></a>00272       arg_list.push_front( param );
<a name="l00273"></a>00273       k++;
<a name="l00274"></a>00274    }
<a name="l00275"></a>00275    <span class="keywordflow">return</span> CL_SUCCESS;
<a name="l00276"></a>00276 }
<a name="l00277"></a>00277 
<a name="l00278"></a>00278 <span class="preprocessor">#define min(a,b) ((a&lt;b)?(a):(b))</span>
<a name="l00279"></a>00279 <span class="preprocessor"></span>
<a name="l00280"></a><a class="code" href="struct__cl__kernel.html#af261776b863fbd77b425eeb8a40ca6e2">00280</a> <span class="keywordtype">size_t</span> <a class="code" href="struct__cl__kernel.html#af261776b863fbd77b425eeb8a40ca6e2">_cl_kernel::get_workgroup_size</a>(cl_device_id device)
<a name="l00281"></a>00281 {
<a name="l00282"></a>00282    <span class="keywordtype">unsigned</span> nregs = <a class="code" href="ptx__ir_8cc.html#a035bc4c576dbed6c53886e1f3922bcbb">ptx_kernel_nregs</a>( <a class="code" href="struct__cl__kernel.html#aa70be6207432f226fd9d1de1e8bd5f0a">m_kernel_impl</a> );
<a name="l00283"></a>00283    <span class="keywordtype">unsigned</span> result_regs = (unsigned)-1;
<a name="l00284"></a>00284    <span class="keywordflow">if</span>( nregs &gt; 0 )
<a name="l00285"></a>00285       result_regs = device-&gt;the_device()-&gt;num_registers_per_core() / ((nregs+3)&amp;~3);
<a name="l00286"></a>00286    <span class="keywordtype">unsigned</span> result = device-&gt;the_device()-&gt;threads_per_core();
<a name="l00287"></a>00287    result = min(result, result_regs);
<a name="l00288"></a>00288    <span class="keywordflow">return</span> (<span class="keywordtype">size_t</span>)result;
<a name="l00289"></a>00289 }
<a name="l00290"></a>00290 
<a name="l00291"></a><a class="code" href="struct__cl__mem.html#a726bbc965573e0f779f7d9e4e9990520">00291</a> cl_mem <a class="code" href="struct__cl__mem.html#a726bbc965573e0f779f7d9e4e9990520">_cl_mem::device_ptr</a>()
<a name="l00292"></a>00292 {
<a name="l00293"></a>00293    cl_mem result = (cl_mem)(<span class="keywordtype">void</span>*)<a class="code" href="struct__cl__mem.html#a1c8cdf06ee30aafd4787cc2cfcfbb1ae">m_device_ptr</a>;
<a name="l00294"></a>00294    <span class="keywordflow">return</span> result;
<a name="l00295"></a>00295 }
<a name="l00296"></a>00296 
<a name="l00297"></a><a class="code" href="struct__cl__mem.html#ae428f8f9f2b1e0ccc66dc8fcf86c263a">00297</a> <span class="keywordtype">void</span>* <a class="code" href="struct__cl__mem.html#ae428f8f9f2b1e0ccc66dc8fcf86c263a">_cl_mem::host_ptr</a>()
<a name="l00298"></a>00298 {
<a name="l00299"></a>00299    <span class="keywordflow">return</span> <a class="code" href="struct__cl__mem.html#a2da5a4cc662b840ffaa6533027a0d36a">m_host_ptr</a>;
<a name="l00300"></a>00300 }
<a name="l00301"></a>00301 
<a name="l00302"></a><a class="code" href="struct__cl__mem.html#a3fc58e0ab1f4081d9dd8578edc4d8ccf">00302</a> <a class="code" href="struct__cl__mem.html#a3fc58e0ab1f4081d9dd8578edc4d8ccf">_cl_mem::_cl_mem</a>(
<a name="l00303"></a>00303    cl_mem_flags flags,
<a name="l00304"></a>00304    <span class="keywordtype">size_t</span>       size ,
<a name="l00305"></a>00305    <span class="keywordtype">void</span> *       host_ptr,
<a name="l00306"></a>00306    cl_int *     errcode_ret,
<a name="l00307"></a>00307    cl_device_id gpu )
<a name="l00308"></a>00308 {
<a name="l00309"></a>00309    <a class="code" href="opencl__runtime__api_8cc.html#a39aab942676c56e70bd1cb9ed952b4b1">setErrCode</a>( errcode_ret, CL_SUCCESS );
<a name="l00310"></a>00310 
<a name="l00311"></a>00311    <a class="code" href="struct__cl__mem.html#ad31afeb002295a89bbaa8e7bdffc9da4">m_is_on_host</a> = <span class="keyword">false</span>;
<a name="l00312"></a>00312    <a class="code" href="struct__cl__mem.html#a7b7c84d73f4079c61f1190c38eb0c555">m_flags</a> = flags;
<a name="l00313"></a>00313    <a class="code" href="struct__cl__mem.html#ad28ffff3eb91d7b91f69185d10e8001f">m_size</a> = size;
<a name="l00314"></a>00314    <a class="code" href="struct__cl__mem.html#a2da5a4cc662b840ffaa6533027a0d36a">m_host_ptr</a> = host_ptr;
<a name="l00315"></a>00315    <a class="code" href="struct__cl__mem.html#a1c8cdf06ee30aafd4787cc2cfcfbb1ae">m_device_ptr</a> = 0;
<a name="l00316"></a>00316 
<a name="l00317"></a>00317    <span class="keywordflow">if</span>( (flags &amp; (CL_MEM_USE_HOST_PTR|CL_MEM_COPY_HOST_PTR)) &amp;&amp; host_ptr == NULL ) {
<a name="l00318"></a>00318       <a class="code" href="opencl__runtime__api_8cc.html#a39aab942676c56e70bd1cb9ed952b4b1">setErrCode</a>( errcode_ret, CL_INVALID_HOST_PTR );
<a name="l00319"></a>00319       <span class="keywordflow">return</span>;
<a name="l00320"></a>00320    }
<a name="l00321"></a>00321    <span class="keywordflow">if</span>( (flags &amp; CL_MEM_COPY_HOST_PTR) &amp;&amp; (flags &amp; CL_MEM_USE_HOST_PTR) ) {
<a name="l00322"></a>00322       <a class="code" href="opencl__runtime__api_8cc.html#a39aab942676c56e70bd1cb9ed952b4b1">setErrCode</a>( errcode_ret, CL_INVALID_VALUE );
<a name="l00323"></a>00323       <span class="keywordflow">return</span>;
<a name="l00324"></a>00324    }
<a name="l00325"></a>00325    <span class="keywordflow">if</span>( flags &amp; CL_MEM_ALLOC_HOST_PTR ) {
<a name="l00326"></a>00326       <span class="keywordflow">if</span>( host_ptr ) 
<a name="l00327"></a>00327          <a class="code" href="opencl__runtime__api_8cc.html#a77eeeaf34ab24fa98b6a3ce144099aef">gpgpusim_opencl_error</a>(__my_func__,__LINE__,<span class="stringliteral">&quot; CL_MEM_ALLOC_HOST_PTR -- not yet supported/tested.\n&quot;</span>);
<a name="l00328"></a>00328       <a class="code" href="struct__cl__mem.html#a2da5a4cc662b840ffaa6533027a0d36a">m_host_ptr</a> = malloc(size);
<a name="l00329"></a>00329    }
<a name="l00330"></a>00330 
<a name="l00331"></a>00331    <span class="keywordflow">if</span>( flags &amp; (CL_MEM_USE_HOST_PTR|CL_MEM_ALLOC_HOST_PTR) ) {
<a name="l00332"></a>00332       <a class="code" href="struct__cl__mem.html#ad31afeb002295a89bbaa8e7bdffc9da4">m_is_on_host</a> = <span class="keyword">true</span>;
<a name="l00333"></a>00333    } <span class="keywordflow">else</span> {
<a name="l00334"></a>00334       <a class="code" href="struct__cl__mem.html#ad31afeb002295a89bbaa8e7bdffc9da4">m_is_on_host</a> = <span class="keyword">false</span>;
<a name="l00335"></a>00335    }
<a name="l00336"></a>00336    <span class="keywordflow">if</span>( !(flags &amp; (CL_MEM_USE_HOST_PTR|CL_MEM_ALLOC_HOST_PTR)) ) {
<a name="l00337"></a>00337       <span class="comment">// if not allocating on host, then allocate GPU memory and make a copy</span>
<a name="l00338"></a>00338       <a class="code" href="struct__cl__mem.html#a1c8cdf06ee30aafd4787cc2cfcfbb1ae">m_device_ptr</a> = (size_t) gpu-&gt;the_device()-&gt;gpu_malloc(size);
<a name="l00339"></a>00339       <span class="keywordflow">if</span>( host_ptr )
<a name="l00340"></a>00340          gpu-&gt;the_device()-&gt;memcpy_to_gpu( <a class="code" href="struct__cl__mem.html#a1c8cdf06ee30aafd4787cc2cfcfbb1ae">m_device_ptr</a>, host_ptr, size );
<a name="l00341"></a>00341    }
<a name="l00342"></a>00342 }
<a name="l00343"></a>00343 
<a name="l00344"></a>00344 <a class="code" href="struct__cl__context.html#a6841afd8075a83248d8f2df41eb2ac0e">_cl_context::_cl_context</a>( <span class="keyword">struct</span> <a class="code" href="struct__cl__device__id.html">_cl_device_id</a> *gpu ) 
<a name="l00345"></a>00345 { 
<a name="l00346"></a>00346    <a class="code" href="struct__cl__context.html#a750fe75a1cf1779dc5c8fecaef953034">m_uid</a> = <a class="code" href="struct__cl__context.html#a87d08d4f1a5a7059dc2214dcdc0173e2">sm_context_uid</a>++; 
<a name="l00347"></a>00347    <a class="code" href="struct__cl__context.html#a8e11ff42c1ec91392d6275d8bedda1f4">m_gpu</a> = gpu;
<a name="l00348"></a>00348 }
<a name="l00349"></a>00349 
<a name="l00350"></a><a class="code" href="struct__cl__context.html#a4c3ca03c89afcb62809e47bd60adbe10">00350</a> cl_device_id <a class="code" href="struct__cl__context.html#a4c3ca03c89afcb62809e47bd60adbe10">_cl_context::get_first_device</a>() 
<a name="l00351"></a>00351 {
<a name="l00352"></a>00352    <span class="keywordflow">return</span> <a class="code" href="struct__cl__context.html#a8e11ff42c1ec91392d6275d8bedda1f4">m_gpu</a>;
<a name="l00353"></a>00353 }
<a name="l00354"></a>00354 
<a name="l00355"></a><a class="code" href="struct__cl__context.html#aea614318eb7157c7212fd24755ebf163">00355</a> cl_mem <a class="code" href="struct__cl__context.html#aea614318eb7157c7212fd24755ebf163">_cl_context::CreateBuffer</a>(
<a name="l00356"></a>00356                cl_mem_flags flags,
<a name="l00357"></a>00357                <span class="keywordtype">size_t</span>       size ,
<a name="l00358"></a>00358                <span class="keywordtype">void</span> *       host_ptr,
<a name="l00359"></a>00359                cl_int *     errcode_ret )
<a name="l00360"></a>00360 {
<a name="l00361"></a>00361    <span class="keywordflow">if</span>( host_ptr &amp;&amp; (<a class="code" href="struct__cl__context.html#a6f1dfbe16f401b0d8d578478e753123b">m_hostptr_to_cl_mem</a>.find(host_ptr) != <a class="code" href="struct__cl__context.html#a6f1dfbe16f401b0d8d578478e753123b">m_hostptr_to_cl_mem</a>.end()) ) {
<a name="l00362"></a>00362       printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: WARNING ** clCreateBuffer - buffer already created for this host variable\n&quot;</span>);
<a name="l00363"></a>00363    }
<a name="l00364"></a>00364    cl_mem result = <span class="keyword">new</span> <a class="code" href="struct__cl__mem.html">_cl_mem</a>(flags,size,host_ptr,errcode_ret,<a class="code" href="struct__cl__context.html#a8e11ff42c1ec91392d6275d8bedda1f4">m_gpu</a>);
<a name="l00365"></a>00365    <a class="code" href="struct__cl__context.html#a5fa44c815b36a73e04abb0d5e0cef05f">m_devptr_to_cl_mem</a>[result-&gt;device_ptr()] = result;
<a name="l00366"></a>00366    <span class="keywordflow">if</span>( host_ptr ) 
<a name="l00367"></a>00367       <a class="code" href="struct__cl__context.html#a6f1dfbe16f401b0d8d578478e753123b">m_hostptr_to_cl_mem</a>[host_ptr] = result;
<a name="l00368"></a>00368    <span class="keywordflow">if</span>( result-&gt;device_ptr() ) 
<a name="l00369"></a>00369       <span class="keywordflow">return</span> (cl_mem) result-&gt;device_ptr();
<a name="l00370"></a>00370    <span class="keywordflow">else</span> 
<a name="l00371"></a>00371       <span class="keywordflow">return</span> (cl_mem) host_ptr;
<a name="l00372"></a>00372 }
<a name="l00373"></a>00373 
<a name="l00374"></a><a class="code" href="struct__cl__context.html#a0968653b329b998c0742940a377e6aa2">00374</a> cl_mem <a class="code" href="struct__cl__context.html#a0968653b329b998c0742940a377e6aa2">_cl_context::lookup_mem</a>( cl_mem m )
<a name="l00375"></a>00375 {
<a name="l00376"></a>00376    std::map&lt;cl_mem<span class="comment">/*device ptr*/</span>,cl_mem&gt;::iterator i=<a class="code" href="struct__cl__context.html#a5fa44c815b36a73e04abb0d5e0cef05f">m_devptr_to_cl_mem</a>.find(m);
<a name="l00377"></a>00377    <span class="keywordflow">if</span>( i == <a class="code" href="struct__cl__context.html#a5fa44c815b36a73e04abb0d5e0cef05f">m_devptr_to_cl_mem</a>.end() ) {
<a name="l00378"></a>00378       <span class="keywordtype">void</span> *t = (<span class="keywordtype">void</span>*)m;
<a name="l00379"></a>00379       std::map&lt;<span class="keywordtype">void</span>*<span class="comment">/*host_ptr*/</span>,cl_mem&gt;::iterator j = <a class="code" href="struct__cl__context.html#a6f1dfbe16f401b0d8d578478e753123b">m_hostptr_to_cl_mem</a>.find(t);
<a name="l00380"></a>00380       <span class="keywordflow">if</span>( j == <a class="code" href="struct__cl__context.html#a6f1dfbe16f401b0d8d578478e753123b">m_hostptr_to_cl_mem</a>.end() )
<a name="l00381"></a>00381          <span class="keywordflow">return</span> NULL;
<a name="l00382"></a>00382       <span class="keywordflow">else</span> 
<a name="l00383"></a>00383          <span class="keywordflow">return</span> j-&gt;second;
<a name="l00384"></a>00384    } <span class="keywordflow">else</span> {
<a name="l00385"></a>00385       <span class="keywordflow">return</span> i-&gt;second;
<a name="l00386"></a>00386    }
<a name="l00387"></a>00387 }
<a name="l00388"></a>00388 
<a name="l00389"></a>00389 <span class="keywordtype">unsigned</span> <a class="code" href="struct__cl__program.html#abc19bd152a384600b0d7221fde701e39">_cl_program::m_kernels_compiled</a> = 0;
<a name="l00390"></a><a class="code" href="struct__cl__program.html#a002a303bca997760e7d3afe3b8ef1abc">00390</a> <a class="code" href="struct__cl__program.html#a002a303bca997760e7d3afe3b8ef1abc">_cl_program::_cl_program</a>( cl_context        context,
<a name="l00391"></a>00391                           cl_uint           count, 
<a name="l00392"></a>00392                           <span class="keyword">const</span> <span class="keywordtype">char</span> **     strings, 
<a name="l00393"></a>00393                           <span class="keyword">const</span> <span class="keywordtype">size_t</span> *    lengths )
<a name="l00394"></a>00394 {
<a name="l00395"></a>00395    <a class="code" href="struct__cl__program.html#a0ce934320a86ca53d93dc28da088f7e9">m_context</a> = context;
<a name="l00396"></a>00396    <span class="keywordflow">for</span>( cl_uint i=0; i&lt;count; i++ ) {
<a name="l00397"></a>00397       <span class="keywordtype">unsigned</span> len;
<a name="l00398"></a>00398       <span class="keywordflow">if</span>(lengths != NULL and lengths[i] &gt; 0)
<a name="l00399"></a>00399           len = lengths[i];
<a name="l00400"></a>00400       <span class="keywordflow">else</span>
<a name="l00401"></a>00401           len = strlen(strings[i]);
<a name="l00402"></a>00402       <span class="keywordtype">char</span> *tmp = (<span class="keywordtype">char</span>*)malloc(len+1);
<a name="l00403"></a>00403       memcpy(tmp,strings[i],len);
<a name="l00404"></a>00404       tmp[len] = 0;
<a name="l00405"></a>00405       <a class="code" href="struct__cl__program.html#a7beecabd493a8dcaa9dae88c6e8268f0">m_pgm</a>[<a class="code" href="struct__cl__program.html#abc19bd152a384600b0d7221fde701e39">m_kernels_compiled</a>].m_source = tmp;
<a name="l00406"></a>00406       ++<a class="code" href="struct__cl__program.html#abc19bd152a384600b0d7221fde701e39">m_kernels_compiled</a>;
<a name="l00407"></a>00407       <a class="code" href="y_8tab_8c.html#af07d89f5ceaea0c7c8252cc41fd75f37">free</a>(tmp);
<a name="l00408"></a>00408    }
<a name="l00409"></a>00409 }
<a name="l00410"></a>00410 
<a name="l00411"></a><a class="code" href="opencl__runtime__api_8cc.html#af8cc4227c5c8f2589e2ec94b7e817469">00411</a> <span class="keyword">static</span> <a class="code" href="structpgm__info.html">pgm_info</a> *<a class="code" href="opencl__runtime__api_8cc.html#af8cc4227c5c8f2589e2ec94b7e817469">sg_info</a>;
<a name="l00412"></a>00412 
<a name="l00413"></a><a class="code" href="opencl__runtime__api_8cc.html#a67e7cc97deef7b0777faddbb23951b6d">00413</a> <span class="keywordtype">void</span> <a class="code" href="ptx__ir_8cc.html#a67e7cc97deef7b0777faddbb23951b6d">register_ptx_function</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <a class="code" href="classfunction__info.html">function_info</a> *impl )
<a name="l00414"></a>00414 {
<a name="l00415"></a>00415    sg_info-&gt;<a class="code" href="structpgm__info.html#a9230c523e1d02756709978ce0f2415bb">m_kernels</a>[name] = impl;
<a name="l00416"></a>00416 }
<a name="l00417"></a>00417 
<a name="l00418"></a><a class="code" href="opencl__runtime__api_8cc.html#aad37ca574f64c25d02176537d844d887">00418</a>  <span class="keywordtype">void</span> <a class="code" href="cuda__runtime__api_8cc.html#aad37ca574f64c25d02176537d844d887">ptxinfo_addinfo</a>()
<a name="l00419"></a>00419 {
<a name="l00420"></a>00420    <a class="code" href="cuda-sim_8cc.html#a465b15ddb00d0bcf9d9df5e124c1c690">ptxinfo_opencl_addinfo</a>( sg_info-&gt;<a class="code" href="structpgm__info.html#a9230c523e1d02756709978ce0f2415bb">m_kernels</a> );
<a name="l00421"></a>00421 }
<a name="l00422"></a>00422 
<a name="l00423"></a><a class="code" href="struct__cl__program.html#a809adef8d893d67619304543cf356ae7">00423</a> <span class="keywordtype">void</span> <a class="code" href="struct__cl__program.html#a809adef8d893d67619304543cf356ae7">_cl_program::Build</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *options)
<a name="l00424"></a>00424 {
<a name="l00425"></a>00425    printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: compiling OpenCL kernels...\n&quot;</span>); 
<a name="l00426"></a>00426    std::map&lt;cl_uint,pgm_info&gt;::iterator i;
<a name="l00427"></a>00427    <span class="keywordflow">for</span>( i = <a class="code" href="struct__cl__program.html#a7beecabd493a8dcaa9dae88c6e8268f0">m_pgm</a>.begin(); i!= <a class="code" href="struct__cl__program.html#a7beecabd493a8dcaa9dae88c6e8268f0">m_pgm</a>.end(); i++ ) {
<a name="l00428"></a>00428       <a class="code" href="structpgm__info.html">pgm_info</a> &amp;info=i-&gt;second;
<a name="l00429"></a>00429       sg_info = &amp;info;
<a name="l00430"></a>00430       <span class="keywordtype">unsigned</span> source_num=i-&gt;first;
<a name="l00431"></a>00431       <span class="keywordtype">char</span> ptx_fname[1024];
<a name="l00432"></a>00432       <span class="keywordtype">char</span> *use_extracted_ptx = getenv(<span class="stringliteral">&quot;PTX_SIM_USE_PTX_FILE&quot;</span>);
<a name="l00433"></a>00433       <span class="keywordflow">if</span>( use_extracted_ptx == NULL ) {
<a name="l00434"></a>00434          <span class="keywordtype">char</span> *nvopencl_libdir = getenv(<span class="stringliteral">&quot;NVOPENCL_LIBDIR&quot;</span>);
<a name="l00435"></a>00435          <span class="keyword">const</span> std::string gpgpu_opencl_path_str = std::string(getenv(<span class="stringliteral">&quot;GPGPUSIM_ROOT&quot;</span>))
<a name="l00436"></a>00436             + <span class="stringliteral">&quot;/build/&quot;</span> + std::string(getenv(<span class="stringliteral">&quot;GPGPUSIM_CONFIG&quot;</span>));
<a name="l00437"></a>00437          <span class="keywordtype">bool</span> error = <span class="keyword">false</span>;
<a name="l00438"></a>00438          <span class="keywordflow">if</span>( nvopencl_libdir == NULL ) {
<a name="l00439"></a>00439             printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: Please set your NVOPENCL_LIBDIR environment variable to\n&quot;</span>
<a name="l00440"></a>00440                    <span class="stringliteral">&quot;                      the location of NVIDIA&apos;s libOpenCL.so file on your system.\n&quot;</span>);
<a name="l00441"></a>00441             error = <span class="keyword">true</span>;
<a name="l00442"></a>00442          }
<a name="l00443"></a>00443          <span class="keywordflow">if</span>( getenv(<span class="stringliteral">&quot;GPGPUSIM_ROOT&quot;</span>) == NULL || getenv(<span class="stringliteral">&quot;GPGPUSIM_CONFIG&quot;</span>) == NULL ) {
<a name="l00444"></a>00444             fprintf(stderr,<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: Please set your GPGPUSIM_ROOT environment variable\n&quot;</span>);
<a name="l00445"></a>00445             fprintf(stderr,<span class="stringliteral">&quot;                      to point to the location of your GPGPU-Sim installation\n&quot;</span>);
<a name="l00446"></a>00446             error = <span class="keyword">true</span>;
<a name="l00447"></a>00447          }
<a name="l00448"></a>00448          <span class="keywordflow">if</span>( error ) 
<a name="l00449"></a>00449             exit(1); 
<a name="l00450"></a>00450 
<a name="l00451"></a>00451          <span class="keywordtype">char</span> cl_fname[1024];
<a name="l00452"></a>00452          <span class="keyword">const</span> <span class="keywordtype">char</span> *source = info.<a class="code" href="structpgm__info.html#ac512c454382e56af6c9fe9eaa8217ec9">m_source</a>.c_str();
<a name="l00453"></a>00453 
<a name="l00454"></a>00454          <span class="comment">// call wrapper</span>
<a name="l00455"></a>00455          <span class="keywordtype">char</span> *ld_library_path_orig = getenv(<span class="stringliteral">&quot;LD_LIBRARY_PATH&quot;</span>);
<a name="l00456"></a>00456 
<a name="l00457"></a>00457          <span class="comment">// create temporary filenames</span>
<a name="l00458"></a>00458          snprintf(cl_fname,1024,<span class="stringliteral">&quot;_cl_XXXXXX&quot;</span>);
<a name="l00459"></a>00459          snprintf(ptx_fname,1024,<span class="stringliteral">&quot;_ptx_XXXXXX&quot;</span>);
<a name="l00460"></a>00460          <span class="keywordtype">int</span> fd=mkstemp(cl_fname); 
<a name="l00461"></a>00461          close(fd);
<a name="l00462"></a>00462          fd=mkstemp(ptx_fname); 
<a name="l00463"></a>00463          close(fd);
<a name="l00464"></a>00464 
<a name="l00465"></a>00465          <span class="comment">// write OpenCL source to file</span>
<a name="l00466"></a>00466          FILE *fp = fopen(cl_fname,<span class="stringliteral">&quot;w&quot;</span>);
<a name="l00467"></a>00467          <span class="keywordflow">if</span>( fp == NULL ) {
<a name="l00468"></a>00468             printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: ERROR ** could not create temporary files required for generating PTX\n&quot;</span>);
<a name="l00469"></a>00469             printf(<span class="stringliteral">&quot;                      Ensure you have write permission to the simulation directory\n&quot;</span>);
<a name="l00470"></a>00470             exit(1);
<a name="l00471"></a>00471          }
<a name="l00472"></a>00472          fputs(source,fp);
<a name="l00473"></a>00473          fclose(fp);
<a name="l00474"></a>00474 
<a name="l00475"></a>00475          <span class="keywordtype">char</span> commandline[1024];
<a name="l00476"></a>00476          <span class="keyword">const</span> <span class="keywordtype">char</span> *opt = options?options:<span class="stringliteral">&quot;&quot;</span>;
<a name="l00477"></a>00477          <span class="keyword">const</span> <span class="keywordtype">char</span>* remote_dir = getenv( <span class="stringliteral">&quot;OPENCL_REMOTE_DIRECTORY&quot;</span> );
<a name="l00478"></a>00478          <span class="keyword">const</span> <span class="keywordtype">char</span>* local_pwd = getenv( <span class="stringliteral">&quot;PWD&quot;</span> );
<a name="l00479"></a>00479          <span class="keywordflow">if</span> ( !remote_dir || strncmp( remote_dir, <span class="stringliteral">&quot;&quot;</span>, 1 ) == 0 ) {
<a name="l00480"></a>00480              remote_dir = local_pwd;
<a name="l00481"></a>00481          }
<a name="l00482"></a>00482          <span class="keyword">const</span> <span class="keywordtype">char</span>* remote_host = getenv( <span class="stringliteral">&quot;OPENCL_REMOTE_GPU_HOST&quot;</span> );
<a name="l00483"></a>00483          <span class="keywordflow">if</span> ( remote_host &amp;&amp; remote_dir ) {
<a name="l00484"></a>00484             <span class="comment">// create same directory on OpenCL to PTX server</span>
<a name="l00485"></a>00485             snprintf(commandline,1024,<span class="stringliteral">&quot;ssh %s mkdir -p %s&quot;</span>, remote_host, remote_dir );
<a name="l00486"></a>00486             printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: OpenCL wrapper command line \&apos;%s\&apos;\n&quot;</span>, commandline);
<a name="l00487"></a>00487             fflush(stdout);
<a name="l00488"></a>00488             <span class="keywordtype">int</span> result = system(commandline);
<a name="l00489"></a>00489             <span class="keywordflow">if</span>( result ) { printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: ERROR (%d)\n&quot;</span>, result ); exit(1); }
<a name="l00490"></a>00490 
<a name="l00491"></a>00491             <span class="comment">// copy input OpenCL file to OpenCL to PTX server</span>
<a name="l00492"></a>00492             snprintf(commandline,1024,<span class="stringliteral">&quot;rsync -t %s/%s %s:%s/%s&quot;</span>, local_pwd, cl_fname, remote_host, remote_dir, cl_fname );
<a name="l00493"></a>00493             printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: OpenCL wrapper command line \&apos;%s\&apos;\n&quot;</span>, commandline);
<a name="l00494"></a>00494             fflush(stdout);
<a name="l00495"></a>00495             result = system(commandline);
<a name="l00496"></a>00496             <span class="keywordflow">if</span>( result ) { printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: ERROR (%d)\n&quot;</span>, result ); exit(1); }
<a name="l00497"></a>00497 
<a name="l00498"></a>00498             <span class="comment">// copy the nvopencl_wrapper file to the remote server</span>
<a name="l00499"></a>00499             snprintf(commandline,1024,<span class="stringliteral">&quot;rsync -t %s/libopencl/bin/nvopencl_wrapper %s:%s/nvopencl_wrapper&quot;</span>, gpgpu_opencl_path_str.c_str(), remote_host, remote_dir );
<a name="l00500"></a>00500             printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: OpenCL wrapper command line \&apos;%s\&apos;\n&quot;</span>, commandline);
<a name="l00501"></a>00501             fflush(stdout);
<a name="l00502"></a>00502             result = system(commandline);
<a name="l00503"></a>00503             <span class="keywordflow">if</span>( result ) { printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: ERROR (%d)\n&quot;</span>, result ); exit(1); }
<a name="l00504"></a>00504 
<a name="l00505"></a>00505             <span class="comment">// convert OpenCL to PTX on remote server</span>
<a name="l00506"></a>00506             snprintf(commandline,1024,<span class="stringliteral">&quot;ssh %s \&quot;export LD_LIBRARY_PATH=%s; %s/nvopencl_wrapper %s/%s %s/%s %s\&quot;&quot;</span>,
<a name="l00507"></a>00507                     remote_host, nvopencl_libdir, remote_dir, remote_dir, cl_fname, remote_dir, ptx_fname, opt );
<a name="l00508"></a>00508             printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: OpenCL wrapper command line \&apos;%s\&apos;\n&quot;</span>, commandline);
<a name="l00509"></a>00509             fflush(stdout);
<a name="l00510"></a>00510             result = system(commandline);
<a name="l00511"></a>00511             <span class="keywordflow">if</span>( result ) { printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: ERROR (%d)\n&quot;</span>, result ); exit(1); }
<a name="l00512"></a>00512 
<a name="l00513"></a>00513             <span class="comment">// copy output PTX from OpenCL to PTX server back to simulation directory</span>
<a name="l00514"></a>00514             snprintf(commandline,1024,<span class="stringliteral">&quot;rsync -t %s:%s/%s %s/%s&quot;</span>, remote_host, remote_dir, ptx_fname, local_pwd, ptx_fname );
<a name="l00515"></a>00515             printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: OpenCL wrapper command line \&apos;%s\&apos;\n&quot;</span>, commandline);
<a name="l00516"></a>00516             fflush(stdout);
<a name="l00517"></a>00517             result = system(commandline);
<a name="l00518"></a>00518             <span class="keywordflow">if</span>( result ) { printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: ERROR (%d)\n&quot;</span>, result ); exit(1); }
<a name="l00519"></a>00519          } <span class="keywordflow">else</span> {
<a name="l00520"></a>00520             setenv(<span class="stringliteral">&quot;LD_LIBRARY_PATH&quot;</span>,nvopencl_libdir,1);
<a name="l00521"></a>00521             snprintf(commandline,1024,<span class="stringliteral">&quot;%s/libopencl/bin/nvopencl_wrapper %s %s %s&quot;</span>, 
<a name="l00522"></a>00522                    gpgpu_opencl_path_str.c_str(), cl_fname, ptx_fname, opt );
<a name="l00523"></a>00523             printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: OpenCL wrapper command line \&apos;%s\&apos;\n&quot;</span>, commandline);
<a name="l00524"></a>00524             fflush(stdout);
<a name="l00525"></a>00525             <span class="keywordtype">int</span> result = system(commandline);
<a name="l00526"></a>00526             setenv(<span class="stringliteral">&quot;LD_LIBRARY_PATH&quot;</span>,ld_library_path_orig,1);
<a name="l00527"></a>00527             <span class="keywordflow">if</span>( result != 0 ) {
<a name="l00528"></a>00528                printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: ERROR ** while calling NVIDIA driver to convert OpenCL to PTX (%u)\n&quot;</span>,
<a name="l00529"></a>00529                       result );
<a name="l00530"></a>00530                printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: LD_LIBRARY_PATH was \&apos;%s\&apos;\n&quot;</span>, nvopencl_libdir);
<a name="l00531"></a>00531                printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: command line was \&apos;%s\&apos;\n&quot;</span>, commandline);
<a name="l00532"></a>00532                exit(1);
<a name="l00533"></a>00533             }
<a name="l00534"></a>00534          }
<a name="l00535"></a>00535          <span class="keywordflow">if</span>( !<a class="code" href="ptx__ir_8h.html#a822d2d33e4fb701b5abafe4bff42175f">g_keep_intermediate_files</a> ) {
<a name="l00536"></a>00536             <span class="comment">// clean up files...</span>
<a name="l00537"></a>00537             snprintf(commandline,1024,<span class="stringliteral">&quot;rm -f %s&quot;</span>, cl_fname );
<a name="l00538"></a>00538             <span class="keywordtype">int</span> result = system(commandline);
<a name="l00539"></a>00539             <span class="keywordflow">if</span>( result != 0 ) 
<a name="l00540"></a>00540                printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: could not remove temporary files generated while generating PTX\n&quot;</span>);
<a name="l00541"></a>00541          }
<a name="l00542"></a>00542       } <span class="keywordflow">else</span> {
<a name="l00543"></a>00543          snprintf(ptx_fname,1024,<span class="stringliteral">&quot;_%u.ptx&quot;</span>, source_num);
<a name="l00544"></a>00544       }
<a name="l00545"></a>00545 
<a name="l00546"></a>00546       <span class="comment">// read in PTX generated by wrapper</span>
<a name="l00547"></a>00547       FILE *fp = fopen(ptx_fname,<span class="stringliteral">&quot;r&quot;</span>);
<a name="l00548"></a>00548       <span class="keywordflow">if</span>( fp == NULL ) {
<a name="l00549"></a>00549          printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: ERROR ** could not open PTX file \&apos;%s\&apos; for reading\n&quot;</span>, ptx_fname );
<a name="l00550"></a>00550          <span class="keywordflow">if</span>( use_extracted_ptx != NULL ) 
<a name="l00551"></a>00551             printf(<span class="stringliteral">&quot;                      Ensure PTX files are in simulation directory.\n&quot;</span>);
<a name="l00552"></a>00552          exit(1);
<a name="l00553"></a>00553       }
<a name="l00554"></a>00554       fseek(fp,0,SEEK_END);
<a name="l00555"></a>00555       <span class="keywordtype">unsigned</span> len = ftell(fp);
<a name="l00556"></a>00556       <span class="keywordflow">if</span>( len == 0 ) {
<a name="l00557"></a>00557          exit(1);
<a name="l00558"></a>00558       }
<a name="l00559"></a>00559       fseek(fp,0,SEEK_SET);
<a name="l00560"></a>00560       <span class="keywordtype">char</span> *tmp = (<span class="keywordtype">char</span>*)calloc(len+1,1);
<a name="l00561"></a>00561       fread(tmp,1,len,fp);
<a name="l00562"></a>00562       fclose(fp);
<a name="l00563"></a>00563       <span class="keywordflow">if</span>( use_extracted_ptx == NULL ) {
<a name="l00564"></a>00564          <span class="comment">// clean up files...</span>
<a name="l00565"></a>00565          <span class="keywordtype">char</span> commandline[1024];
<a name="l00566"></a>00566          snprintf(commandline,1024,<span class="stringliteral">&quot;rm -f %s&quot;</span>, ptx_fname );
<a name="l00567"></a>00567          <span class="keywordtype">int</span> result = system(commandline);
<a name="l00568"></a>00568          <span class="keywordflow">if</span>( result != 0 ) 
<a name="l00569"></a>00569             printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: could not remove temporary files generated while generating PTX\n&quot;</span>);
<a name="l00570"></a>00570          <span class="comment">// remove any trailing characters from string</span>
<a name="l00571"></a>00571          <span class="keywordflow">while</span>( len &gt; 0 &amp;&amp; tmp[len] != <span class="charliteral">&apos;}&apos;</span> ) {
<a name="l00572"></a>00572             tmp[len] = 0;
<a name="l00573"></a>00573             len--;
<a name="l00574"></a>00574          }
<a name="l00575"></a>00575       }
<a name="l00576"></a>00576       info.<a class="code" href="structpgm__info.html#ab15a4b1c33f8e05b1ab06b8f8e660939">m_asm</a> = tmp;
<a name="l00577"></a>00577       info.<a class="code" href="structpgm__info.html#a11f7108a3f798b60f7e08739a4359827">m_symtab</a> = <a class="code" href="ptx__loader_8cc.html#a9153fe1307859dba35b5405fd43cb3d0">gpgpu_ptx_sim_load_ptx_from_string</a>( tmp, source_num );
<a name="l00578"></a>00578       <a class="code" href="ptx__loader_8cc.html#abf8f7af0ec4ae9a3e43acf8658b3a872">gpgpu_ptxinfo_load_from_string</a>( tmp, source_num );
<a name="l00579"></a>00579       <a class="code" href="y_8tab_8c.html#af07d89f5ceaea0c7c8252cc41fd75f37">free</a>(tmp);
<a name="l00580"></a>00580    }
<a name="l00581"></a>00581    printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: finished compiling OpenCL kernels.\n&quot;</span>); 
<a name="l00582"></a>00582 }
<a name="l00583"></a>00583 
<a name="l00584"></a><a class="code" href="struct__cl__program.html#a773e6c0c14e7a387c2c42f0fe31213de">00584</a> cl_kernel <a class="code" href="struct__cl__program.html#a773e6c0c14e7a387c2c42f0fe31213de">_cl_program::CreateKernel</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> *kernel_name, cl_int *errcode_ret )
<a name="l00585"></a>00585 {
<a name="l00586"></a>00586    cl_kernel result = NULL;
<a name="l00587"></a>00587    <span class="keyword">class </span><a class="code" href="classfunction__info.html">function_info</a> *finfo=NULL;
<a name="l00588"></a>00588    std::map&lt;cl_uint,pgm_info&gt;::iterator f;
<a name="l00589"></a>00589    <span class="keywordflow">for</span>( f = <a class="code" href="struct__cl__program.html#a7beecabd493a8dcaa9dae88c6e8268f0">m_pgm</a>.begin(); f!= <a class="code" href="struct__cl__program.html#a7beecabd493a8dcaa9dae88c6e8268f0">m_pgm</a>.end(); f++ ) {
<a name="l00590"></a>00590       <a class="code" href="structpgm__info.html">pgm_info</a> &amp;info=f-&gt;second;
<a name="l00591"></a>00591       std::map&lt;std::string,function_info*&gt;::iterator k = info.<a class="code" href="structpgm__info.html#a9230c523e1d02756709978ce0f2415bb">m_kernels</a>.find(kernel_name);
<a name="l00592"></a>00592       <span class="keywordflow">if</span>( k != info.<a class="code" href="structpgm__info.html#a9230c523e1d02756709978ce0f2415bb">m_kernels</a>.end() ) {
<a name="l00593"></a>00593          assert( finfo == NULL ); <span class="comment">// kernels with same name in different .cl files</span>
<a name="l00594"></a>00594          finfo = k-&gt;second;
<a name="l00595"></a>00595       }
<a name="l00596"></a>00596    }
<a name="l00597"></a>00597 
<a name="l00598"></a>00598    <span class="keywordflow">if</span>( finfo == NULL ) 
<a name="l00599"></a>00599       <a class="code" href="opencl__runtime__api_8cc.html#a39aab942676c56e70bd1cb9ed952b4b1">setErrCode</a>( errcode_ret, CL_INVALID_PROGRAM_EXECUTABLE );
<a name="l00600"></a>00600    <span class="keywordflow">else</span>{ 
<a name="l00601"></a>00601       result = <span class="keyword">new</span> <a class="code" href="struct__cl__kernel.html">_cl_kernel</a>(<span class="keyword">this</span>,kernel_name,finfo);
<a name="l00602"></a>00602       <a class="code" href="opencl__runtime__api_8cc.html#a39aab942676c56e70bd1cb9ed952b4b1">setErrCode</a>( errcode_ret, CL_SUCCESS );
<a name="l00603"></a>00603    }
<a name="l00604"></a>00604    <span class="keywordflow">return</span> result;
<a name="l00605"></a>00605 }
<a name="l00606"></a>00606 
<a name="l00607"></a><a class="code" href="struct__cl__program.html#a35f4f6a682edfe789229ac8c60f6cf45">00607</a> <span class="keywordtype">char</span> *<a class="code" href="struct__cl__program.html#a35f4f6a682edfe789229ac8c60f6cf45">_cl_program::get_ptx</a>()
<a name="l00608"></a>00608 {
<a name="l00609"></a>00609    <span class="keywordflow">if</span>( <a class="code" href="struct__cl__program.html#a7beecabd493a8dcaa9dae88c6e8268f0">m_pgm</a>.empty() ) {
<a name="l00610"></a>00610       printf(<span class="stringliteral">&quot;GPGPU-Sim PTX OpenCL API: Cannot get PTX before building program\n&quot;</span>);
<a name="l00611"></a>00611       abort();
<a name="l00612"></a>00612    }
<a name="l00613"></a>00613    <span class="keywordtype">size_t</span> buffer_length= <a class="code" href="struct__cl__program.html#a802f9f1fd4f863716a0935a570d5e623">get_ptx_size</a>();
<a name="l00614"></a>00614    <span class="keywordtype">char</span> *tmp = (<span class="keywordtype">char</span>*)calloc(buffer_length + 1,1);
<a name="l00615"></a>00615    tmp[ buffer_length ] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l00616"></a>00616    <span class="keywordtype">unsigned</span> <a class="code" href="rng_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>=0;
<a name="l00617"></a>00617    std::map&lt;cl_uint,pgm_info&gt;::iterator p;
<a name="l00618"></a>00618    <span class="keywordflow">for</span>( p=<a class="code" href="struct__cl__program.html#a7beecabd493a8dcaa9dae88c6e8268f0">m_pgm</a>.begin(); p != <a class="code" href="struct__cl__program.html#a7beecabd493a8dcaa9dae88c6e8268f0">m_pgm</a>.end(); p++ ) {
<a name="l00619"></a>00619       <span class="keyword">const</span> <span class="keywordtype">char</span> *ptx = p-&gt;second.m_asm.c_str();
<a name="l00620"></a>00620       <span class="keywordtype">unsigned</span> len = strlen( ptx );
<a name="l00621"></a>00621       assert( (n+len) &lt;= buffer_length );
<a name="l00622"></a>00622       memcpy(tmp+n,ptx,len);
<a name="l00623"></a>00623       n+=len;
<a name="l00624"></a>00624    }
<a name="l00625"></a>00625    assert( n == buffer_length );
<a name="l00626"></a>00626    <span class="keywordflow">return</span> tmp;
<a name="l00627"></a>00627 }
<a name="l00628"></a>00628 
<a name="l00629"></a><a class="code" href="struct__cl__program.html#a802f9f1fd4f863716a0935a570d5e623">00629</a> <span class="keywordtype">size_t</span> <a class="code" href="struct__cl__program.html#a802f9f1fd4f863716a0935a570d5e623">_cl_program::get_ptx_size</a>()
<a name="l00630"></a>00630 {
<a name="l00631"></a>00631    <span class="keywordtype">size_t</span> buffer_length=0;
<a name="l00632"></a>00632    std::map&lt;cl_uint,pgm_info&gt;::iterator p;
<a name="l00633"></a>00633    <span class="keywordflow">for</span>( p=<a class="code" href="struct__cl__program.html#a7beecabd493a8dcaa9dae88c6e8268f0">m_pgm</a>.begin(); p != <a class="code" href="struct__cl__program.html#a7beecabd493a8dcaa9dae88c6e8268f0">m_pgm</a>.end(); p++ ) {
<a name="l00634"></a>00634       buffer_length += p-&gt;second.m_asm.length();
<a name="l00635"></a>00635    }
<a name="l00636"></a>00636    <span class="keywordflow">return</span> buffer_length;
<a name="l00637"></a>00637 }
<a name="l00638"></a>00638 
<a name="l00639"></a>00639 <span class="keywordtype">unsigned</span> <a class="code" href="struct__cl__context.html#a87d08d4f1a5a7059dc2214dcdc0173e2">_cl_context::sm_context_uid</a> = 0;
<a name="l00640"></a>00640 <span class="keywordtype">unsigned</span> <a class="code" href="struct__cl__kernel.html#a20e70791f85ef0893dcd8d957dbec7a9">_cl_kernel::sm_context_uid</a> = 0;
<a name="l00641"></a>00641 
<a name="l00642"></a><a class="code" href="opencl__runtime__api_8cc.html#ae3b3753ad8ad6ad7bf70b03f162dbd10">00642</a> <span class="keyword">class </span><a class="code" href="struct__cl__device__id.html">_cl_device_id</a> *<a class="code" href="cuda__runtime__api_8cc.html#a94c0fea1658f193cb989a8fb9be76d4c">GPGPUSim_Init</a>()
<a name="l00643"></a>00643 {
<a name="l00644"></a>00644    <span class="keyword">static</span> <a class="code" href="struct__cl__device__id.html">_cl_device_id</a> *<a class="code" href="struct__cl__device__id.html#a4b4f1fb55b5839b282f27dd92f4af19a">the_device</a> = NULL;
<a name="l00645"></a>00645    <span class="keywordflow">if</span>( !the_device ) { 
<a name="l00646"></a>00646       <a class="code" href="classgpgpu__sim.html">gpgpu_sim</a> *the_gpu = <a class="code" href="gpgpusim__entrypoint_8cc.html#a58d26c81f3edb7e6e5b31c9c6ca42821">gpgpu_ptx_sim_init_perf</a>(); 
<a name="l00647"></a>00647       the_device = <span class="keyword">new</span> <a class="code" href="struct__cl__device__id.html#a2bf32ec4ec514b8d33beaada022249b4">_cl_device_id</a>(the_gpu);
<a name="l00648"></a>00648    } 
<a name="l00649"></a>00649    <a class="code" href="gpgpusim__entrypoint_8cc.html#a61985b00cca57f3d479f1d3dd1434d11">start_sim_thread</a>(2);
<a name="l00650"></a>00650    <span class="keywordflow">return</span> the_device;
<a name="l00651"></a>00651 }
<a name="l00652"></a>00652 
<a name="l00653"></a><a class="code" href="opencl__runtime__api_8cc.html#a76e0dd21ab0c687276cb8617d0c17e8d">00653</a> <span class="keywordtype">void</span> <a class="code" href="opencl__runtime__api_8cc.html#a76e0dd21ab0c687276cb8617d0c17e8d">opencl_not_implemented</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* func, <span class="keywordtype">unsigned</span> line )
<a name="l00654"></a>00654 {
<a name="l00655"></a>00655    fflush(stdout);
<a name="l00656"></a>00656    fflush(stderr);
<a name="l00657"></a>00657    printf(<span class="stringliteral">&quot;\n\nGPGPU-Sim PTX: Execution error: OpenCL API function \&quot;%s()\&quot; has not been implemented yet.\n&quot;</span>
<a name="l00658"></a>00658          <span class="stringliteral">&quot;                 [$GPGPUSIM_ROOT/libcuda/%s around line %u]\n\n\n&quot;</span>, 
<a name="l00659"></a>00659          func,__FILE__, line );
<a name="l00660"></a>00660    fflush(stdout);
<a name="l00661"></a>00661    abort();
<a name="l00662"></a>00662 }
<a name="l00663"></a>00663 
<a name="l00664"></a><a class="code" href="opencl__runtime__api_8cc.html#a4144ff9136cb09a1986b83ffa411986f">00664</a> <span class="keywordtype">void</span> <a class="code" href="opencl__runtime__api_8cc.html#a4144ff9136cb09a1986b83ffa411986f">opencl_not_finished</a>( <span class="keyword">const</span> <span class="keywordtype">char</span>* func, <span class="keywordtype">unsigned</span> line )
<a name="l00665"></a>00665 {
<a name="l00666"></a>00666    fflush(stdout);
<a name="l00667"></a>00667    fflush(stderr);
<a name="l00668"></a>00668    printf(<span class="stringliteral">&quot;\n\nGPGPU-Sim PTX: Execution error: OpenCL API function \&quot;%s()\&quot; has not been completed yet.\n&quot;</span>
<a name="l00669"></a>00669          <span class="stringliteral">&quot;                 [$GPGPUSIM_ROOT/libopencl/%s around line %u]\n\n\n&quot;</span>, 
<a name="l00670"></a>00670          func,__FILE__, line );
<a name="l00671"></a>00671    fflush(stdout);
<a name="l00672"></a>00672    abort();
<a name="l00673"></a>00673 }
<a name="l00674"></a>00674 
<a name="l00675"></a>00675 <span class="keyword">extern</span> CL_API_ENTRY cl_context CL_API_CALL
<a name="l00676"></a><a class="code" href="opencl__runtime__api_8cc.html#a256a96ca0f0426ab306d198bb1404d5c">00676</a> <a class="code" href="opencl__runtime__api_8cc.html#a256a96ca0f0426ab306d198bb1404d5c">clCreateContextFromType</a>(<span class="keyword">const</span> cl_context_properties * properties,
<a name="l00677"></a>00677                         cl_device_type          device_type,
<a name="l00678"></a>00678                         <span class="keywordtype">void</span> (*pfn_notify)(<span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keyword">const</span> <span class="keywordtype">void</span> *, <span class="keywordtype">size_t</span>, <span class="keywordtype">void</span> *),
<a name="l00679"></a>00679                         <span class="keywordtype">void</span> *                  user_data,
<a name="l00680"></a>00680                         cl_int *                errcode_ret) CL_API_SUFFIX__VERSION_1_0
<a name="l00681"></a>00681 {
<a name="l00682"></a>00682    <a class="code" href="struct__cl__device__id.html">_cl_device_id</a> *gpu = <a class="code" href="cuda__runtime__api_8cc.html#a94c0fea1658f193cb989a8fb9be76d4c">GPGPUSim_Init</a>();
<a name="l00683"></a>00683 
<a name="l00684"></a>00684    <span class="keywordflow">switch</span> (device_type) {
<a name="l00685"></a>00685    <span class="keywordflow">case</span> CL_DEVICE_TYPE_GPU: 
<a name="l00686"></a>00686    <span class="keywordflow">case</span> CL_DEVICE_TYPE_ACCELERATOR:
<a name="l00687"></a>00687    <span class="keywordflow">case</span> CL_DEVICE_TYPE_DEFAULT:
<a name="l00688"></a>00688    <span class="keywordflow">case</span> CL_DEVICE_TYPE_ALL:
<a name="l00689"></a>00689       <span class="keywordflow">break</span>; <span class="comment">// GPGPU-Sim qualifies as these types of device. </span>
<a name="l00690"></a>00690    <span class="keywordflow">default</span>: 
<a name="l00691"></a>00691       printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: unsupported device type %lx\n&quot;</span>, device_type );
<a name="l00692"></a>00692       <a class="code" href="opencl__runtime__api_8cc.html#a39aab942676c56e70bd1cb9ed952b4b1">setErrCode</a>( errcode_ret, CL_DEVICE_NOT_FOUND );
<a name="l00693"></a>00693       <span class="keywordflow">return</span> NULL;
<a name="l00694"></a>00694       <span class="keywordflow">break</span>;
<a name="l00695"></a>00695    }
<a name="l00696"></a>00696    
<a name="l00697"></a>00697    <span class="keywordflow">if</span>( properties != NULL ) {
<a name="l00698"></a>00698       printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: do not know how to use properties in %s\n&quot;</span>, __my_func__ );
<a name="l00699"></a>00699       <span class="comment">//exit(1); // Temporarily commented out to allow the AMD Sample applications to run. </span>
<a name="l00700"></a>00700    }
<a name="l00701"></a>00701    
<a name="l00702"></a>00702    <a class="code" href="opencl__runtime__api_8cc.html#a39aab942676c56e70bd1cb9ed952b4b1">setErrCode</a>( errcode_ret, CL_SUCCESS );
<a name="l00703"></a>00703    cl_context ctx = <span class="keyword">new</span> <a class="code" href="struct__cl__context.html">_cl_context</a>(gpu);
<a name="l00704"></a>00704    <span class="keywordflow">return</span> ctx;
<a name="l00705"></a>00705 }
<a name="l00706"></a>00706 
<a name="l00707"></a>00707 <span class="comment">/***************************** Unimplemented shell functions *******************************************/</span>
<a name="l00708"></a>00708 <span class="keyword">extern</span> CL_API_ENTRY cl_program CL_API_CALL
<a name="l00709"></a><a class="code" href="opencl__runtime__api_8cc.html#a52d60fcc5c96bd55fec1455bfd16d1e8">00709</a> <a class="code" href="opencl__runtime__api_8cc.html#a52d60fcc5c96bd55fec1455bfd16d1e8">clCreateProgramWithBinary</a>(cl_context                     <span class="comment">/* context */</span>,
<a name="l00710"></a>00710                           cl_uint                        <span class="comment">/* num_devices */</span>,
<a name="l00711"></a>00711                           <span class="keyword">const</span> cl_device_id *           <span class="comment">/* device_list */</span>,
<a name="l00712"></a>00712                           <span class="keyword">const</span> <span class="keywordtype">size_t</span> *                 <span class="comment">/* lengths */</span>,
<a name="l00713"></a>00713                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> **         <span class="comment">/* binaries */</span>,
<a name="l00714"></a>00714                           cl_int *                       <span class="comment">/* binary_status */</span>,
<a name="l00715"></a>00715                           cl_int *                       <span class="comment">/* errcode_ret */</span>) CL_API_SUFFIX__VERSION_1_0 {
<a name="l00716"></a>00716 
<a name="l00717"></a>00717     <a class="code" href="opencl__runtime__api_8cc.html#a4144ff9136cb09a1986b83ffa411986f">opencl_not_finished</a>(__my_func__, __LINE__ );
<a name="l00718"></a>00718     <span class="keywordflow">return</span> cl_program();
<a name="l00719"></a>00719 }
<a name="l00720"></a>00720 
<a name="l00721"></a>00721 <span class="keyword">extern</span> CL_API_ENTRY cl_int CL_API_CALL
<a name="l00722"></a><a class="code" href="opencl__runtime__api_8cc.html#a806dcdc2d763c37ea22bbb504bd26745">00722</a> <a class="code" href="opencl__runtime__api_8cc.html#a806dcdc2d763c37ea22bbb504bd26745">clGetEventProfilingInfo</a>(cl_event            <span class="comment">/* event */</span>,
<a name="l00723"></a>00723                         cl_profiling_info   <span class="comment">/* param_name */</span>,
<a name="l00724"></a>00724                         <span class="keywordtype">size_t</span>              <span class="comment">/* param_value_size */</span>,
<a name="l00725"></a>00725                         <span class="keywordtype">void</span> *              <span class="comment">/* param_value */</span>,
<a name="l00726"></a>00726                         <span class="keywordtype">size_t</span> *            <span class="comment">/* param_value_size_ret */</span>) CL_API_SUFFIX__VERSION_1_0{
<a name="l00727"></a>00727     <a class="code" href="opencl__runtime__api_8cc.html#aa5b14a4414d6febccda5d793e905deb5">gpgpusim_opencl_warning</a>(__my_func__,__LINE__, <span class="stringliteral">&quot;GPGPUsim - OpenCLFunction is not implemented. Returning CL_SUCCESS&quot;</span>);
<a name="l00728"></a>00728     <span class="keywordflow">return</span> CL_SUCCESS;
<a name="l00729"></a>00729 }
<a name="l00730"></a>00730 <span class="comment">/*******************************************************************************************************/</span>
<a name="l00731"></a>00731 
<a name="l00732"></a>00732 
<a name="l00733"></a>00733 <span class="keyword">extern</span> CL_API_ENTRY cl_context CL_API_CALL
<a name="l00734"></a><a class="code" href="opencl__runtime__api_8cc.html#af46ebd8efcaf02d9099ca07eeb263295">00734</a> <a class="code" href="opencl__runtime__api_8cc.html#af46ebd8efcaf02d9099ca07eeb263295">clCreateContext</a>(  <span class="keyword">const</span> cl_context_properties * properties,
<a name="l00735"></a>00735                   cl_uint num_devices,
<a name="l00736"></a>00736                   <span class="keyword">const</span> cl_device_id *devices,
<a name="l00737"></a>00737                   <span class="keywordtype">void</span> (*pfn_notify)(<span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keyword">const</span> <span class="keywordtype">void</span> *, <span class="keywordtype">size_t</span>, <span class="keywordtype">void</span> *),
<a name="l00738"></a>00738                   <span class="keywordtype">void</span> *                  user_data,
<a name="l00739"></a>00739                   cl_int *                errcode_ret) CL_API_SUFFIX__VERSION_1_0
<a name="l00740"></a>00740 {
<a name="l00741"></a>00741    <span class="keyword">struct </span><a class="code" href="struct__cl__device__id.html">_cl_device_id</a> *gpu = <a class="code" href="cuda__runtime__api_8cc.html#a94c0fea1658f193cb989a8fb9be76d4c">GPGPUSim_Init</a>();
<a name="l00742"></a>00742    <span class="keywordflow">if</span>( properties != NULL ) {
<a name="l00743"></a>00743       <span class="keywordflow">if</span>( properties[0] != CL_CONTEXT_PLATFORM || properties[1] != (cl_context_properties)&amp;<a class="code" href="opencl__runtime__api_8cc.html#a158cda46f7dea36f60603c58053b3276">g_gpgpu_sim_platform_id</a> ) {
<a name="l00744"></a>00744          <a class="code" href="opencl__runtime__api_8cc.html#a39aab942676c56e70bd1cb9ed952b4b1">setErrCode</a>( errcode_ret, CL_INVALID_PLATFORM );
<a name="l00745"></a>00745          <span class="keywordflow">return</span> NULL;
<a name="l00746"></a>00746       }
<a name="l00747"></a>00747    }
<a name="l00748"></a>00748    <a class="code" href="opencl__runtime__api_8cc.html#a39aab942676c56e70bd1cb9ed952b4b1">setErrCode</a>( errcode_ret, CL_SUCCESS );
<a name="l00749"></a>00749    cl_context ctx = <span class="keyword">new</span> <a class="code" href="struct__cl__context.html">_cl_context</a>(gpu);
<a name="l00750"></a>00750    <span class="keywordflow">return</span> ctx;
<a name="l00751"></a>00751 }
<a name="l00752"></a>00752 
<a name="l00753"></a>00753 <span class="keyword">extern</span> CL_API_ENTRY cl_int CL_API_CALL
<a name="l00754"></a><a class="code" href="opencl__runtime__api_8cc.html#a8adeb18103f752f54e4a7f8d4d97e3e5">00754</a> <a class="code" href="opencl__runtime__api_8cc.html#a8adeb18103f752f54e4a7f8d4d97e3e5">clGetContextInfo</a>(cl_context         context, 
<a name="l00755"></a>00755                  cl_context_info    param_name, 
<a name="l00756"></a>00756                  <span class="keywordtype">size_t</span>             param_value_size, 
<a name="l00757"></a>00757                  <span class="keywordtype">void</span> *             param_value, 
<a name="l00758"></a>00758                  <span class="keywordtype">size_t</span> *           param_value_size_ret ) CL_API_SUFFIX__VERSION_1_0
<a name="l00759"></a>00759 {
<a name="l00760"></a>00760    <span class="keywordflow">if</span>( context == NULL ) <span class="keywordflow">return</span> CL_INVALID_CONTEXT;
<a name="l00761"></a>00761    <span class="keywordflow">switch</span>( param_name ) {
<a name="l00762"></a>00762    <span class="keywordflow">case</span> CL_CONTEXT_DEVICES: {
<a name="l00763"></a>00763       <span class="keywordtype">unsigned</span> ngpu=0;
<a name="l00764"></a>00764       cl_device_id device_id = context-&gt;get_first_device();
<a name="l00765"></a>00765       <span class="keywordflow">while</span> ( device_id != NULL ) {
<a name="l00766"></a>00766          <span class="keywordflow">if</span>( param_value ) 
<a name="l00767"></a>00767             ((cl_device_id*)param_value)[ngpu] = device_id;
<a name="l00768"></a>00768          device_id = device_id-&gt;next();
<a name="l00769"></a>00769          ngpu++;
<a name="l00770"></a>00770       }
<a name="l00771"></a>00771       <span class="keywordflow">if</span>( param_value_size_ret ) *param_value_size_ret = ngpu * <span class="keyword">sizeof</span>(cl_device_id);
<a name="l00772"></a>00772       <span class="keywordflow">break</span>;
<a name="l00773"></a>00773    }
<a name="l00774"></a>00774    <span class="keywordflow">case</span> CL_CONTEXT_REFERENCE_COUNT:
<a name="l00775"></a>00775       <a class="code" href="opencl__runtime__api_8cc.html#a4144ff9136cb09a1986b83ffa411986f">opencl_not_finished</a>(__my_func__,__LINE__);
<a name="l00776"></a>00776       <span class="keywordflow">break</span>;
<a name="l00777"></a>00777    <span class="keywordflow">case</span> CL_CONTEXT_PROPERTIES: 
<a name="l00778"></a>00778       <a class="code" href="opencl__runtime__api_8cc.html#a4144ff9136cb09a1986b83ffa411986f">opencl_not_finished</a>(__my_func__,__LINE__);
<a name="l00779"></a>00779       <span class="keywordflow">break</span>;
<a name="l00780"></a>00780    <span class="keywordflow">default</span>:
<a name="l00781"></a>00781       <a class="code" href="opencl__runtime__api_8cc.html#a4144ff9136cb09a1986b83ffa411986f">opencl_not_finished</a>(__my_func__,__LINE__);
<a name="l00782"></a>00782    }
<a name="l00783"></a>00783    <span class="keywordflow">return</span> CL_SUCCESS;
<a name="l00784"></a>00784 }
<a name="l00785"></a>00785 
<a name="l00786"></a>00786 <span class="keyword">extern</span> CL_API_ENTRY cl_command_queue CL_API_CALL
<a name="l00787"></a><a class="code" href="opencl__runtime__api_8cc.html#a85431441b2cd55106aca8279447c91d3">00787</a> <a class="code" href="opencl__runtime__api_8cc.html#a85431441b2cd55106aca8279447c91d3">clCreateCommandQueue</a>(cl_context                     context, 
<a name="l00788"></a>00788                      cl_device_id                   device, 
<a name="l00789"></a>00789                      cl_command_queue_properties    properties,
<a name="l00790"></a>00790                      cl_int *                       errcode_ret) CL_API_SUFFIX__VERSION_1_0
<a name="l00791"></a>00791 {
<a name="l00792"></a>00792    <span class="keywordflow">if</span>( !context ) { <a class="code" href="opencl__runtime__api_8cc.html#a39aab942676c56e70bd1cb9ed952b4b1">setErrCode</a>( errcode_ret, CL_INVALID_CONTEXT );   <span class="keywordflow">return</span> NULL; }
<a name="l00793"></a>00793    <a class="code" href="opencl__runtime__api_8cc.html#aa5b14a4414d6febccda5d793e905deb5">gpgpusim_opencl_warning</a>(__my_func__,__LINE__, <span class="stringliteral">&quot;assuming device_id is in context&quot;</span>);
<a name="l00794"></a>00794    <span class="keywordflow">if</span>( (properties &amp; CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE) ) 
<a name="l00795"></a>00795       <a class="code" href="opencl__runtime__api_8cc.html#aa5b14a4414d6febccda5d793e905deb5">gpgpusim_opencl_warning</a>(__my_func__,__LINE__, <span class="stringliteral">&quot;ignoring command queue property&quot;</span>);
<a name="l00796"></a>00796    <span class="keywordflow">if</span>( (properties &amp; CL_QUEUE_PROFILING_ENABLE) )
<a name="l00797"></a>00797       <a class="code" href="opencl__runtime__api_8cc.html#aa5b14a4414d6febccda5d793e905deb5">gpgpusim_opencl_warning</a>(__my_func__,__LINE__, <span class="stringliteral">&quot;ignoring command queue property&quot;</span>);
<a name="l00798"></a>00798    <a class="code" href="opencl__runtime__api_8cc.html#a39aab942676c56e70bd1cb9ed952b4b1">setErrCode</a>( errcode_ret, CL_SUCCESS );
<a name="l00799"></a>00799    <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="struct__cl__command__queue.html">_cl_command_queue</a>(context,device,properties);
<a name="l00800"></a>00800 }
<a name="l00801"></a>00801 
<a name="l00802"></a>00802 <span class="keyword">extern</span> CL_API_ENTRY cl_mem CL_API_CALL
<a name="l00803"></a><a class="code" href="opencl__runtime__api_8cc.html#aac38e81744dfa0006b4e44f844dac219">00803</a> <a class="code" href="opencl__runtime__api_8cc.html#aac38e81744dfa0006b4e44f844dac219">clCreateBuffer</a>(cl_context   context,
<a name="l00804"></a>00804                cl_mem_flags flags,
<a name="l00805"></a>00805                <span class="keywordtype">size_t</span>       size ,
<a name="l00806"></a>00806                <span class="keywordtype">void</span> *       host_ptr,
<a name="l00807"></a>00807                cl_int *     errcode_ret ) CL_API_SUFFIX__VERSION_1_0
<a name="l00808"></a>00808 {
<a name="l00809"></a>00809    <span class="keywordflow">if</span>( !context ) { <a class="code" href="opencl__runtime__api_8cc.html#a39aab942676c56e70bd1cb9ed952b4b1">setErrCode</a>( errcode_ret, CL_INVALID_CONTEXT );   <span class="keywordflow">return</span> NULL; }
<a name="l00810"></a>00810    <span class="keywordflow">return</span> context-&gt;CreateBuffer(flags,size,host_ptr,errcode_ret);
<a name="l00811"></a>00811 }
<a name="l00812"></a>00812 
<a name="l00813"></a>00813 <span class="keyword">extern</span> CL_API_ENTRY cl_program CL_API_CALL
<a name="l00814"></a><a class="code" href="opencl__runtime__api_8cc.html#a2b71f734d816faa3449a365bb7c94ce6">00814</a> <a class="code" href="opencl__runtime__api_8cc.html#a2b71f734d816faa3449a365bb7c94ce6">clCreateProgramWithSource</a>(cl_context        context,
<a name="l00815"></a>00815                           cl_uint           count,
<a name="l00816"></a>00816                           <span class="keyword">const</span> <span class="keywordtype">char</span> **     strings,
<a name="l00817"></a>00817                           <span class="keyword">const</span> <span class="keywordtype">size_t</span> *    lengths,
<a name="l00818"></a>00818                           cl_int *          errcode_ret) CL_API_SUFFIX__VERSION_1_0
<a name="l00819"></a>00819 {
<a name="l00820"></a>00820    <span class="keywordflow">if</span>( !context ) { <a class="code" href="opencl__runtime__api_8cc.html#a39aab942676c56e70bd1cb9ed952b4b1">setErrCode</a>( errcode_ret, CL_INVALID_CONTEXT );   <span class="keywordflow">return</span> NULL; }
<a name="l00821"></a>00821    <a class="code" href="opencl__runtime__api_8cc.html#a39aab942676c56e70bd1cb9ed952b4b1">setErrCode</a>( errcode_ret, CL_SUCCESS );
<a name="l00822"></a>00822    <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="struct__cl__program.html">_cl_program</a>(context,count,strings,lengths);
<a name="l00823"></a>00823 }
<a name="l00824"></a>00824 
<a name="l00825"></a>00825 
<a name="l00826"></a>00826 <span class="keyword">extern</span> CL_API_ENTRY cl_int CL_API_CALL
<a name="l00827"></a><a class="code" href="opencl__runtime__api_8cc.html#a84837bb8e5a0f84dc2c2855f6d2f147d">00827</a> <a class="code" href="opencl__runtime__api_8cc.html#a84837bb8e5a0f84dc2c2855f6d2f147d">clBuildProgram</a>(cl_program           program,
<a name="l00828"></a>00828                cl_uint              num_devices,
<a name="l00829"></a>00829                <span class="keyword">const</span> cl_device_id * device_list,
<a name="l00830"></a>00830                <span class="keyword">const</span> <span class="keywordtype">char</span> *         options, 
<a name="l00831"></a>00831                <span class="keywordtype">void</span> (*pfn_notify)(cl_program <span class="comment">/* program */</span>, <span class="keywordtype">void</span> * <span class="comment">/* user_data */</span>),
<a name="l00832"></a>00832                <span class="keywordtype">void</span> *               user_data ) CL_API_SUFFIX__VERSION_1_0
<a name="l00833"></a>00833 {
<a name="l00834"></a>00834    <span class="keywordflow">if</span>( !program ) <span class="keywordflow">return</span> CL_INVALID_PROGRAM;
<a name="l00835"></a>00835    program-&gt;Build(options);
<a name="l00836"></a>00836    <span class="keywordflow">return</span> CL_SUCCESS;
<a name="l00837"></a>00837 }
<a name="l00838"></a>00838 
<a name="l00839"></a>00839 <span class="keyword">extern</span> CL_API_ENTRY cl_kernel CL_API_CALL
<a name="l00840"></a><a class="code" href="opencl__runtime__api_8cc.html#adfa6321d5265fd6d9d0fd0b2c361934e">00840</a> <a class="code" href="opencl__runtime__api_8cc.html#adfa6321d5265fd6d9d0fd0b2c361934e">clCreateKernel</a>(cl_program      program,
<a name="l00841"></a>00841                <span class="keyword">const</span> <span class="keywordtype">char</span> *    kernel_name,
<a name="l00842"></a>00842                cl_int *        errcode_ret) CL_API_SUFFIX__VERSION_1_0
<a name="l00843"></a>00843 {
<a name="l00844"></a>00844    <span class="keywordflow">if</span>( kernel_name == NULL ) {
<a name="l00845"></a>00845       <a class="code" href="opencl__runtime__api_8cc.html#a39aab942676c56e70bd1cb9ed952b4b1">setErrCode</a>( errcode_ret, CL_INVALID_KERNEL_NAME );
<a name="l00846"></a>00846       <span class="keywordflow">return</span> NULL;
<a name="l00847"></a>00847    }
<a name="l00848"></a>00848    cl_kernel kobj = program-&gt;CreateKernel(kernel_name,errcode_ret);
<a name="l00849"></a>00849    <span class="keywordflow">return</span> kobj;
<a name="l00850"></a>00850 }
<a name="l00851"></a>00851 
<a name="l00852"></a>00852 <span class="keyword">extern</span> CL_API_ENTRY cl_int CL_API_CALL
<a name="l00853"></a><a class="code" href="opencl__runtime__api_8cc.html#ae136c0e8327dcddfa7d0cad59c1ec355">00853</a> <a class="code" href="opencl__runtime__api_8cc.html#ae136c0e8327dcddfa7d0cad59c1ec355">clSetKernelArg</a>(cl_kernel    kernel,
<a name="l00854"></a>00854                cl_uint      arg_index,
<a name="l00855"></a>00855                <span class="keywordtype">size_t</span>       arg_size,
<a name="l00856"></a>00856                <span class="keyword">const</span> <span class="keywordtype">void</span> * arg_value ) CL_API_SUFFIX__VERSION_1_0
<a name="l00857"></a>00857 {
<a name="l00858"></a>00858    kernel-&gt;SetKernelArg(arg_index,arg_size,arg_value);
<a name="l00859"></a>00859    <span class="keywordflow">return</span> CL_SUCCESS;
<a name="l00860"></a>00860 }
<a name="l00861"></a>00861 
<a name="l00862"></a>00862 <span class="keyword">extern</span> CL_API_ENTRY cl_int CL_API_CALL
<a name="l00863"></a><a class="code" href="opencl__runtime__api_8cc.html#a5609ab5c9a5106ae9af3dcfefbb53142">00863</a> <a class="code" href="opencl__runtime__api_8cc.html#a5609ab5c9a5106ae9af3dcfefbb53142">clEnqueueNDRangeKernel</a>(cl_command_queue command_queue,
<a name="l00864"></a>00864                        cl_kernel        kernel,
<a name="l00865"></a>00865                        cl_uint          work_dim,
<a name="l00866"></a>00866                        <span class="keyword">const</span> <span class="keywordtype">size_t</span> *   global_work_offset,
<a name="l00867"></a>00867                        <span class="keyword">const</span> <span class="keywordtype">size_t</span> *   global_work_size,
<a name="l00868"></a>00868                        <span class="keyword">const</span> <span class="keywordtype">size_t</span> *   local_work_size,
<a name="l00869"></a>00869                        cl_uint          num_events_in_wait_list,
<a name="l00870"></a>00870                        <span class="keyword">const</span> cl_event * event_wait_list,
<a name="l00871"></a>00871                        cl_event *       event) CL_API_SUFFIX__VERSION_1_0
<a name="l00872"></a>00872 {
<a name="l00873"></a>00873    <span class="keywordtype">int</span> _global_size[3];
<a name="l00874"></a>00874    <span class="keywordtype">int</span> zeros[3] = { 0, 0, 0};
<a name="l00875"></a>00875    printf(<span class="stringliteral">&quot;\n\n\n&quot;</span>);
<a name="l00876"></a>00876    <span class="keywordtype">char</span> *mode = getenv(<span class="stringliteral">&quot;PTX_SIM_MODE_FUNC&quot;</span>);
<a name="l00877"></a>00877    <span class="keywordflow">if</span> ( mode )
<a name="l00878"></a>00878       sscanf(mode,<span class="stringliteral">&quot;%u&quot;</span>, &amp;<a class="code" href="cuda-sim_8cc.html#a6159b587777bb85f99ddc2659decc699">g_ptx_sim_mode</a>);
<a name="l00879"></a>00879    printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: clEnqueueNDRangeKernel &apos;%s&apos; (mode=%s)\n&quot;</span>, kernel-&gt;name().c_str(),
<a name="l00880"></a>00880           <a class="code" href="cuda-sim_8cc.html#a6159b587777bb85f99ddc2659decc699">g_ptx_sim_mode</a>?<span class="stringliteral">&quot;functional simulation&quot;</span>:<span class="stringliteral">&quot;performance simulation&quot;</span>);
<a name="l00881"></a>00881    <span class="keywordflow">if</span> ( !work_dim || work_dim &gt; 3 ) <span class="keywordflow">return</span> CL_INVALID_WORK_DIMENSION;
<a name="l00882"></a>00882    <span class="keywordtype">size_t</span> _local_size[3];
<a name="l00883"></a>00883    <span class="keywordflow">if</span>( local_work_size != NULL ) {
<a name="l00884"></a>00884       <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> d=0; d &lt; work_dim; d++ ) 
<a name="l00885"></a>00885          _local_size[d]=local_work_size[d];
<a name="l00886"></a>00886    } <span class="keywordflow">else</span> {
<a name="l00887"></a>00887       printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: clEnqueueNDRangeKernel automatic local work size selection:\n&quot;</span>);
<a name="l00888"></a>00888       <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> d=0; d &lt; work_dim; d++ ) {
<a name="l00889"></a>00889           <span class="keywordflow">if</span>( d==0 ) {
<a name="l00890"></a>00890              <span class="keywordflow">if</span>( global_work_size[d] &lt;= command_queue-&gt;get_device()-&gt;the_device()-&gt;threads_per_core() ) {
<a name="l00891"></a>00891                 _local_size[d] = global_work_size[d];
<a name="l00892"></a>00892              } <span class="keywordflow">else</span> { 
<a name="l00893"></a>00893                 <span class="comment">// start with the maximum number of thread that a core may hold, </span>
<a name="l00894"></a>00894                 <span class="comment">// and decrement by 64 threadsuntil there is a local_work_size </span>
<a name="l00895"></a>00895                 <span class="comment">// that can perfectly divide the global_work_size. </span>
<a name="l00896"></a>00896                 <span class="keywordtype">unsigned</span> n_thread_per_core = command_queue-&gt;get_device()-&gt;the_device()-&gt;threads_per_core();
<a name="l00897"></a>00897                 <span class="keywordtype">size_t</span> local_size_attempt = n_thread_per_core; 
<a name="l00898"></a>00898                 <span class="keywordflow">while</span> (local_size_attempt &gt; 1 and (n_thread_per_core % 64 == 0)) {
<a name="l00899"></a>00899                    <span class="keywordflow">if</span> (global_work_size[d] % local_size_attempt == 0) {
<a name="l00900"></a>00900                       <span class="keywordflow">break</span>; 
<a name="l00901"></a>00901                    }
<a name="l00902"></a>00902                    local_size_attempt -= 64; 
<a name="l00903"></a>00903                 }
<a name="l00904"></a>00904                 <span class="keywordflow">if</span> (local_size_attempt == 0) local_size_attempt = 1;
<a name="l00905"></a>00905                 _local_size[d] = local_size_attempt;
<a name="l00906"></a>00906              }
<a name="l00907"></a>00907           } <span class="keywordflow">else</span> {
<a name="l00908"></a>00908              _local_size[d] = 1;
<a name="l00909"></a>00909           }
<a name="l00910"></a>00910           printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: clEnqueueNDRangeKernel global_work_size[%u] = %zu\n&quot;</span>, d, global_work_size[d] );
<a name="l00911"></a>00911           printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: clEnqueueNDRangeKernel local_work_size[%u]  = %zu\n&quot;</span>, d, _local_size[d] );
<a name="l00912"></a>00912       }
<a name="l00913"></a>00913    }
<a name="l00914"></a>00914    <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> d=0; d &lt; work_dim; d++ ) {
<a name="l00915"></a>00915       _global_size[d] = (<a class="code" href="classint.html">int</a>)global_work_size[d];
<a name="l00916"></a>00916       <span class="keywordflow">if</span> ( (global_work_size[d] % _local_size[d]) != 0 )
<a name="l00917"></a>00917          <span class="keywordflow">return</span> CL_INVALID_WORK_GROUP_SIZE;
<a name="l00918"></a>00918    }
<a name="l00919"></a>00919    <span class="keywordflow">if</span> (global_work_offset != NULL){
<a name="l00920"></a>00920        <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> d=0; d &lt; work_dim; d++ ) {
<a name="l00921"></a>00921            <span class="keywordflow">if</span> (global_work_offset[d] != 0){
<a name="l00922"></a>00922                printf(<span class="stringliteral">&quot;GPGPU-Sim: global id offset is not supported\n&quot;</span>);
<a name="l00923"></a>00923                abort();
<a name="l00924"></a>00924            }
<a name="l00925"></a>00925        }
<a name="l00926"></a>00926    }
<a name="l00927"></a>00927    assert( global_work_size[0] == _local_size[0] * (global_work_size[0]/_local_size[0]) ); <span class="comment">// i.e., we can divide into equal CTAs</span>
<a name="l00928"></a>00928    <a class="code" href="structdim3.html">dim3</a> GridDim;
<a name="l00929"></a>00929    GridDim.<a class="code" href="structdim3.html#ac94584074d5c15f67c66656859bb24e9">x</a> = global_work_size[0]/_local_size[0];
<a name="l00930"></a>00930    GridDim.<a class="code" href="structdim3.html#ae87d6f5fc0cc038be953f78f36ba873f">y</a> = (work_dim &lt; 2)?1:(global_work_size[1]/_local_size[1]);
<a name="l00931"></a>00931    GridDim.<a class="code" href="structdim3.html#a4856dbf9372e82eb478bf14ec1d2e294">z</a> = (work_dim &lt; 3)?1:(global_work_size[2]/_local_size[2]);
<a name="l00932"></a>00932    <a class="code" href="structdim3.html">dim3</a> BlockDim;
<a name="l00933"></a>00933    BlockDim.<a class="code" href="structdim3.html#ac94584074d5c15f67c66656859bb24e9">x</a> = _local_size[0];
<a name="l00934"></a>00934    BlockDim.<a class="code" href="structdim3.html#ae87d6f5fc0cc038be953f78f36ba873f">y</a> = (work_dim &lt; 2)?1:_local_size[1];
<a name="l00935"></a>00935    BlockDim.<a class="code" href="structdim3.html#a4856dbf9372e82eb478bf14ec1d2e294">z</a> = (work_dim &lt; 3)?1:_local_size[2];
<a name="l00936"></a>00936 
<a name="l00937"></a>00937    <a class="code" href="abstract__hardware__model_8h.html#a400ae36727fbd6ac693cb1adc886e3d4">gpgpu_ptx_sim_arg_list_t</a> params;
<a name="l00938"></a>00938    cl_int err_val = kernel-&gt;bind_args(params);
<a name="l00939"></a>00939    <span class="keywordflow">if</span> ( err_val != CL_SUCCESS ) 
<a name="l00940"></a>00940       <span class="keywordflow">return</span> err_val;
<a name="l00941"></a>00941 
<a name="l00942"></a>00942    <a class="code" href="classgpgpu__t.html">gpgpu_t</a> *gpu = command_queue-&gt;get_device()-&gt;the_device();
<a name="l00943"></a>00943    <span class="keywordflow">if</span> (kernel-&gt;get_implementation()-&gt;get_ptx_version().ver() &lt;3.0){
<a name="l00944"></a>00944        <a class="code" href="cuda-sim_8cc.html#a62747131af7f81c6596dde5d1b070050">gpgpu_ptx_sim_memcpy_symbol</a>( <span class="stringliteral">&quot;%_global_size&quot;</span>, _global_size, 3 * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 0, 1, gpu );
<a name="l00945"></a>00945        <a class="code" href="cuda-sim_8cc.html#a62747131af7f81c6596dde5d1b070050">gpgpu_ptx_sim_memcpy_symbol</a>( <span class="stringliteral">&quot;%_work_dim&quot;</span>, &amp;work_dim, 1 * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 0, 1, gpu  );
<a name="l00946"></a>00946        <a class="code" href="cuda-sim_8cc.html#a62747131af7f81c6596dde5d1b070050">gpgpu_ptx_sim_memcpy_symbol</a>( <span class="stringliteral">&quot;%_global_num_groups&quot;</span>, &amp;GridDim, 3 * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 0, 1, gpu );
<a name="l00947"></a>00947        <a class="code" href="cuda-sim_8cc.html#a62747131af7f81c6596dde5d1b070050">gpgpu_ptx_sim_memcpy_symbol</a>( <span class="stringliteral">&quot;%_global_launch_offset&quot;</span>, zeros, 3 * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 0, 1, gpu );
<a name="l00948"></a>00948        <a class="code" href="cuda-sim_8cc.html#a62747131af7f81c6596dde5d1b070050">gpgpu_ptx_sim_memcpy_symbol</a>( <span class="stringliteral">&quot;%_global_block_offset&quot;</span>, zeros, 3 * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), 0, 1, gpu );
<a name="l00949"></a>00949    }
<a name="l00950"></a>00950    <a class="code" href="classkernel__info__t.html">kernel_info_t</a> *grid = <a class="code" href="cuda-sim_8cc.html#a1c1edbf749ad771a052756c2522be5f4">gpgpu_opencl_ptx_sim_init_grid</a>(kernel-&gt;get_implementation(),params,GridDim,BlockDim,gpu);
<a name="l00951"></a>00951    <span class="keywordflow">if</span> ( <a class="code" href="cuda-sim_8cc.html#a6159b587777bb85f99ddc2659decc699">g_ptx_sim_mode</a> )
<a name="l00952"></a>00952       <a class="code" href="gpgpusim__entrypoint_8cc.html#a63c32e05f024428880359abcd2a7d009" title="Functional simulation of OpenCL.">gpgpu_opencl_ptx_sim_main_func</a>( grid );
<a name="l00953"></a>00953    <span class="keywordflow">else</span>
<a name="l00954"></a>00954       <a class="code" href="gpgpusim__entrypoint_8cc.html#a4c38eaa8195462adebe36eb401e2f51a">gpgpu_opencl_ptx_sim_main_perf</a>( grid );
<a name="l00955"></a>00955    <span class="keywordflow">return</span> CL_SUCCESS;
<a name="l00956"></a>00956 }
<a name="l00957"></a>00957 
<a name="l00958"></a>00958 <span class="keyword">extern</span> CL_API_ENTRY cl_int CL_API_CALL
<a name="l00959"></a><a class="code" href="opencl__runtime__api_8cc.html#a52d733ce5547a57d3f1c599d5f2d023b">00959</a> <a class="code" href="opencl__runtime__api_8cc.html#a52d733ce5547a57d3f1c599d5f2d023b">clEnqueueReadBuffer</a>(cl_command_queue    command_queue,
<a name="l00960"></a>00960                     cl_mem              buffer,
<a name="l00961"></a>00961                     cl_bool             blocking_read,
<a name="l00962"></a>00962                     <span class="keywordtype">size_t</span>              offset,
<a name="l00963"></a>00963                     <span class="keywordtype">size_t</span>              cb, 
<a name="l00964"></a>00964                     <span class="keywordtype">void</span> *              ptr,
<a name="l00965"></a>00965                     cl_uint             num_events_in_wait_list,
<a name="l00966"></a>00966                     <span class="keyword">const</span> cl_event *    event_wait_list,
<a name="l00967"></a>00967                     cl_event *          event ) CL_API_SUFFIX__VERSION_1_0
<a name="l00968"></a>00968 {
<a name="l00969"></a>00969    <span class="keywordflow">if</span>( !blocking_read ) 
<a name="l00970"></a>00970       <a class="code" href="opencl__runtime__api_8cc.html#aa5b14a4414d6febccda5d793e905deb5">gpgpusim_opencl_warning</a>(__my_func__,__LINE__, <span class="stringliteral">&quot;non-blocking read treated as blocking read&quot;</span>);
<a name="l00971"></a>00971    <a class="code" href="classgpgpu__t.html">gpgpu_t</a> *gpu = command_queue-&gt;get_device()-&gt;the_device();
<a name="l00972"></a>00972    gpu-&gt;<a class="code" href="classgpgpu__t.html#a2e9eb56ef7444781e563a3d836557245">memcpy_from_gpu</a>( ptr, (<span class="keywordtype">size_t</span>)buffer, cb );
<a name="l00973"></a>00973    <span class="keywordflow">return</span> CL_SUCCESS;
<a name="l00974"></a>00974 }
<a name="l00975"></a>00975 
<a name="l00976"></a>00976 <span class="keyword">extern</span> CL_API_ENTRY cl_int CL_API_CALL
<a name="l00977"></a><a class="code" href="opencl__runtime__api_8cc.html#a4a75411ecebc89e98a92466c59d25d08">00977</a> <a class="code" href="opencl__runtime__api_8cc.html#a4a75411ecebc89e98a92466c59d25d08">clEnqueueWriteBuffer</a>(cl_command_queue   command_queue, 
<a name="l00978"></a>00978                      cl_mem             buffer, 
<a name="l00979"></a>00979                      cl_bool            blocking_write, 
<a name="l00980"></a>00980                      <span class="keywordtype">size_t</span>             offset, 
<a name="l00981"></a>00981                      <span class="keywordtype">size_t</span>             cb, 
<a name="l00982"></a>00982                      <span class="keyword">const</span> <span class="keywordtype">void</span> *       ptr, 
<a name="l00983"></a>00983                      cl_uint            num_events_in_wait_list, 
<a name="l00984"></a>00984                      <span class="keyword">const</span> cl_event *   event_wait_list, 
<a name="l00985"></a>00985                      cl_event *         event ) CL_API_SUFFIX__VERSION_1_0
<a name="l00986"></a>00986 {
<a name="l00987"></a>00987    <span class="keywordflow">if</span>( !blocking_write ) 
<a name="l00988"></a>00988       <a class="code" href="opencl__runtime__api_8cc.html#aa5b14a4414d6febccda5d793e905deb5">gpgpusim_opencl_warning</a>(__my_func__,__LINE__, <span class="stringliteral">&quot;non-blocking write treated as blocking write&quot;</span>);
<a name="l00989"></a>00989    <a class="code" href="classgpgpu__t.html">gpgpu_t</a> *gpu = command_queue-&gt;get_device()-&gt;the_device();
<a name="l00990"></a>00990    gpu-&gt;<a class="code" href="classgpgpu__t.html#aaf7b32025107b1c53e8939f39d5a8980">memcpy_to_gpu</a>( (<span class="keywordtype">size_t</span>)buffer, ptr, cb );
<a name="l00991"></a>00991    <span class="keywordflow">return</span> CL_SUCCESS;
<a name="l00992"></a>00992 }
<a name="l00993"></a>00993 
<a name="l00994"></a>00994 <span class="keyword">extern</span> CL_API_ENTRY cl_int CL_API_CALL
<a name="l00995"></a><a class="code" href="opencl__runtime__api_8cc.html#a97663dde2bbb31fe98c645ae27b91dce">00995</a> <a class="code" href="opencl__runtime__api_8cc.html#a97663dde2bbb31fe98c645ae27b91dce">clReleaseMemObject</a>(cl_mem <span class="comment">/* memobj */</span>) CL_API_SUFFIX__VERSION_1_0
<a name="l00996"></a>00996 {
<a name="l00997"></a>00997    <span class="keywordflow">return</span> CL_SUCCESS;
<a name="l00998"></a>00998 }
<a name="l00999"></a>00999 
<a name="l01000"></a>01000 <span class="keyword">extern</span> CL_API_ENTRY cl_int CL_API_CALL
<a name="l01001"></a><a class="code" href="opencl__runtime__api_8cc.html#a2e894efd673867e4469018b23e21129c">01001</a> <a class="code" href="opencl__runtime__api_8cc.html#a2e894efd673867e4469018b23e21129c">clReleaseKernel</a>(cl_kernel   <span class="comment">/* kernel */</span>) CL_API_SUFFIX__VERSION_1_0
<a name="l01002"></a>01002 {
<a name="l01003"></a>01003    <span class="keywordflow">return</span> CL_SUCCESS;
<a name="l01004"></a>01004 }
<a name="l01005"></a>01005 
<a name="l01006"></a>01006 <span class="keyword">extern</span> CL_API_ENTRY cl_int CL_API_CALL
<a name="l01007"></a><a class="code" href="opencl__runtime__api_8cc.html#ab95572be7b3cea274bb99a715c1e017c">01007</a> <a class="code" href="opencl__runtime__api_8cc.html#ab95572be7b3cea274bb99a715c1e017c">clReleaseProgram</a>(cl_program <span class="comment">/* program */</span>) CL_API_SUFFIX__VERSION_1_0
<a name="l01008"></a>01008 {
<a name="l01009"></a>01009    <span class="keywordflow">return</span> CL_SUCCESS;
<a name="l01010"></a>01010 }
<a name="l01011"></a>01011 
<a name="l01012"></a>01012 <span class="keyword">extern</span> CL_API_ENTRY cl_int CL_API_CALL
<a name="l01013"></a><a class="code" href="opencl__runtime__api_8cc.html#a9975928511a456e69af5d591584bc726">01013</a> <a class="code" href="opencl__runtime__api_8cc.html#a9975928511a456e69af5d591584bc726">clReleaseCommandQueue</a>(cl_command_queue <span class="comment">/* command_queue */</span>) CL_API_SUFFIX__VERSION_1_0
<a name="l01014"></a>01014 {
<a name="l01015"></a>01015    <span class="keywordflow">return</span> CL_SUCCESS;
<a name="l01016"></a>01016 }
<a name="l01017"></a>01017 
<a name="l01018"></a>01018 <span class="keyword">extern</span> CL_API_ENTRY cl_int CL_API_CALL
<a name="l01019"></a><a class="code" href="opencl__runtime__api_8cc.html#ac96181c013a153c289223c64d2632171">01019</a> <a class="code" href="opencl__runtime__api_8cc.html#ac96181c013a153c289223c64d2632171">clReleaseContext</a>(cl_context <span class="comment">/* context */</span>) CL_API_SUFFIX__VERSION_1_0
<a name="l01020"></a>01020 {
<a name="l01021"></a>01021    <span class="keywordflow">return</span> CL_SUCCESS;
<a name="l01022"></a>01022 }
<a name="l01023"></a>01023 
<a name="l01024"></a>01024 <span class="keyword">extern</span> CL_API_ENTRY cl_int CL_API_CALL
<a name="l01025"></a><a class="code" href="opencl__runtime__api_8cc.html#a72fd787cc7c3397527c1ddeca979ec48">01025</a> <a class="code" href="opencl__runtime__api_8cc.html#a72fd787cc7c3397527c1ddeca979ec48">clGetPlatformIDs</a>(cl_uint num_entries, cl_platform_id *platforms, cl_uint *num_platforms ) CL_API_SUFFIX__VERSION_1_0
<a name="l01026"></a>01026 {
<a name="l01027"></a>01027    <span class="keywordflow">if</span>( ((num_entries == 0) &amp;&amp; (platforms != NULL)) ||
<a name="l01028"></a>01028        ((num_platforms == NULL) &amp;&amp; (platforms == NULL)) ) 
<a name="l01029"></a>01029       <span class="keywordflow">return</span> CL_INVALID_VALUE;
<a name="l01030"></a>01030    <span class="keywordflow">if</span>( (platforms != NULL) &amp;&amp; (num_entries &gt; 0) ) 
<a name="l01031"></a>01031       platforms[0] = &amp;<a class="code" href="opencl__runtime__api_8cc.html#a158cda46f7dea36f60603c58053b3276">g_gpgpu_sim_platform_id</a>;
<a name="l01032"></a>01032    <span class="keywordflow">if</span>( num_platforms )
<a name="l01033"></a>01033       *num_platforms = 1;
<a name="l01034"></a>01034    <span class="keywordflow">return</span> CL_SUCCESS;
<a name="l01035"></a>01035 }
<a name="l01036"></a>01036 
<a name="l01037"></a>01037 <span class="preprocessor">#define CL_STRING_CASE( S ) \</span>
<a name="l01038"></a>01038 <span class="preprocessor">      if( param_value &amp;&amp; (param_value_size &lt; strlen(S)+1) ) return CL_INVALID_VALUE; \</span>
<a name="l01039"></a>01039 <span class="preprocessor">      if( param_value ) snprintf(buf,strlen(S)+1,S); \</span>
<a name="l01040"></a>01040 <span class="preprocessor">      if( param_value_size_ret ) *param_value_size_ret = strlen(S)+1; </span>
<a name="l01041"></a>01041 <span class="preprocessor"></span>
<a name="l01042"></a>01042 <span class="preprocessor">#define CL_INT_CASE( N ) \</span>
<a name="l01043"></a>01043 <span class="preprocessor">      if( param_value &amp;&amp; param_value_size &lt; sizeof(cl_int) ) return CL_INVALID_VALUE; \</span>
<a name="l01044"></a>01044 <span class="preprocessor">      if( param_value ) *((cl_int*)param_value) = (N); \</span>
<a name="l01045"></a>01045 <span class="preprocessor">      if( param_value_size_ret ) *param_value_size_ret = sizeof(cl_int);</span>
<a name="l01046"></a>01046 <span class="preprocessor"></span>
<a name="l01047"></a>01047 <span class="preprocessor">#define CL_UINT_CASE( N ) \</span>
<a name="l01048"></a>01048 <span class="preprocessor">      if( param_value &amp;&amp; param_value_size &lt; sizeof(cl_uint) ) return CL_INVALID_VALUE; \</span>
<a name="l01049"></a>01049 <span class="preprocessor">      if( param_value ) *((cl_uint*)param_value) = (N); \</span>
<a name="l01050"></a>01050 <span class="preprocessor">      if( param_value_size_ret ) *param_value_size_ret = sizeof(cl_uint);</span>
<a name="l01051"></a>01051 <span class="preprocessor"></span>
<a name="l01052"></a>01052 <span class="preprocessor">#define CL_ULONG_CASE( N ) \</span>
<a name="l01053"></a>01053 <span class="preprocessor">      if( param_value &amp;&amp; param_value_size &lt; sizeof(cl_ulong) ) return CL_INVALID_VALUE; \</span>
<a name="l01054"></a>01054 <span class="preprocessor">      if( param_value ) *((cl_ulong*)param_value) = (N); \</span>
<a name="l01055"></a>01055 <span class="preprocessor">      if( param_value_size_ret ) *param_value_size_ret = sizeof(cl_ulong);</span>
<a name="l01056"></a>01056 <span class="preprocessor"></span>
<a name="l01057"></a>01057 <span class="preprocessor">#define CL_BOOL_CASE( N ) \</span>
<a name="l01058"></a>01058 <span class="preprocessor">      if( param_value &amp;&amp; param_value_size &lt; sizeof(cl_bool) ) return CL_INVALID_VALUE; \</span>
<a name="l01059"></a>01059 <span class="preprocessor">      if( param_value ) *((cl_bool*)param_value) = (N); \</span>
<a name="l01060"></a>01060 <span class="preprocessor">      if( param_value_size_ret ) *param_value_size_ret = sizeof(cl_bool);</span>
<a name="l01061"></a>01061 <span class="preprocessor"></span>
<a name="l01062"></a>01062 <span class="preprocessor">#define CL_SIZE_CASE( N ) \</span>
<a name="l01063"></a>01063 <span class="preprocessor">      if( param_value &amp;&amp; param_value_size &lt; sizeof(size_t) ) return CL_INVALID_VALUE; \</span>
<a name="l01064"></a>01064 <span class="preprocessor">      if( param_value ) *((size_t*)param_value) = (N); \</span>
<a name="l01065"></a>01065 <span class="preprocessor">      if( param_value_size_ret ) *param_value_size_ret = sizeof(size_t);</span>
<a name="l01066"></a>01066 <span class="preprocessor"></span>
<a name="l01067"></a>01067 <span class="preprocessor">#define CL_CASE( T, N ) \</span>
<a name="l01068"></a>01068 <span class="preprocessor">      if( param_value &amp;&amp; param_value_size &lt; sizeof(T) ) return CL_INVALID_VALUE; \</span>
<a name="l01069"></a>01069 <span class="preprocessor">      if( param_value ) *((T*)param_value) = (N); \</span>
<a name="l01070"></a>01070 <span class="preprocessor">      if( param_value_size_ret ) *param_value_size_ret = sizeof(T);</span>
<a name="l01071"></a>01071 <span class="preprocessor"></span>
<a name="l01072"></a>01072 <span class="keyword">extern</span> CL_API_ENTRY cl_int CL_API_CALL 
<a name="l01073"></a><a class="code" href="opencl__runtime__api_8cc.html#a3e91e9600323f4cc7e2065a36eab1230">01073</a> <a class="code" href="opencl__runtime__api_8cc.html#a3e91e9600323f4cc7e2065a36eab1230">clGetPlatformInfo</a>(cl_platform_id   platform, 
<a name="l01074"></a>01074                   cl_platform_info param_name,
<a name="l01075"></a>01075                   <span class="keywordtype">size_t</span>           param_value_size, 
<a name="l01076"></a>01076                   <span class="keywordtype">void</span> *           param_value,
<a name="l01077"></a>01077                   <span class="keywordtype">size_t</span> *         param_value_size_ret ) CL_API_SUFFIX__VERSION_1_0
<a name="l01078"></a>01078 {
<a name="l01079"></a>01079    <span class="keywordflow">if</span>( platform == NULL || platform-&gt;m_uid != 0 ) 
<a name="l01080"></a>01080       <span class="keywordflow">return</span> CL_INVALID_PLATFORM;
<a name="l01081"></a>01081    <span class="keywordtype">char</span> *buf = (<span class="keywordtype">char</span>*)param_value;
<a name="l01082"></a>01082    <span class="keywordflow">switch</span>( param_name ) {
<a name="l01083"></a>01083    <span class="keywordflow">case</span> CL_PLATFORM_PROFILE:    CL_STRING_CASE(<span class="stringliteral">&quot;FULL_PROFILE&quot;</span>); <span class="keywordflow">break</span>;
<a name="l01084"></a>01084    <span class="keywordflow">case</span> CL_PLATFORM_VERSION:    CL_STRING_CASE(<span class="stringliteral">&quot;OpenCL 1.0&quot;</span>); <span class="keywordflow">break</span>;
<a name="l01085"></a>01085    <span class="keywordflow">case</span> CL_PLATFORM_NAME:       CL_STRING_CASE(<span class="stringliteral">&quot;GPGPU-Sim&quot;</span>); <span class="keywordflow">break</span>;
<a name="l01086"></a>01086    <span class="keywordflow">case</span> CL_PLATFORM_VENDOR:     CL_STRING_CASE(<span class="stringliteral">&quot;GPGPU-Sim.org&quot;</span>); <span class="keywordflow">break</span>;
<a name="l01087"></a>01087    <span class="keywordflow">case</span> CL_PLATFORM_EXTENSIONS: CL_STRING_CASE(<span class="stringliteral">&quot; &quot;</span>); <span class="keywordflow">break</span>;
<a name="l01088"></a>01088    <span class="keywordflow">default</span>:
<a name="l01089"></a>01089       <span class="keywordflow">return</span> CL_INVALID_VALUE;
<a name="l01090"></a>01090    }
<a name="l01091"></a>01091    <span class="keywordflow">return</span> CL_SUCCESS;
<a name="l01092"></a>01092 }
<a name="l01093"></a>01093 
<a name="l01094"></a>01094 <span class="preprocessor">#define NUM_DEVICES 1</span>
<a name="l01095"></a>01095 <span class="preprocessor"></span>
<a name="l01096"></a>01096 <span class="keyword">extern</span> CL_API_ENTRY cl_int CL_API_CALL
<a name="l01097"></a><a class="code" href="opencl__runtime__api_8cc.html#a4e58dd3dae9970b7a26bf09feb2f0877">01097</a> <a class="code" href="opencl__runtime__api_8cc.html#a4e58dd3dae9970b7a26bf09feb2f0877">clGetDeviceIDs</a>(cl_platform_id   platform,
<a name="l01098"></a>01098                cl_device_type   device_type, 
<a name="l01099"></a>01099                cl_uint          num_entries, 
<a name="l01100"></a>01100                cl_device_id *   devices, 
<a name="l01101"></a>01101                cl_uint *        num_devices ) CL_API_SUFFIX__VERSION_1_0
<a name="l01102"></a>01102 {
<a name="l01103"></a>01103    <span class="keywordflow">if</span>( platform == NULL || platform-&gt;m_uid != 0 ) 
<a name="l01104"></a>01104       <span class="keywordflow">return</span> CL_INVALID_PLATFORM;
<a name="l01105"></a>01105    <span class="keywordflow">if</span>( (num_entries == 0 &amp;&amp; devices != NULL) ||
<a name="l01106"></a>01106        (num_devices == NULL &amp;&amp; devices == NULL) )
<a name="l01107"></a>01107       <span class="keywordflow">return</span> CL_INVALID_VALUE;
<a name="l01108"></a>01108 
<a name="l01109"></a>01109    <span class="keywordflow">switch</span>( device_type ) {
<a name="l01110"></a>01110    <span class="keywordflow">case</span> CL_DEVICE_TYPE_CPU: 
<a name="l01111"></a>01111       <span class="comment">// Some benchmarks (e.g. ComD benchmark from Mantevo package) looks for CPU and GPU to choose among, so it is not wise to abort execution because of GPGPUsim is not a CPU !.</span>
<a name="l01112"></a>01112       printf(<span class="stringliteral">&quot;GPGPU-Sim OpenCL API: unsupported device type %lx\n&quot;</span>, device_type );
<a name="l01113"></a>01113       <span class="keywordflow">return</span> CL_DEVICE_NOT_FOUND;
<a name="l01114"></a>01114       <span class="keywordflow">break</span>;
<a name="l01115"></a>01115    <span class="keywordflow">case</span> CL_DEVICE_TYPE_DEFAULT:
<a name="l01116"></a>01116    <span class="keywordflow">case</span> CL_DEVICE_TYPE_GPU: 
<a name="l01117"></a>01117    <span class="keywordflow">case</span> CL_DEVICE_TYPE_ACCELERATOR:
<a name="l01118"></a>01118    <span class="keywordflow">case</span> CL_DEVICE_TYPE_ALL:
<a name="l01119"></a>01119       <span class="keywordflow">if</span>( devices != NULL ) 
<a name="l01120"></a>01120          devices[0] = <a class="code" href="cuda__runtime__api_8cc.html#a94c0fea1658f193cb989a8fb9be76d4c">GPGPUSim_Init</a>();
<a name="l01121"></a>01121       <span class="keywordflow">if</span>( num_devices ) 
<a name="l01122"></a>01122          *num_devices = NUM_DEVICES;
<a name="l01123"></a>01123       <span class="keywordflow">break</span>;
<a name="l01124"></a>01124    <span class="keywordflow">default</span>:
<a name="l01125"></a>01125       <span class="keywordflow">return</span> CL_INVALID_DEVICE_TYPE;
<a name="l01126"></a>01126    }
<a name="l01127"></a>01127    <span class="keywordflow">return</span> CL_SUCCESS;
<a name="l01128"></a>01128 }
<a name="l01129"></a>01129 
<a name="l01130"></a>01130 <span class="keyword">extern</span> CL_API_ENTRY cl_int CL_API_CALL
<a name="l01131"></a><a class="code" href="opencl__runtime__api_8cc.html#a70aeb5d8a9c7c4635aa3c161d5266947">01131</a> <a class="code" href="opencl__runtime__api_8cc.html#a70aeb5d8a9c7c4635aa3c161d5266947">clGetDeviceInfo</a>(cl_device_id    device,
<a name="l01132"></a>01132                 cl_device_info  param_name, 
<a name="l01133"></a>01133                 <span class="keywordtype">size_t</span>          param_value_size, 
<a name="l01134"></a>01134                 <span class="keywordtype">void</span> *          param_value,
<a name="l01135"></a>01135                 <span class="keywordtype">size_t</span> *        param_value_size_ret) CL_API_SUFFIX__VERSION_1_0
<a name="l01136"></a>01136 {
<a name="l01137"></a>01137    <span class="keywordflow">if</span>( device != <a class="code" href="cuda__runtime__api_8cc.html#a94c0fea1658f193cb989a8fb9be76d4c">GPGPUSim_Init</a>() ) 
<a name="l01138"></a>01138       <span class="keywordflow">return</span> CL_INVALID_DEVICE;
<a name="l01139"></a>01139    <span class="keywordtype">char</span> *buf = (<span class="keywordtype">char</span>*)param_value;
<a name="l01140"></a>01140    <span class="keywordflow">switch</span>( param_name ) {
<a name="l01141"></a>01141    <span class="keywordflow">case</span> CL_DEVICE_NAME: CL_STRING_CASE( <span class="stringliteral">&quot;GPGPU-Sim&quot;</span> ); <span class="keywordflow">break</span>;
<a name="l01142"></a>01142    <span class="keywordflow">case</span> CL_DEVICE_GLOBAL_MEM_SIZE: CL_ULONG_CASE( 1024*1024*1024 ); <span class="keywordflow">break</span>;
<a name="l01143"></a>01143    <span class="keywordflow">case</span> CL_DEVICE_MAX_COMPUTE_UNITS: CL_UINT_CASE( device-&gt;the_device()-&gt;get_config().num_shader() ); <span class="keywordflow">break</span>;
<a name="l01144"></a>01144    <span class="keywordflow">case</span> CL_DEVICE_MAX_CLOCK_FREQUENCY: CL_UINT_CASE( device-&gt;the_device()-&gt;shader_clock() ); <span class="keywordflow">break</span>;
<a name="l01145"></a>01145    <span class="keywordflow">case</span> CL_DEVICE_VENDOR:CL_STRING_CASE(<span class="stringliteral">&quot;GPGPU-Sim.org&quot;</span>); <span class="keywordflow">break</span>;
<a name="l01146"></a>01146    <span class="keywordflow">case</span> CL_DEVICE_VERSION: CL_STRING_CASE(<span class="stringliteral">&quot;OpenCL 1.0&quot;</span>); <span class="keywordflow">break</span>;
<a name="l01147"></a>01147    <span class="keywordflow">case</span> CL_DRIVER_VERSION: CL_STRING_CASE(<span class="stringliteral">&quot;1.0&quot;</span>); <span class="keywordflow">break</span>;
<a name="l01148"></a>01148    <span class="keywordflow">case</span> CL_DEVICE_TYPE: CL_CASE(cl_device_type, CL_DEVICE_TYPE_GPU); <span class="keywordflow">break</span>;
<a name="l01149"></a>01149    <span class="keywordflow">case</span> CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS: CL_INT_CASE( 3 ); <span class="keywordflow">break</span>;
<a name="l01150"></a>01150    <span class="keywordflow">case</span> CL_DEVICE_MAX_WORK_ITEM_SIZES: 
<a name="l01151"></a>01151       <span class="keywordflow">if</span>( param_value &amp;&amp; param_value_size &lt; 3*<span class="keyword">sizeof</span>(<span class="keywordtype">size_t</span>) ) <span class="keywordflow">return</span> CL_INVALID_VALUE; \
<a name="l01152"></a>01152       <span class="keywordflow">if</span>( param_value ) {
<a name="l01153"></a>01153          <span class="keywordtype">unsigned</span> n_thread_per_shader = device-&gt;the_device()-&gt;threads_per_core();
<a name="l01154"></a>01154          ((<span class="keywordtype">size_t</span>*)param_value)[0] = n_thread_per_shader;
<a name="l01155"></a>01155          ((<span class="keywordtype">size_t</span>*)param_value)[1] = n_thread_per_shader;
<a name="l01156"></a>01156          ((<span class="keywordtype">size_t</span>*)param_value)[2] = n_thread_per_shader;
<a name="l01157"></a>01157       }
<a name="l01158"></a>01158       <span class="keywordflow">if</span>( param_value_size_ret ) *param_value_size_ret = 3*<span class="keyword">sizeof</span>(cl_uint);
<a name="l01159"></a>01159       <span class="keywordflow">break</span>;
<a name="l01160"></a>01160    <span class="keywordflow">case</span> CL_DEVICE_MAX_WORK_GROUP_SIZE: CL_INT_CASE( device-&gt;the_device()-&gt;threads_per_core() ); <span class="keywordflow">break</span>;
<a name="l01161"></a>01161    <span class="keywordflow">case</span> CL_DEVICE_ADDRESS_BITS: CL_INT_CASE( 32 ); <span class="keywordflow">break</span>;
<a name="l01162"></a>01162    <span class="keywordflow">case</span> CL_DEVICE_AVAILABLE: CL_BOOL_CASE( CL_TRUE ); <span class="keywordflow">break</span>;
<a name="l01163"></a>01163    <span class="keywordflow">case</span> CL_DEVICE_COMPILER_AVAILABLE: CL_BOOL_CASE( CL_TRUE ); <span class="keywordflow">break</span>;
<a name="l01164"></a>01164    <span class="keywordflow">case</span> CL_DEVICE_IMAGE_SUPPORT: CL_INT_CASE( CL_TRUE ); <span class="keywordflow">break</span>;
<a name="l01165"></a>01165    <span class="keywordflow">case</span> CL_DEVICE_MAX_READ_IMAGE_ARGS: CL_INT_CASE( 128 ); <span class="keywordflow">break</span>;
<a name="l01166"></a>01166    <span class="keywordflow">case</span> CL_DEVICE_MAX_WRITE_IMAGE_ARGS: CL_INT_CASE( 8 ); <span class="keywordflow">break</span>;
<a name="l01167"></a>01167    <span class="keywordflow">case</span> CL_DEVICE_IMAGE2D_MAX_HEIGHT: CL_INT_CASE( 8192 ); <span class="keywordflow">break</span>;
<a name="l01168"></a>01168    <span class="keywordflow">case</span> CL_DEVICE_IMAGE2D_MAX_WIDTH: CL_INT_CASE( 8192 ); <span class="keywordflow">break</span>;
<a name="l01169"></a>01169    <span class="keywordflow">case</span> CL_DEVICE_IMAGE3D_MAX_HEIGHT: CL_INT_CASE( 2048 ); <span class="keywordflow">break</span>;
<a name="l01170"></a>01170    <span class="keywordflow">case</span> CL_DEVICE_IMAGE3D_MAX_WIDTH: CL_INT_CASE( 2048 ); <span class="keywordflow">break</span>;
<a name="l01171"></a>01171    <span class="keywordflow">case</span> CL_DEVICE_IMAGE3D_MAX_DEPTH: CL_INT_CASE( 2048 ); <span class="keywordflow">break</span>;
<a name="l01172"></a>01172    <span class="keywordflow">case</span> CL_DEVICE_MAX_MEM_ALLOC_SIZE: CL_INT_CASE( 128*1024*1024 ); <span class="keywordflow">break</span>;
<a name="l01173"></a>01173    <span class="keywordflow">case</span> CL_DEVICE_ERROR_CORRECTION_SUPPORT: CL_INT_CASE( 0 ); <span class="keywordflow">break</span>;
<a name="l01174"></a>01174    <span class="keywordflow">case</span> CL_DEVICE_LOCAL_MEM_TYPE: CL_INT_CASE( CL_LOCAL ); <span class="keywordflow">break</span>;
<a name="l01175"></a>01175    <span class="keywordflow">case</span> CL_DEVICE_LOCAL_MEM_SIZE: CL_ULONG_CASE( device-&gt;the_device()-&gt;shared_mem_size() ); <span class="keywordflow">break</span>;
<a name="l01176"></a>01176    <span class="keywordflow">case</span> CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE: CL_ULONG_CASE( 64 * 1024 ); <span class="keywordflow">break</span>;
<a name="l01177"></a>01177    <span class="keywordflow">case</span> CL_DEVICE_QUEUE_PROPERTIES: CL_INT_CASE( CL_QUEUE_PROFILING_ENABLE ); <span class="keywordflow">break</span>;
<a name="l01178"></a>01178    <span class="keywordflow">case</span> CL_DEVICE_EXTENSIONS: 
<a name="l01179"></a>01179       <span class="keywordflow">if</span>( param_value &amp;&amp; (param_value_size &lt; 1) ) <span class="keywordflow">return</span> CL_INVALID_VALUE; 
<a name="l01180"></a>01180       <span class="keywordflow">if</span>( param_value ) buf[0]=0;
<a name="l01181"></a>01181       <span class="keywordflow">if</span>( param_value_size_ret ) *param_value_size_ret = 1; 
<a name="l01182"></a>01182       <span class="keywordflow">break</span>;
<a name="l01183"></a>01183    <span class="keywordflow">case</span> CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR: CL_INT_CASE(1); <span class="keywordflow">break</span>;
<a name="l01184"></a>01184    <span class="keywordflow">case</span> CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT: CL_INT_CASE(1); <span class="keywordflow">break</span>;
<a name="l01185"></a>01185    <span class="keywordflow">case</span> CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT: CL_INT_CASE(1); <span class="keywordflow">break</span>;
<a name="l01186"></a>01186    <span class="keywordflow">case</span> CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG: CL_INT_CASE(1); <span class="keywordflow">break</span>;
<a name="l01187"></a>01187    <span class="keywordflow">case</span> CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT: CL_INT_CASE(1); <span class="keywordflow">break</span>;
<a name="l01188"></a>01188    <span class="keywordflow">case</span> CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE: CL_INT_CASE(0); <span class="keywordflow">break</span>;
<a name="l01189"></a>01189    <span class="keywordflow">case</span> CL_DEVICE_SINGLE_FP_CONFIG: CL_INT_CASE(0); <span class="keywordflow">break</span>;
<a name="l01190"></a>01190    <span class="keywordflow">case</span> CL_DEVICE_MEM_BASE_ADDR_ALIGN: CL_INT_CASE(256*8); <span class="keywordflow">break</span>;
<a name="l01191"></a>01191    <span class="keywordflow">default</span>:
<a name="l01192"></a>01192       <a class="code" href="opencl__runtime__api_8cc.html#a76e0dd21ab0c687276cb8617d0c17e8d">opencl_not_implemented</a>(__my_func__,__LINE__);
<a name="l01193"></a>01193    }
<a name="l01194"></a>01194    <span class="keywordflow">return</span> CL_SUCCESS;
<a name="l01195"></a>01195 }
<a name="l01196"></a>01196 
<a name="l01197"></a>01197 <span class="keyword">extern</span> CL_API_ENTRY cl_int CL_API_CALL
<a name="l01198"></a><a class="code" href="opencl__runtime__api_8cc.html#a6688e8be559fd5745ec716b847e4569f">01198</a> <a class="code" href="opencl__runtime__api_8cc.html#a6688e8be559fd5745ec716b847e4569f">clFinish</a>(cl_command_queue <span class="comment">/* command_queue */</span>) CL_API_SUFFIX__VERSION_1_0
<a name="l01199"></a>01199 {
<a name="l01200"></a>01200    <span class="keywordflow">return</span> CL_SUCCESS;
<a name="l01201"></a>01201 }
<a name="l01202"></a>01202 
<a name="l01203"></a>01203 <span class="keyword">extern</span> CL_API_ENTRY cl_int CL_API_CALL
<a name="l01204"></a><a class="code" href="opencl__runtime__api_8cc.html#a52934f42e02f691020329cb58ec7e5b0">01204</a> <a class="code" href="opencl__runtime__api_8cc.html#a52934f42e02f691020329cb58ec7e5b0">clGetProgramInfo</a>(cl_program         program,
<a name="l01205"></a>01205                  cl_program_info    param_name,
<a name="l01206"></a>01206                  <span class="keywordtype">size_t</span>             param_value_size,
<a name="l01207"></a>01207                  <span class="keywordtype">void</span> *             param_value,
<a name="l01208"></a>01208                  <span class="keywordtype">size_t</span> *           param_value_size_ret ) CL_API_SUFFIX__VERSION_1_0
<a name="l01209"></a>01209 {
<a name="l01210"></a>01210    <span class="keywordflow">if</span>( program == NULL ) 
<a name="l01211"></a>01211       <span class="keywordflow">return</span> CL_INVALID_PROGRAM;
<a name="l01212"></a>01212    <span class="keywordtype">char</span> *tmp=NULL;
<a name="l01213"></a>01213    <span class="keywordtype">size_t</span> len=0;
<a name="l01214"></a>01214    <span class="keywordflow">switch</span>( param_name ) {
<a name="l01215"></a>01215    <span class="keywordflow">case</span> CL_PROGRAM_REFERENCE_COUNT: 
<a name="l01216"></a>01216       CL_INT_CASE(1);
<a name="l01217"></a>01217       <span class="keywordflow">break</span>;
<a name="l01218"></a>01218    <span class="keywordflow">case</span> CL_PROGRAM_CONTEXT:
<a name="l01219"></a>01219       <span class="keywordflow">if</span>( param_value &amp;&amp; param_value_size &lt; <span class="keyword">sizeof</span>(cl_context)) <span class="keywordflow">return</span> CL_INVALID_VALUE;
<a name="l01220"></a>01220       <span class="keywordflow">if</span>( param_value ) *((cl_context*)param_value) = program-&gt;get_context();
<a name="l01221"></a>01221       <span class="keywordflow">if</span>( param_value_size_ret ) *param_value_size_ret = <span class="keyword">sizeof</span>(cl_context);
<a name="l01222"></a>01222       <span class="keywordflow">break</span>;
<a name="l01223"></a>01223    <span class="keywordflow">case</span> CL_PROGRAM_NUM_DEVICES:
<a name="l01224"></a>01224       CL_INT_CASE(NUM_DEVICES);
<a name="l01225"></a>01225       <span class="keywordflow">break</span>;
<a name="l01226"></a>01226    <span class="keywordflow">case</span> CL_PROGRAM_DEVICES:
<a name="l01227"></a>01227       <span class="keywordflow">if</span>( param_value &amp;&amp; param_value_size &lt; NUM_DEVICES * <span class="keyword">sizeof</span>(cl_device_id) ) 
<a name="l01228"></a>01228          <span class="keywordflow">return</span> CL_INVALID_VALUE;
<a name="l01229"></a>01229       <span class="keywordflow">if</span>( param_value ) {
<a name="l01230"></a>01230          assert( NUM_DEVICES == 1 );
<a name="l01231"></a>01231          ((cl_device_id*)param_value)[0] = <a class="code" href="cuda__runtime__api_8cc.html#a94c0fea1658f193cb989a8fb9be76d4c">GPGPUSim_Init</a>();
<a name="l01232"></a>01232       }
<a name="l01233"></a>01233       <span class="keywordflow">if</span>( param_value_size_ret ) *param_value_size_ret = <span class="keyword">sizeof</span>(cl_device_id);
<a name="l01234"></a>01234       <span class="keywordflow">break</span>;
<a name="l01235"></a>01235    <span class="keywordflow">case</span> CL_PROGRAM_SOURCE:
<a name="l01236"></a>01236       <a class="code" href="opencl__runtime__api_8cc.html#a76e0dd21ab0c687276cb8617d0c17e8d">opencl_not_implemented</a>(__my_func__,__LINE__);
<a name="l01237"></a>01237       <span class="keywordflow">break</span>;
<a name="l01238"></a>01238    <span class="keywordflow">case</span> CL_PROGRAM_BINARY_SIZES:
<a name="l01239"></a>01239       <span class="keywordflow">if</span>( param_value &amp;&amp; param_value_size &lt; NUM_DEVICES * <span class="keyword">sizeof</span>(<span class="keywordtype">size_t</span>) ) <span class="keywordflow">return</span> CL_INVALID_VALUE;
<a name="l01240"></a>01240       <span class="keywordflow">if</span>( param_value ) *((<span class="keywordtype">size_t</span>*)param_value) = program-&gt;get_ptx_size();
<a name="l01241"></a>01241       <span class="keywordflow">if</span>( param_value_size_ret ) *param_value_size_ret = NUM_DEVICES*<span class="keyword">sizeof</span>(size_t);
<a name="l01242"></a>01242       <span class="keywordflow">break</span>;
<a name="l01243"></a>01243    <span class="keywordflow">case</span> CL_PROGRAM_BINARIES:
<a name="l01244"></a>01244       len = program-&gt;get_ptx_size();
<a name="l01245"></a>01245       tmp = program-&gt;get_ptx();
<a name="l01246"></a>01246       <span class="keywordflow">if</span>( param_value ) memcpy( ((<span class="keywordtype">char</span>**)param_value)[0], tmp, len );
<a name="l01247"></a>01247       <span class="keywordflow">if</span>( param_value_size_ret ) *param_value_size_ret = len;
<a name="l01248"></a>01248       <span class="keywordflow">break</span>;
<a name="l01249"></a>01249    <span class="keywordflow">default</span>:
<a name="l01250"></a>01250       <span class="keywordflow">return</span> CL_INVALID_VALUE;
<a name="l01251"></a>01251       <span class="keywordflow">break</span>;
<a name="l01252"></a>01252    }
<a name="l01253"></a>01253    <span class="keywordflow">return</span> CL_SUCCESS;
<a name="l01254"></a>01254 }
<a name="l01255"></a>01255 
<a name="l01256"></a>01256 <span class="keyword">extern</span> CL_API_ENTRY cl_int CL_API_CALL
<a name="l01257"></a><a class="code" href="opencl__runtime__api_8cc.html#aaff251aaad037ec76c4770de6723f49c">01257</a> <a class="code" href="opencl__runtime__api_8cc.html#aaff251aaad037ec76c4770de6723f49c">clEnqueueCopyBuffer</a>(cl_command_queue    command_queue, 
<a name="l01258"></a>01258                     cl_mem              src_buffer,
<a name="l01259"></a>01259                     cl_mem              dst_buffer, 
<a name="l01260"></a>01260                     <span class="keywordtype">size_t</span>              src_offset,
<a name="l01261"></a>01261                     <span class="keywordtype">size_t</span>              dst_offset,
<a name="l01262"></a>01262                     <span class="keywordtype">size_t</span>              cb, 
<a name="l01263"></a>01263                     cl_uint             num_events_in_wait_list,
<a name="l01264"></a>01264                     <span class="keyword">const</span> cl_event *    event_wait_list,
<a name="l01265"></a>01265                     cl_event *          event ) CL_API_SUFFIX__VERSION_1_0
<a name="l01266"></a>01266 {
<a name="l01267"></a>01267    <span class="keywordflow">if</span>( num_events_in_wait_list &gt; 0 ) 
<a name="l01268"></a>01268       <a class="code" href="opencl__runtime__api_8cc.html#a76e0dd21ab0c687276cb8617d0c17e8d">opencl_not_implemented</a>(__my_func__,__LINE__);
<a name="l01269"></a>01269    <span class="keywordflow">if</span>( command_queue == NULL || !command_queue-&gt;is_valid() ) 
<a name="l01270"></a>01270       <span class="keywordflow">return</span> CL_INVALID_COMMAND_QUEUE;
<a name="l01271"></a>01271    cl_context context = command_queue-&gt;get_context();
<a name="l01272"></a>01272    cl_mem src = context-&gt;lookup_mem( src_buffer );
<a name="l01273"></a>01273    cl_mem dst = context-&gt;lookup_mem( dst_buffer );
<a name="l01274"></a>01274    <span class="keywordflow">if</span>( src == NULL || dst == NULL ) 
<a name="l01275"></a>01275       <span class="keywordflow">return</span> CL_INVALID_MEM_OBJECT;
<a name="l01276"></a>01276 
<a name="l01277"></a>01277    <a class="code" href="classgpgpu__t.html">gpgpu_t</a> *gpu = command_queue-&gt;get_device()-&gt;the_device();
<a name="l01278"></a>01278    <span class="keywordflow">if</span>( src-&gt;is_on_host() &amp;&amp; !dst-&gt;is_on_host() )
<a name="l01279"></a>01279       gpu-&gt;<a class="code" href="classgpgpu__t.html#aaf7b32025107b1c53e8939f39d5a8980">memcpy_to_gpu</a>( ((<span class="keywordtype">size_t</span>)dst-&gt;device_ptr())+dst_offset, ((<span class="keywordtype">char</span>*)src-&gt;host_ptr())+src_offset, cb );
<a name="l01280"></a>01280    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( !src-&gt;is_on_host() &amp;&amp; dst-&gt;is_on_host() ) 
<a name="l01281"></a>01281       gpu-&gt;<a class="code" href="classgpgpu__t.html#a2e9eb56ef7444781e563a3d836557245">memcpy_from_gpu</a>( ((<span class="keywordtype">char</span>*)dst-&gt;host_ptr())+dst_offset, ((<span class="keywordtype">size_t</span>)src-&gt;device_ptr())+src_offset, cb );
<a name="l01282"></a>01282    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( !src-&gt;is_on_host() &amp;&amp; !dst-&gt;is_on_host() ) 
<a name="l01283"></a>01283       gpu-&gt;<a class="code" href="classgpgpu__t.html#a118cf20fa0de5d8584929f18693eadc0">memcpy_gpu_to_gpu</a>( ((<span class="keywordtype">size_t</span>)dst-&gt;device_ptr())+dst_offset, ((<span class="keywordtype">size_t</span>)src-&gt;device_ptr())+src_offset, cb );
<a name="l01284"></a>01284    <span class="keywordflow">else</span>
<a name="l01285"></a>01285       <a class="code" href="opencl__runtime__api_8cc.html#a76e0dd21ab0c687276cb8617d0c17e8d">opencl_not_implemented</a>(__my_func__,__LINE__);
<a name="l01286"></a>01286    <span class="keywordflow">return</span> CL_SUCCESS;
<a name="l01287"></a>01287 }
<a name="l01288"></a>01288 
<a name="l01289"></a>01289 <span class="keyword">extern</span> CL_API_ENTRY cl_int CL_API_CALL
<a name="l01290"></a><a class="code" href="opencl__runtime__api_8cc.html#ad2f1a1bbfe00262291e4823a004d94d5">01290</a> <a class="code" href="opencl__runtime__api_8cc.html#ad2f1a1bbfe00262291e4823a004d94d5">clGetKernelWorkGroupInfo</a>(cl_kernel                  kernel,
<a name="l01291"></a>01291                          cl_device_id               device,
<a name="l01292"></a>01292                          cl_kernel_work_group_info  param_name,
<a name="l01293"></a>01293                          <span class="keywordtype">size_t</span>                     param_value_size,
<a name="l01294"></a>01294                          <span class="keywordtype">void</span> *                     param_value,
<a name="l01295"></a>01295                          <span class="keywordtype">size_t</span> *                   param_value_size_ret ) CL_API_SUFFIX__VERSION_1_0
<a name="l01296"></a>01296 {
<a name="l01297"></a>01297    <span class="keywordflow">if</span>( kernel == NULL ) 
<a name="l01298"></a>01298       <span class="keywordflow">return</span> CL_INVALID_KERNEL;
<a name="l01299"></a>01299    <span class="keywordflow">switch</span>( param_name ) {
<a name="l01300"></a>01300    <span class="keywordflow">case</span> CL_KERNEL_WORK_GROUP_SIZE:
<a name="l01301"></a>01301       CL_SIZE_CASE( kernel-&gt;get_workgroup_size(device) );
<a name="l01302"></a>01302       <span class="keywordflow">break</span>;
<a name="l01303"></a>01303    <span class="keywordflow">case</span> CL_KERNEL_COMPILE_WORK_GROUP_SIZE:
<a name="l01304"></a>01304    <span class="keywordflow">case</span> CL_KERNEL_LOCAL_MEM_SIZE:
<a name="l01305"></a>01305       <a class="code" href="opencl__runtime__api_8cc.html#a76e0dd21ab0c687276cb8617d0c17e8d">opencl_not_implemented</a>(__my_func__,__LINE__);
<a name="l01306"></a>01306       *(<span class="keywordtype">size_t</span> *)param_value = device-&gt;the_device()-&gt;shared_mem_size();
<a name="l01307"></a>01307       <span class="keywordflow">break</span>;
<a name="l01308"></a>01308    <span class="keywordflow">default</span>:
<a name="l01309"></a>01309       <span class="keywordflow">return</span> CL_INVALID_VALUE;
<a name="l01310"></a>01310       <span class="keywordflow">break</span>;
<a name="l01311"></a>01311    }
<a name="l01312"></a>01312    <span class="keywordflow">return</span> CL_SUCCESS;
<a name="l01313"></a>01313 }
<a name="l01314"></a>01314 
<a name="l01315"></a>01315 <span class="keyword">extern</span> CL_API_ENTRY cl_int CL_API_CALL
<a name="l01316"></a><a class="code" href="opencl__runtime__api_8cc.html#a6ce8a28686e4152fd5ab669b28c068f6">01316</a> <a class="code" href="opencl__runtime__api_8cc.html#a6ce8a28686e4152fd5ab669b28c068f6">clWaitForEvents</a>(cl_uint             <span class="comment">/* num_events */</span>,
<a name="l01317"></a>01317                 <span class="keyword">const</span> cl_event *    <span class="comment">/* event_list */</span>) CL_API_SUFFIX__VERSION_1_0
<a name="l01318"></a>01318 {
<a name="l01319"></a>01319    <span class="keywordflow">return</span> CL_SUCCESS;
<a name="l01320"></a>01320 }
<a name="l01321"></a>01321 
<a name="l01322"></a>01322 <span class="keyword">extern</span> CL_API_ENTRY cl_int CL_API_CALL
<a name="l01323"></a><a class="code" href="opencl__runtime__api_8cc.html#acc7516ae070540948b4ffb02555ad8cf">01323</a> <a class="code" href="opencl__runtime__api_8cc.html#acc7516ae070540948b4ffb02555ad8cf">clReleaseEvent</a>(cl_event <span class="comment">/* event */</span>) CL_API_SUFFIX__VERSION_1_0
<a name="l01324"></a>01324 {
<a name="l01325"></a>01325    <span class="keywordflow">return</span> CL_SUCCESS;
<a name="l01326"></a>01326 }
<a name="l01327"></a>01327 
<a name="l01328"></a>01328 <span class="keyword">extern</span> CL_API_ENTRY cl_int CL_API_CALL
<a name="l01329"></a><a class="code" href="opencl__runtime__api_8cc.html#add6f115c49cf3d1cf2f4e5c7280679ee">01329</a> <a class="code" href="opencl__runtime__api_8cc.html#add6f115c49cf3d1cf2f4e5c7280679ee">clGetCommandQueueInfo</a>(cl_command_queue      command_queue,
<a name="l01330"></a>01330                       cl_command_queue_info param_name,
<a name="l01331"></a>01331                       <span class="keywordtype">size_t</span>                param_value_size,
<a name="l01332"></a>01332                       <span class="keywordtype">void</span> *                param_value,
<a name="l01333"></a>01333                       <span class="keywordtype">size_t</span> *              param_value_size_ret ) CL_API_SUFFIX__VERSION_1_0
<a name="l01334"></a>01334 {
<a name="l01335"></a>01335    <span class="keywordflow">if</span>( command_queue == NULL ) 
<a name="l01336"></a>01336       <span class="keywordflow">return</span> CL_INVALID_COMMAND_QUEUE;
<a name="l01337"></a>01337    <span class="keywordflow">switch</span>( param_name ) {
<a name="l01338"></a>01338    <span class="keywordflow">case</span> CL_QUEUE_CONTEXT: CL_CASE(cl_context, command_queue-&gt;get_context()); <span class="keywordflow">break</span>;
<a name="l01339"></a>01339    <span class="keywordflow">case</span> CL_QUEUE_DEVICE: CL_CASE(cl_device_id, command_queue-&gt;get_device()); <span class="keywordflow">break</span>;
<a name="l01340"></a>01340    <span class="keywordflow">case</span> CL_QUEUE_REFERENCE_COUNT: CL_CASE(cl_uint,1); <span class="keywordflow">break</span>;
<a name="l01341"></a>01341    <span class="keywordflow">case</span> CL_QUEUE_PROPERTIES: CL_CASE(cl_command_queue_properties, command_queue-&gt;get_properties()); <span class="keywordflow">break</span>;
<a name="l01342"></a>01342    <span class="keywordflow">default</span>:
<a name="l01343"></a>01343       <span class="keywordflow">return</span> CL_INVALID_VALUE;
<a name="l01344"></a>01344    }
<a name="l01345"></a>01345    <span class="keywordflow">return</span> CL_SUCCESS;
<a name="l01346"></a>01346 }
<a name="l01347"></a>01347 
<a name="l01348"></a>01348 <span class="keyword">extern</span> CL_API_ENTRY cl_int CL_API_CALL
<a name="l01349"></a><a class="code" href="opencl__runtime__api_8cc.html#adbbe37091a2252f35d90bb74173302f5">01349</a> <a class="code" href="opencl__runtime__api_8cc.html#adbbe37091a2252f35d90bb74173302f5">clFlush</a>(cl_command_queue <span class="comment">/* command_queue */</span>) CL_API_SUFFIX__VERSION_1_0
<a name="l01350"></a>01350 {
<a name="l01351"></a>01351    <span class="keywordflow">return</span> CL_SUCCESS;
<a name="l01352"></a>01352 }
<a name="l01353"></a>01353 
<a name="l01354"></a>01354 <span class="keyword">extern</span> CL_API_ENTRY cl_int CL_API_CALL
<a name="l01355"></a><a class="code" href="opencl__runtime__api_8cc.html#aacb18cfb5657ec9da0fb9480dc2e4d18">01355</a> <a class="code" href="opencl__runtime__api_8cc.html#aacb18cfb5657ec9da0fb9480dc2e4d18">clGetSupportedImageFormats</a>(cl_context           context,
<a name="l01356"></a>01356                            cl_mem_flags         flags,
<a name="l01357"></a>01357                            cl_mem_object_type   image_type,
<a name="l01358"></a>01358                            cl_uint              num_entries,
<a name="l01359"></a>01359                            cl_image_format *    image_formats,
<a name="l01360"></a>01360                            cl_uint *            num_image_formats) CL_API_SUFFIX__VERSION_1_0
<a name="l01361"></a>01361 {
<a name="l01362"></a>01362    <span class="keywordflow">if</span>( !context ) 
<a name="l01363"></a>01363       <span class="keywordflow">return</span> CL_INVALID_CONTEXT;
<a name="l01364"></a>01364    <span class="keywordflow">if</span>( flags == CL_MEM_READ_ONLY ) {
<a name="l01365"></a>01365       <span class="keywordflow">if</span>( image_type == CL_MEM_OBJECT_IMAGE2D || image_type == CL_MEM_OBJECT_IMAGE2D ) {
<a name="l01366"></a>01366          <span class="keywordflow">if</span>( num_entries == 0 || image_formats == NULL ) {
<a name="l01367"></a>01367             <span class="keywordflow">if</span>( num_image_formats != NULL ) 
<a name="l01368"></a>01368                *num_image_formats = 71;
<a name="l01369"></a>01369          } <span class="keywordflow">else</span> {
<a name="l01370"></a>01370             <span class="keywordflow">if</span>( num_entries != 71 ) 
<a name="l01371"></a>01371                <a class="code" href="opencl__runtime__api_8cc.html#a76e0dd21ab0c687276cb8617d0c17e8d">opencl_not_implemented</a>(__my_func__,__LINE__);
<a name="l01372"></a>01372             image_formats[0].image_channel_order = CL_R;                        image_formats[0].image_channel_data_type = CL_FLOAT               ;
<a name="l01373"></a>01373             image_formats[1].image_channel_order = CL_R;                        image_formats[1].image_channel_data_type = CL_HALF_FLOAT          ;
<a name="l01374"></a>01374             image_formats[2].image_channel_order = CL_R;                        image_formats[2].image_channel_data_type = CL_UNORM_INT8          ;
<a name="l01375"></a>01375             image_formats[3].image_channel_order = CL_R;                        image_formats[3].image_channel_data_type = CL_UNORM_INT16         ;
<a name="l01376"></a>01376             image_formats[4].image_channel_order = CL_R;                        image_formats[4].image_channel_data_type = CL_SNORM_INT16         ;
<a name="l01377"></a>01377             image_formats[5].image_channel_order = CL_R;                        image_formats[5].image_channel_data_type = CL_SIGNED_INT8         ;
<a name="l01378"></a>01378             image_formats[6].image_channel_order = CL_R;                        image_formats[6].image_channel_data_type = CL_SIGNED_INT16        ;
<a name="l01379"></a>01379             image_formats[7].image_channel_order = CL_R;                        image_formats[7].image_channel_data_type = CL_SIGNED_INT32        ;
<a name="l01380"></a>01380             image_formats[8].image_channel_order = CL_R;                        image_formats[8].image_channel_data_type = CL_UNSIGNED_INT8       ;
<a name="l01381"></a>01381             image_formats[9].image_channel_order = CL_R;                        image_formats[9].image_channel_data_type = CL_UNSIGNED_INT16      ;
<a name="l01382"></a>01382             image_formats[10].image_channel_order = CL_R;                       image_formats[10].image_channel_data_type = CL_UNSIGNED_INT32     ;
<a name="l01383"></a>01383             image_formats[11].image_channel_order = CL_A;                       image_formats[11].image_channel_data_type = CL_FLOAT              ;
<a name="l01384"></a>01384             image_formats[12].image_channel_order = CL_A;                       image_formats[12].image_channel_data_type = CL_HALF_FLOAT         ;
<a name="l01385"></a>01385             image_formats[13].image_channel_order = CL_A;                       image_formats[13].image_channel_data_type = CL_UNORM_INT8         ;
<a name="l01386"></a>01386             image_formats[14].image_channel_order = CL_A;                       image_formats[14].image_channel_data_type = CL_UNORM_INT16        ;
<a name="l01387"></a>01387             image_formats[15].image_channel_order = CL_A;                       image_formats[15].image_channel_data_type = CL_SNORM_INT16        ;
<a name="l01388"></a>01388             image_formats[16].image_channel_order = CL_A;                       image_formats[16].image_channel_data_type = CL_SIGNED_INT8        ;
<a name="l01389"></a>01389             image_formats[17].image_channel_order = CL_A;                       image_formats[17].image_channel_data_type = CL_SIGNED_INT16       ;
<a name="l01390"></a>01390             image_formats[18].image_channel_order = CL_A;                       image_formats[18].image_channel_data_type = CL_SIGNED_INT32       ;
<a name="l01391"></a>01391             image_formats[19].image_channel_order = CL_A;                       image_formats[19].image_channel_data_type = CL_UNSIGNED_INT8      ;
<a name="l01392"></a>01392             image_formats[20].image_channel_order = CL_A;                       image_formats[20].image_channel_data_type = CL_UNSIGNED_INT16     ;
<a name="l01393"></a>01393             image_formats[21].image_channel_order = CL_A;                       image_formats[21].image_channel_data_type = CL_UNSIGNED_INT32     ;
<a name="l01394"></a>01394             image_formats[22].image_channel_order = CL_RG;                      image_formats[22].image_channel_data_type = CL_FLOAT              ;
<a name="l01395"></a>01395             image_formats[23].image_channel_order = CL_RG;                      image_formats[23].image_channel_data_type = CL_HALF_FLOAT         ;
<a name="l01396"></a>01396             image_formats[24].image_channel_order = CL_RG;                      image_formats[24].image_channel_data_type = CL_UNORM_INT8         ;
<a name="l01397"></a>01397             image_formats[25].image_channel_order = CL_RG;                      image_formats[25].image_channel_data_type = CL_UNORM_INT16        ;
<a name="l01398"></a>01398             image_formats[26].image_channel_order = CL_RG;                      image_formats[26].image_channel_data_type = CL_SNORM_INT16        ;
<a name="l01399"></a>01399             image_formats[27].image_channel_order = CL_RG;                      image_formats[27].image_channel_data_type = CL_SIGNED_INT8        ;
<a name="l01400"></a>01400             image_formats[28].image_channel_order = CL_RG;                      image_formats[28].image_channel_data_type = CL_SIGNED_INT16       ;
<a name="l01401"></a>01401             image_formats[29].image_channel_order = CL_RG;                      image_formats[29].image_channel_data_type = CL_SIGNED_INT32       ;
<a name="l01402"></a>01402             image_formats[30].image_channel_order = CL_RG;                      image_formats[30].image_channel_data_type = CL_UNSIGNED_INT8      ;
<a name="l01403"></a>01403             image_formats[31].image_channel_order = CL_RG;                      image_formats[31].image_channel_data_type = CL_UNSIGNED_INT16     ;
<a name="l01404"></a>01404             image_formats[32].image_channel_order = CL_RG;                      image_formats[32].image_channel_data_type = CL_UNSIGNED_INT32     ;
<a name="l01405"></a>01405             image_formats[33].image_channel_order = CL_RA;                      image_formats[33].image_channel_data_type = CL_FLOAT              ;
<a name="l01406"></a>01406             image_formats[34].image_channel_order = CL_RA;                      image_formats[34].image_channel_data_type = CL_HALF_FLOAT         ;
<a name="l01407"></a>01407             image_formats[35].image_channel_order = CL_RA;                      image_formats[35].image_channel_data_type = CL_UNORM_INT8         ;
<a name="l01408"></a>01408             image_formats[36].image_channel_order = CL_RA;                      image_formats[36].image_channel_data_type = CL_UNORM_INT16        ;
<a name="l01409"></a>01409             image_formats[37].image_channel_order = CL_RA;                      image_formats[37].image_channel_data_type = CL_SNORM_INT16        ;
<a name="l01410"></a>01410             image_formats[38].image_channel_order = CL_RA;                      image_formats[38].image_channel_data_type = CL_SIGNED_INT8        ;
<a name="l01411"></a>01411             image_formats[39].image_channel_order = CL_RA;                      image_formats[39].image_channel_data_type = CL_SIGNED_INT16       ;
<a name="l01412"></a>01412             image_formats[40].image_channel_order = CL_RA;                      image_formats[40].image_channel_data_type = CL_SIGNED_INT32       ;
<a name="l01413"></a>01413             image_formats[41].image_channel_order = CL_RA;                      image_formats[41].image_channel_data_type = CL_UNSIGNED_INT8      ;
<a name="l01414"></a>01414             image_formats[42].image_channel_order = CL_RA;                      image_formats[42].image_channel_data_type = CL_UNSIGNED_INT16     ;
<a name="l01415"></a>01415             image_formats[43].image_channel_order = CL_RA;                      image_formats[43].image_channel_data_type = CL_UNSIGNED_INT32     ;
<a name="l01416"></a>01416             image_formats[44].image_channel_order = CL_RGBA;                    image_formats[44].image_channel_data_type = CL_FLOAT              ;
<a name="l01417"></a>01417             image_formats[45].image_channel_order = CL_RGBA;                    image_formats[45].image_channel_data_type = CL_HALF_FLOAT         ;
<a name="l01418"></a>01418             image_formats[46].image_channel_order = CL_RGBA;                    image_formats[46].image_channel_data_type = CL_UNORM_INT8         ;
<a name="l01419"></a>01419             image_formats[47].image_channel_order = CL_RGBA;                    image_formats[47].image_channel_data_type = CL_UNORM_INT16        ;
<a name="l01420"></a>01420             image_formats[48].image_channel_order = CL_RGBA;                    image_formats[48].image_channel_data_type = CL_SNORM_INT16        ;
<a name="l01421"></a>01421             image_formats[49].image_channel_order = CL_RGBA;                    image_formats[49].image_channel_data_type = CL_SIGNED_INT8        ;
<a name="l01422"></a>01422             image_formats[50].image_channel_order = CL_RGBA;                    image_formats[50].image_channel_data_type = CL_SIGNED_INT16       ;
<a name="l01423"></a>01423             image_formats[51].image_channel_order = CL_RGBA;                    image_formats[51].image_channel_data_type = CL_SIGNED_INT32       ;
<a name="l01424"></a>01424             image_formats[52].image_channel_order = CL_RGBA;                    image_formats[52].image_channel_data_type = CL_UNSIGNED_INT8      ;
<a name="l01425"></a>01425             image_formats[53].image_channel_order = CL_RGBA;                    image_formats[53].image_channel_data_type = CL_UNSIGNED_INT16     ;
<a name="l01426"></a>01426             image_formats[54].image_channel_order = CL_RGBA;                    image_formats[54].image_channel_data_type = CL_UNSIGNED_INT32     ;
<a name="l01427"></a>01427             image_formats[55].image_channel_order = CL_BGRA;                    image_formats[55].image_channel_data_type = CL_UNORM_INT8         ;
<a name="l01428"></a>01428             image_formats[56].image_channel_order = CL_BGRA;                    image_formats[56].image_channel_data_type = CL_SIGNED_INT8        ;
<a name="l01429"></a>01429             image_formats[57].image_channel_order = CL_BGRA;                    image_formats[57].image_channel_data_type = CL_UNSIGNED_INT8      ;
<a name="l01430"></a>01430             image_formats[58].image_channel_order = CL_ARGB;                    image_formats[58].image_channel_data_type = CL_UNORM_INT8         ;
<a name="l01431"></a>01431             image_formats[59].image_channel_order = CL_ARGB;                    image_formats[59].image_channel_data_type = CL_SIGNED_INT8        ;
<a name="l01432"></a>01432             image_formats[60].image_channel_order = CL_ARGB;                    image_formats[60].image_channel_data_type = CL_UNSIGNED_INT8      ;
<a name="l01433"></a>01433             image_formats[61].image_channel_order = CL_INTENSITY;               image_formats[61].image_channel_data_type = CL_FLOAT              ;
<a name="l01434"></a>01434             image_formats[62].image_channel_order = CL_INTENSITY;               image_formats[62].image_channel_data_type = CL_HALF_FLOAT         ;
<a name="l01435"></a>01435             image_formats[63].image_channel_order = CL_INTENSITY;               image_formats[63].image_channel_data_type = CL_UNORM_INT8         ;
<a name="l01436"></a>01436             image_formats[64].image_channel_order = CL_INTENSITY;               image_formats[64].image_channel_data_type = CL_UNORM_INT16        ;
<a name="l01437"></a>01437             image_formats[65].image_channel_order = CL_INTENSITY;               image_formats[65].image_channel_data_type = CL_SNORM_INT16        ;
<a name="l01438"></a>01438             image_formats[66].image_channel_order = CL_LUMINANCE;               image_formats[66].image_channel_data_type = CL_FLOAT              ;
<a name="l01439"></a>01439             image_formats[67].image_channel_order = CL_LUMINANCE;               image_formats[67].image_channel_data_type = CL_HALF_FLOAT         ;
<a name="l01440"></a>01440             image_formats[68].image_channel_order = CL_LUMINANCE;               image_formats[68].image_channel_data_type = CL_UNORM_INT8         ;
<a name="l01441"></a>01441             image_formats[69].image_channel_order = CL_LUMINANCE;               image_formats[69].image_channel_data_type = CL_UNORM_INT16        ;
<a name="l01442"></a>01442             image_formats[70].image_channel_order = CL_LUMINANCE;               image_formats[70].image_channel_data_type = CL_SNORM_INT16        ;
<a name="l01443"></a>01443          }
<a name="l01444"></a>01444       } <span class="keywordflow">else</span> <span class="keywordflow">return</span> CL_INVALID_VALUE;
<a name="l01445"></a>01445    } <span class="keywordflow">else</span> {
<a name="l01446"></a>01446       <a class="code" href="opencl__runtime__api_8cc.html#a76e0dd21ab0c687276cb8617d0c17e8d">opencl_not_implemented</a>(__my_func__,__LINE__);
<a name="l01447"></a>01447    }
<a name="l01448"></a>01448    <span class="keywordflow">return</span> CL_SUCCESS;
<a name="l01449"></a>01449 }
<a name="l01450"></a>01450 
<a name="l01451"></a>01451 <span class="keyword">extern</span> CL_API_ENTRY <span class="keywordtype">void</span> * CL_API_CALL
<a name="l01452"></a><a class="code" href="opencl__runtime__api_8cc.html#a01fe260d476405bf5085a25299ff0f75">01452</a> <a class="code" href="opencl__runtime__api_8cc.html#a01fe260d476405bf5085a25299ff0f75">clEnqueueMapBuffer</a>(cl_command_queue command_queue,
<a name="l01453"></a>01453                    cl_mem           buffer,
<a name="l01454"></a>01454                    cl_bool          blocking_map, 
<a name="l01455"></a>01455                    cl_map_flags     map_flags,
<a name="l01456"></a>01456                    <span class="keywordtype">size_t</span>           offset,
<a name="l01457"></a>01457                    <span class="keywordtype">size_t</span>           cb,
<a name="l01458"></a>01458                    cl_uint          num_events_in_wait_list,
<a name="l01459"></a>01459                    <span class="keyword">const</span> cl_event * event_wait_list,
<a name="l01460"></a>01460                    cl_event *       event,
<a name="l01461"></a>01461                    cl_int *         errcode_ret ) CL_API_SUFFIX__VERSION_1_0
<a name="l01462"></a>01462 {
<a name="l01463"></a>01463    <a class="code" href="struct__cl__mem.html">_cl_mem</a> *mem = command_queue-&gt;get_context()-&gt;lookup_mem(buffer);
<a name="l01464"></a>01464    assert( mem-&gt;<a class="code" href="struct__cl__mem.html#a0fa4be6f84f1dcb2038661c1acf608b4">is_on_host</a>() );
<a name="l01465"></a>01465    <span class="keywordflow">return</span> mem-&gt;<a class="code" href="struct__cl__mem.html#ae428f8f9f2b1e0ccc66dc8fcf86c263a">host_ptr</a>();
<a name="l01466"></a>01466 }
<a name="l01467"></a>01467 
<a name="l01468"></a>01468 
<a name="l01469"></a>01469 <span class="keyword">extern</span> CL_API_ENTRY cl_int CL_API_CALL
<a name="l01470"></a><a class="code" href="opencl__runtime__api_8cc.html#ad131afc0f3bcbaa003e6e27b2afcdf91">01470</a> <a class="code" href="opencl__runtime__api_8cc.html#ad131afc0f3bcbaa003e6e27b2afcdf91">clSetCommandQueueProperty</a>( cl_command_queue command_queue,
<a name="l01471"></a>01471                               cl_command_queue_properties properties,
<a name="l01472"></a>01472                               cl_bool enable,
<a name="l01473"></a>01473                               cl_command_queue_properties *old_properties
<a name="l01474"></a>01474                            ) CL_API_SUFFIX__VERSION_1_0
<a name="l01475"></a>01475 {
<a name="l01476"></a>01476    <span class="comment">// TODO: do something here</span>
<a name="l01477"></a>01477    <span class="keywordflow">return</span> CL_SUCCESS;
<a name="l01478"></a>01478 }
<a name="l01479"></a>01479 
</pre></div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 13 May 2014 for GPGPU-Sim by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
